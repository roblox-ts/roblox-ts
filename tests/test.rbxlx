<roblox version="4">
  <Item class="ReplicatedStorage" referent="0">
    <Properties>
      <string name="Name">ReplicatedStorage</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">include</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">Promise</string>
          <string name="Source"><![CDATA[--[[
	An implementation of Promises similar to Promise/A+.
]]

local ERROR_NON_PROMISE_IN_LIST = "Non-promise value passed into %s at index %s"
local ERROR_NON_LIST = "Please pass a list of promises to %s"
local ERROR_NON_FUNCTION = "Please pass a handler function to %s!"
local MODE_KEY_METATABLE = { __mode = "k" }

local function isCallable(value)
	if type(value) == "function" then
		return true
	end

	if type(value) == "table" then
		local metatable = getmetatable(value)
		if metatable and type(rawget(metatable, "__call")) == "function" then
			return true
		end
	end

	return false
end

--[[
	Creates an enum dictionary with some metamethods to prevent common mistakes.
]]
local function makeEnum(enumName, members)
	local enum = {}

	for _, memberName in ipairs(members) do
		enum[memberName] = memberName
	end

	return setmetatable(enum, {
		__index = function(_, k)
			error(string.format("%s is not in %s!", k, enumName), 2)
		end,
		__newindex = function()
			error(string.format("Creating new members in %s is not allowed!", enumName), 2)
		end,
	})
end

--[=[
	An object to represent runtime errors that occur during execution.
	Promises that experience an error like this will be rejected with
	an instance of this object.

	@class Error
]=]
local Error
do
	Error = {
		Kind = makeEnum("Promise.Error.Kind", {
			"ExecutionError",
			"AlreadyCancelled",
			"NotResolvedInTime",
			"TimedOut",
		}),
	}
	Error.__index = Error

	function Error.new(options, parent)
		options = options or {}
		return setmetatable({
			error = tostring(options.error) or "[This error has no error text.]",
			trace = options.trace,
			context = options.context,
			kind = options.kind,
			parent = parent,
			createdTick = os.clock(),
			createdTrace = debug.traceback(),
		}, Error)
	end

	function Error.is(anything)
		if type(anything) == "table" then
			local metatable = getmetatable(anything)

			if type(metatable) == "table" then
				return rawget(anything, "error") ~= nil and type(rawget(metatable, "extend")) == "function"
			end
		end

		return false
	end

	function Error.isKind(anything, kind)
		assert(kind ~= nil, "Argument #2 to Promise.Error.isKind must not be nil")

		return Error.is(anything) and anything.kind == kind
	end

	function Error:extend(options)
		options = options or {}

		options.kind = options.kind or self.kind

		return Error.new(options, self)
	end

	function Error:getErrorChain()
		local runtimeErrors = { self }

		while runtimeErrors[#runtimeErrors].parent do
			table.insert(runtimeErrors, runtimeErrors[#runtimeErrors].parent)
		end

		return runtimeErrors
	end

	function Error:__tostring()
		local errorStrings = {
			string.format("-- Promise.Error(%s) --", self.kind or "?"),
		}

		for _, runtimeError in ipairs(self:getErrorChain()) do
			table.insert(
				errorStrings,
				table.concat({
					runtimeError.trace or runtimeError.error,
					runtimeError.context,
				}, "\n")
			)
		end

		return table.concat(errorStrings, "\n")
	end
end

--[[
	Packs a number of arguments into a table and returns its length.

	Used to cajole varargs without dropping sparse values.
]]
local function pack(...)
	return select("#", ...), { ... }
end

--[[
	Returns first value (success), and packs all following values.
]]
local function packResult(success, ...)
	return success, select("#", ...), { ... }
end

local function makeErrorHandler(traceback)
	assert(traceback ~= nil, "traceback is nil")

	return function(err)
		-- If the error object is already a table, forward it directly.
		-- Should we extend the error here and add our own trace?

		if type(err) == "table" then
			return err
		end

		return Error.new({
			error = err,
			kind = Error.Kind.ExecutionError,
			trace = debug.traceback(tostring(err), 2),
			context = "Promise created at:\n\n" .. traceback,
		})
	end
end

--[[
	Calls a Promise executor with error handling.
]]
local function runExecutor(traceback, callback, ...)
	return packResult(xpcall(callback, makeErrorHandler(traceback), ...))
end

--[[
	Creates a function that invokes a callback with correct error handling and
	resolution mechanisms.
]]
local function createAdvancer(traceback, callback, resolve, reject)
	return function(...)
		local ok, resultLength, result = runExecutor(traceback, callback, ...)

		if ok then
			resolve(unpack(result, 1, resultLength))
		else
			reject(result[1])
		end
	end
end

local function isEmpty(t)
	return next(t) == nil
end

--[=[
	An enum value used to represent the Promise's status.
	@interface Status
	@tag enum
	@within Promise
	.Started "Started" -- The Promise is executing, and not settled yet.
	.Resolved "Resolved" -- The Promise finished successfully.
	.Rejected "Rejected" -- The Promise was rejected.
	.Cancelled "Cancelled" -- The Promise was cancelled before it finished.
]=]
--[=[
	@prop Status Status
	@within Promise
	@readonly
	@tag enums
	A table containing all members of the `Status` enum, e.g., `Promise.Status.Resolved`.
]=]
--[=[
	A Promise is an object that represents a value that will exist in the future, but doesn't right now.
	Promises allow you to then attach callbacks that can run once the value becomes available (known as *resolving*),
	or if an error has occurred (known as *rejecting*).

	@class Promise
	@__index prototype
]=]
local Promise = {
	Error = Error,
	Status = makeEnum("Promise.Status", { "Started", "Resolved", "Rejected", "Cancelled" }),
	_getTime = os.clock,
	_timeEvent = game:GetService("RunService").Heartbeat,
	_unhandledRejectionCallbacks = {},
}
Promise.prototype = {}
Promise.__index = Promise.prototype

function Promise._new(traceback, callback, parent)
	if parent ~= nil and not Promise.is(parent) then
		error("Argument #2 to Promise.new must be a promise or nil", 2)
	end

	local self = {
		-- Used to locate where a promise was created
		_source = traceback,

		_status = Promise.Status.Started,

		-- A table containing a list of all results, whether success or failure.
		-- Only valid if _status is set to something besides Started
		_values = nil,

		-- Lua doesn't like sparse arrays very much, so we explicitly store the
		-- length of _values to handle middle nils.
		_valuesLength = -1,

		-- Tracks if this Promise has no error observers..
		_unhandledRejection = true,

		-- Queues representing functions we should invoke when we update!
		_queuedResolve = {},
		_queuedReject = {},
		_queuedFinally = {},

		-- The function to run when/if this promise is cancelled.
		_cancellationHook = nil,

		-- The "parent" of this promise in a promise chain. Required for
		-- cancellation propagation upstream.
		_parent = parent,

		-- Consumers are Promises that have chained onto this one.
		-- We track them for cancellation propagation downstream.
		_consumers = setmetatable({}, MODE_KEY_METATABLE),
	}

	if parent and parent._status == Promise.Status.Started then
		parent._consumers[self] = true
	end

	setmetatable(self, Promise)

	local function resolve(...)
		self:_resolve(...)
	end

	local function reject(...)
		self:_reject(...)
	end

	local function onCancel(cancellationHook)
		if cancellationHook then
			if self._status == Promise.Status.Cancelled then
				cancellationHook()
			else
				self._cancellationHook = cancellationHook
			end
		end

		return self._status == Promise.Status.Cancelled
	end

	coroutine.wrap(function()
		local ok, _, result = runExecutor(self._source, callback, resolve, reject, onCancel)

		if not ok then
			reject(result[1])
		end
	end)()

	return self
end

--[=[
	Construct a new Promise that will be resolved or rejected with the given callbacks.

	If you `resolve` with a Promise, it will be chained onto.

	You can safely yield within the executor function and it will not block the creating thread.

	```lua
	local myFunction()
		return Promise.new(function(resolve, reject, onCancel)
			wait(1)
			resolve("Hello world!")
		end)
	end

	myFunction():andThen(print)
	```

	You do not need to use `pcall` within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If `error()` is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into `Promise.Error(Promise.Error.Kind.ExecutionError)` objects for tracking debug information.

	You may register an optional cancellation hook by using the `onCancel` argument:

	* This should be used to abort any ongoing operations leading up to the promise being settled.
	* Call the `onCancel` function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled.
	* `onCancel` returns `true` if the Promise was already cancelled when you called `onCancel`.
	* Calling `onCancel` with no argument will not override a previously set cancellation hook, but it will still return `true` if the Promise is currently cancelled.
	* You can set the cancellation hook at any time before resolving.
	* When a promise is cancelled, calls to `resolve` or `reject` will be ignored, regardless of if you set a cancellation hook or not.

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.new(executor)
	return Promise._new(debug.traceback(nil, 2), executor)
end

function Promise:__tostring()
	return string.format("Promise(%s)", self._status)
end

--[=[
	The same as [Promise.new](/api/Promise#new), except execution begins after the next `Heartbeat` event.

	This is a spiritual replacement for `spawn`, but it does not suffer from the same [issues](https://eryn.io/gist/3db84579866c099cdd5bb2ff37947cec) as `spawn`.

	```lua
	local function waitForChild(instance, childName, timeout)
	  return Promise.defer(function(resolve, reject)
		local child = instance:WaitForChild(childName, timeout)

		;(child and resolve or reject)(child)
	  end)
	end
	```

	@param executor (resolve: (...: any) -> (), reject: (...: any) -> (), onCancel: (abortHandler?: () -> ()) -> boolean) -> ()
	@return Promise
]=]
function Promise.defer(executor)
	local traceback = debug.traceback(nil, 2)
	local promise
	promise = Promise._new(traceback, function(resolve, reject, onCancel)
		local connection
		connection = Promise._timeEvent:Connect(function()
			connection:Disconnect()
			local ok, _, result = runExecutor(traceback, executor, resolve, reject, onCancel)

			if not ok then
				reject(result[1])
			end
		end)
	end)

	return promise
end

-- Backwards compatibility
Promise.async = Promise.defer

--[=[
	Creates an immediately resolved Promise with the given value.

	```lua
	-- Example using Promise.resolve to deliver cached values:
	function getSomething(name)
		if cache[name] then
			return Promise.resolve(cache[name])
		else
			return Promise.new(function(resolve, reject)
				local thing = getTheThing()
				cache[name] = thing

				resolve(thing)
			end)
		end
	end
	```

	@param ... any
	@return Promise<...any>
]=]
function Promise.resolve(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(resolve)
		resolve(unpack(values, 1, length))
	end)
end

--[=[
	Creates an immediately rejected Promise with the given value.

	:::caution
	Something needs to consume this rejection (i.e. `:catch()` it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.
	:::

	@param ... any
	@return Promise<...any>
]=]
function Promise.reject(...)
	local length, values = pack(...)
	return Promise._new(debug.traceback(nil, 2), function(_, reject)
		reject(unpack(values, 1, length))
	end)
end

--[[
	Runs a non-promise-returning function as a Promise with the
  given arguments.
]]
function Promise._try(traceback, callback, ...)
	local valuesLength, values = pack(...)

	return Promise._new(traceback, function(resolve)
		resolve(callback(unpack(values, 1, valuesLength)))
	end)
end

--[=[
	Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback.

	:::info
	`Promise.try` is similar to [Promise.promisify](#promisify), except the callback is invoked immediately instead of returning a new function.
	:::

	```lua
	Promise.try(function()
		return math.random(1, 2) == 1 and "ok" or error("Oh an error!")
	end)
		:andThen(function(text)
			print(text)
		end)
		:catch(function(err)
			warn("Something went wrong")
		end)
	```

	@param callback (...: T...) -> ...any
	@param ... T... -- Additional arguments passed to `callback`
	@return Promise
]=]
function Promise.try(callback, ...)
	return Promise._try(debug.traceback(nil, 2), callback, ...)
end

--[[
	Returns a new promise that:
		* is resolved when all input promises resolve
		* is rejected if ANY input promises reject
]]
function Promise._all(traceback, promises, amount)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.all"), 3)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.all", tostring(i)), 3)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 or amount == 0 then
		return Promise.resolve({})
	end

	return Promise._new(traceback, function(resolve, reject, onCancel)
		-- An array to contain our resolved values from the given promises.
		local resolvedValues = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local resolvedCount = 0
		local rejectedCount = 0
		local done = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			if done then
				return
			end

			resolvedCount = resolvedCount + 1

			if amount == nil then
				resolvedValues[i] = ...
			else
				resolvedValues[resolvedCount] = ...
			end

			if resolvedCount >= (amount or #promises) then
				done = true
				resolve(resolvedValues)
				cancel()
			end
		end

		onCancel(cancel)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(function(...)
				resolveOne(i, ...)
			end, function(...)
				rejectedCount = rejectedCount + 1

				if amount == nil or #promises - rejectedCount < amount then
					cancel()
					done = true

					reject(...)
				end
			end)
		end

		if done then
			cancel()
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that:
	* is resolved after all input promises resolve.
	* is rejected if *any* input promises reject.

	:::info
	Only the first return value from each promise will be present in the resulting array.
	:::

	After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.all(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{T}>
]=]
function Promise.all(promises)
	return Promise._all(debug.traceback(nil, 2), promises)
end

--[=[
	Folds an array of values or promises into a single value. The array is traversed sequentially.

	The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value.

	The folding will stop at the first rejection encountered.
	```lua
	local basket = {"blueberry", "melon", "pear", "melon"}
	Promise.fold(basket, function(cost, fruit)
		if fruit == "blueberry" then
			return cost -- blueberries are free!
		else
			-- call a function that returns a promise with the fruit price
			return fetchPrice(fruit):andThen(function(fruitCost)
				return cost + fruitCost
			end)
		end
	end, 0)
	```

	@since v3.1.0
	@param list {T | Promise<T>}
	@param reducer (accumulator: U, value: T, index: number) -> U | Promise<U>
	@param initialValue U
]=]
function Promise.fold(list, reducer, initialValue)
	assert(type(list) == "table", "Bad argument #1 to Promise.fold: must be a table")
	assert(isCallable(reducer), "Bad argument #2 to Promise.fold: must be a function")

	local accumulator = Promise.resolve(initialValue)
	return Promise.each(list, function(resolvedElement, i)
		accumulator = accumulator:andThen(function(previousValueResolved)
			return reducer(previousValueResolved, resolvedElement, i)
		end)
	end):andThen(function()
		return accumulator
	end)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as `count` Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers.

	`count` 0 results in an empty array. The resultant array will never have more than `count` elements.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve
	```

	@param promises {Promise<T>}
	@param count number
	@return Promise<{T}>
]=]
function Promise.some(promises, count)
	assert(type(count) == "number", "Bad argument #2 to Promise.some: must be a number")

	return Promise._all(debug.traceback(nil, 2), promises, count)
end

--[=[
	Accepts an array of Promises and returns a Promise that is resolved as soon as *any* of the input Promises resolves. It will reject only if *all* input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers.

	Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with `1` count, except the Promise resolves with the value directly instead of an array with one element.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.any(promises)
	return Promise._all(debug.traceback(nil, 2), promises, 1):andThen(function(values)
		return values[1]
	end)
end

--[=[
	Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping `promise:finally` over the array of Promises.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.allSettled(promises)
	```

	@param promises {Promise<T>}
	@return Promise<{Status}>
]=]
function Promise.allSettled(promises)
	if type(promises) ~= "table" then
		error(string.format(ERROR_NON_LIST, "Promise.allSettled"), 2)
	end

	-- We need to check that each value is a promise here so that we can produce
	-- a proper error rather than a rejected promise with our error.
	for i, promise in pairs(promises) do
		if not Promise.is(promise) then
			error(string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.allSettled", tostring(i)), 2)
		end
	end

	-- If there are no values then return an already resolved promise.
	if #promises == 0 then
		return Promise.resolve({})
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		-- An array to contain our resolved values from the given promises.
		local fates = {}
		local newPromises = {}

		-- Keep a count of resolved promises because just checking the resolved
		-- values length wouldn't account for promises that resolve with nil.
		local finishedCount = 0

		-- Called when a single value is resolved and resolves if all are done.
		local function resolveOne(i, ...)
			finishedCount = finishedCount + 1

			fates[i] = ...

			if finishedCount >= #promises then
				resolve(fates)
			end
		end

		onCancel(function()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end)

		-- We can assume the values inside `promises` are all promises since we
		-- checked above.
		for i, promise in ipairs(promises) do
			newPromises[i] = promise:finally(function(...)
				resolveOne(i, ...)
			end)
		end
	end)
end

--[=[
	Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects.

	:::warning
	If the first Promise to settle from the array settles with a rejection, the resulting Promise from `race` will reject.

	If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use [Promise.any](#any) or [Promise.some](#some) instead.
	:::

	All other Promises that don't win the race will be cancelled if they have no other consumers.

	```lua
	local promises = {
		returnsAPromise("example 1"),
		returnsAPromise("example 2"),
		returnsAPromise("example 3"),
	}

	return Promise.race(promises) -- Only returns 1st value to resolve or reject
	```

	@param promises {Promise<T>}
	@return Promise<T>
]=]
function Promise.race(promises)
	assert(type(promises) == "table", string.format(ERROR_NON_LIST, "Promise.race"))

	for i, promise in pairs(promises) do
		assert(Promise.is(promise), string.format(ERROR_NON_PROMISE_IN_LIST, "Promise.race", tostring(i)))
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local newPromises = {}
		local finished = false

		local function cancel()
			for _, promise in ipairs(newPromises) do
				promise:cancel()
			end
		end

		local function finalize(callback)
			return function(...)
				cancel()
				finished = true
				return callback(...)
			end
		end

		if onCancel(finalize(reject)) then
			return
		end

		for i, promise in ipairs(promises) do
			newPromises[i] = promise:andThen(finalize(resolve), finalize(reject))
		end

		if finished then
			cancel()
		end
	end)
end

--[=[
	Iterates serially over the given an array of values, calling the predicate callback on each value before continuing.

	If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item
	in the array.

	:::info
	`Promise.each` is similar to `Promise.all`, except the Promises are ran in order instead of all at once.

	But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time.

	The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value.
	:::

	```lua
	Promise.each({
		"foo",
		"bar",
		"baz",
		"qux"
	}, function(value, index)
		return Promise.delay(1):andThen(function()
		print(("%d) Got %s!"):format(index, value))
		end)
	end)

	--[[
		(1 second passes)
		> 1) Got foo!
		(1 second passes)
		> 2) Got bar!
		(1 second passes)
		> 3) Got baz!
		(1 second passes)
		> 4) Got qux!
	]]
	```

	If the Promise a predicate returns rejects, the Promise from `Promise.each` is also rejected with the same value.

	If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value.

	If a Promise in the array of values is already Rejected when `Promise.each` is called, `Promise.each` rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when `Promise.each` is called, `Promise.each` rejects with `Promise.Error(Promise.Error.Kind.AlreadyCancelled`). If a Promise in the array of values is Started at first, but later rejects, `Promise.each` will reject with that value and iteration will not continue once iteration encounters that value.

	Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values.

	If this Promise returned from `Promise.each` rejects or is cancelled for any reason, the following are true:
	- Iteration will not continue.
	- Any Promises within the array of values will now be cancelled if they have no other consumers.
	- The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.

	@since 3.0.0
	@param list {T | Promise<T>}
	@param predicate (value: T, index: number) -> U | Promise<U>
	@return Promise<{U}>
]=]
function Promise.each(list, predicate)
	assert(type(list) == "table", string.format(ERROR_NON_LIST, "Promise.each"))
	assert(isCallable(predicate), string.format(ERROR_NON_FUNCTION, "Promise.each"))

	return Promise._new(debug.traceback(nil, 2), function(resolve, reject, onCancel)
		local results = {}
		local promisesToCancel = {}

		local cancelled = false

		local function cancel()
			for _, promiseToCancel in ipairs(promisesToCancel) do
				promiseToCancel:cancel()
			end
		end

		onCancel(function()
			cancelled = true

			cancel()
		end)

		-- We need to preprocess the list of values and look for Promises.
		-- If we find some, we must register our andThen calls now, so that those Promises have a consumer
		-- from us registered. If we don't do this, those Promises might get cancelled by something else
		-- before we get to them in the series because it's not possible to tell that we plan to use it
		-- unless we indicate it here.

		local preprocessedList = {}

		for index, value in ipairs(list) do
			if Promise.is(value) then
				if value:getStatus() == Promise.Status.Cancelled then
					cancel()
					return reject(Error.new({
						error = "Promise is cancelled",
						kind = Error.Kind.AlreadyCancelled,
						context = string.format(
							"The Promise that was part of the array at index %d passed into Promise.each was already cancelled when Promise.each began.\n\nThat Promise was created at:\n\n%s",
							index,
							value._source
						),
					}))
				elseif value:getStatus() == Promise.Status.Rejected then
					cancel()
					return reject(select(2, value:await()))
				end

				-- Chain a new Promise from this one so we only cancel ours
				local ourPromise = value:andThen(function(...)
					return ...
				end)

				table.insert(promisesToCancel, ourPromise)
				preprocessedList[index] = ourPromise
			else
				preprocessedList[index] = value
			end
		end

		for index, value in ipairs(preprocessedList) do
			if Promise.is(value) then
				local success
				success, value = value:await()

				if not success then
					cancel()
					return reject(value)
				end
			end

			if cancelled then
				return
			end

			local predicatePromise = Promise.resolve(predicate(value, index))

			table.insert(promisesToCancel, predicatePromise)

			local success, result = predicatePromise:await()

			if not success then
				cancel()
				return reject(result)
			end

			results[index] = result
		end

		resolve(results)
	end)
end

--[=[
	Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an `andThen` method.

	@param object any
	@return boolean -- `true` if the given `object` is a Promise.
]=]
function Promise.is(object)
	if type(object) ~= "table" then
		return false
	end

	local objectMetatable = getmetatable(object)

	if objectMetatable == Promise then
		-- The Promise came from this library.
		return true
	elseif objectMetatable == nil then
		-- No metatable, but we should still chain onto tables with andThen methods
		return isCallable(object.andThen)
	elseif
		type(objectMetatable) == "table"
		and type(rawget(objectMetatable, "__index")) == "table"
		and isCallable(rawget(rawget(objectMetatable, "__index"), "andThen"))
	then
		-- Maybe this came from a different or older Promise library.
		return true
	end

	return false
end

--[=[
	Wraps a function that yields into one that returns a Promise.

	Any errors that occur while executing the function will be turned into rejections.

	:::info
	`Promise.promisify` is similar to [Promise.try](#try), except the callback is returned as a callable function instead of being invoked immediately.
	:::

	```lua
	local sleep = Promise.promisify(wait)

	sleep(1):andThen(print)
	```

	```lua
	local isPlayerInGroup = Promise.promisify(function(player, groupId)
		return player:IsInGroup(groupId)
	end)
	```

	@param callback (...: any) -> ...any
	@return (...: any) -> Promise
]=]
function Promise.promisify(callback)
	return function(...)
		return Promise._try(debug.traceback(nil, 2), callback, ...)
	end
end

--[=[
	Returns a Promise that resolves after `seconds` seconds have passed. The Promise resolves with the actual amount of time that was waited.

	This function is **not** a wrapper around `wait`. `Promise.delay` uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler.

	:::warning
	Passing `NaN`, infinity, or a number less than 1/60 is equivalent to passing 1/60.
	:::

	```lua
		Promise.delay(5):andThenCall(print, "This prints after 5 seconds")
	```

	@function delay
	@within Promise
	@param seconds number
	@return Promise<number>
]=]
do
	-- uses a sorted doubly linked list (queue) to achieve O(1) remove operations and O(n) for insert

	-- the initial node in the linked list
	local first
	local connection

	function Promise.delay(seconds)
		assert(type(seconds) == "number", "Bad argument #1 to Promise.delay, must be a number.")
		-- If seconds is -INF, INF, NaN, or less than 1 / 60, assume seconds is 1 / 60.
		-- This mirrors the behavior of wait()
		if not (seconds >= 1 / 60) or seconds == math.huge then
			seconds = 1 / 60
		end

		return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
			local startTime = Promise._getTime()
			local endTime = startTime + seconds

			local node = {
				resolve = resolve,
				startTime = startTime,
				endTime = endTime,
			}

			if connection == nil then -- first is nil when connection is nil
				first = node
				connection = Promise._timeEvent:Connect(function()
					local threadStart = Promise._getTime()

					while first ~= nil and first.endTime < threadStart do
						local current = first
						first = current.next

						if first == nil then
							connection:Disconnect()
							connection = nil
						else
							first.previous = nil
						end

						current.resolve(Promise._getTime() - current.startTime)
					end
				end)
			else -- first is non-nil
				if first.endTime < endTime then -- if `node` should be placed after `first`
					-- we will insert `node` between `current` and `next`
					-- (i.e. after `current` if `next` is nil)
					local current = first
					local next = current.next

					while next ~= nil and next.endTime < endTime do
						current = next
						next = current.next
					end

					-- `current` must be non-nil, but `next` could be `nil` (i.e. last item in list)
					current.next = node
					node.previous = current

					if next ~= nil then
						node.next = next
						next.previous = node
					end
				else
					-- set `node` to `first`
					node.next = first
					first.previous = node
					first = node
				end
			end

			onCancel(function()
				-- remove node from queue
				local next = node.next

				if first == node then
					if next == nil then -- if `node` is the first and last
						connection:Disconnect()
						connection = nil
					else -- if `node` is `first` and not the last
						next.previous = nil
					end
					first = next
				else
					local previous = node.previous
					-- since `node` is not `first`, then we know `previous` is non-nil
					previous.next = next

					if next ~= nil then
						next.previous = previous
					end
				end
			end)
		end)
	end
end

--[=[
	Returns a new Promise that resolves if the chained Promise resolves within `seconds` seconds, or rejects if execution time exceeds `seconds`. The chained Promise will be cancelled if the timeout is reached.

	Rejects with `rejectionValue` if it is non-nil. If a `rejectionValue` is not given, it will reject with a `Promise.Error(Promise.Error.Kind.TimedOut)`. This can be checked with [[Error.isKind]].

	```lua
	getSomething():timeout(5):andThen(function(something)
		-- got something and it only took at max 5 seconds
	end):catch(function(e)
		-- Either getting something failed or the time was exceeded.

		if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then
			warn("Operation timed out!")
		else
			warn("Operation encountered an error!")
		end
	end)
	```

	Sugar for:

	```lua
	Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(
				rejectionValue == nil
				and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut })
				or rejectionValue
			)
		end),
		promise
	})
	```

	@param seconds number
	@param rejectionValue? any -- The value to reject with if the timeout is reached
	@return Promise
]=]
function Promise.prototype:timeout(seconds, rejectionValue)
	local traceback = debug.traceback(nil, 2)

	return Promise.race({
		Promise.delay(seconds):andThen(function()
			return Promise.reject(rejectionValue == nil and Error.new({
				kind = Error.Kind.TimedOut,
				error = "Timed out",
				context = string.format(
					"Timeout of %d seconds exceeded.\n:timeout() called at:\n\n%s",
					seconds,
					traceback
				),
			}) or rejectionValue)
		end),
		self,
	})
end

--[=[
	Returns the current Promise status.

	@return Status
]=]
function Promise.prototype:getStatus()
	return self._status
end

--[[
	Creates a new promise that receives the result of this promise.

	The given callbacks are invoked depending on that result.
]]
function Promise.prototype:_andThen(traceback, successHandler, failureHandler)
	self._unhandledRejection = false

	-- Create a new promise to follow this part of the chain
	return Promise._new(traceback, function(resolve, reject)
		-- Our default callbacks just pass values onto the next promise.
		-- This lets success and failure cascade correctly!

		local successCallback = resolve
		if successHandler then
			successCallback = createAdvancer(traceback, successHandler, resolve, reject)
		end

		local failureCallback = reject
		if failureHandler then
			failureCallback = createAdvancer(traceback, failureHandler, resolve, reject)
		end

		if self._status == Promise.Status.Started then
			-- If we haven't resolved yet, put ourselves into the queue
			table.insert(self._queuedResolve, successCallback)
			table.insert(self._queuedReject, failureCallback)
		elseif self._status == Promise.Status.Resolved then
			-- This promise has already resolved! Trigger success immediately.
			successCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Rejected then
			-- This promise died a terrible death! Trigger failure immediately.
			failureCallback(unpack(self._values, 1, self._valuesLength))
		elseif self._status == Promise.Status.Cancelled then
			-- We don't want to call the success handler or the failure handler,
			-- we just reject this promise outright.
			reject(Error.new({
				error = "Promise is cancelled",
				kind = Error.Kind.AlreadyCancelled,
				context = "Promise created at\n\n" .. traceback,
			}))
		end
	end, self)
end

--[=[
	Chains onto an existing Promise and returns a new Promise.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::

	Return a Promise from the success or failure handler and it will be chained onto.

	@param successHandler (...: any) -> ...any
	@param failureHandler? (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:andThen(successHandler, failureHandler)
	assert(successHandler == nil or isCallable(successHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:andThen"))

	return self:_andThen(debug.traceback(nil, 2), successHandler, failureHandler)
end

--[=[
	Shorthand for `Promise:andThen(nil, failureHandler)`.

	Returns a Promise that resolves if the `failureHandler` worked without encountering an additional error.

	:::warning
	Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call `tostring` on it first.
	:::


	@param failureHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:catch(failureHandler)
	assert(failureHandler == nil or isCallable(failureHandler), string.format(ERROR_NON_FUNCTION, "Promise:catch"))
	return self:_andThen(debug.traceback(nil, 2), nil, failureHandler)
end

--[=[
	Similar to [Promise.andThen](#andThen), except the return value is the same as the value passed to the handler. In other words, you can insert a `:tap` into a Promise chain without affecting the value that downstream Promises receive.

	```lua
		getTheValue()
		:tap(print)
		:andThen(function(theValue)
			print("Got", theValue, "even though print returns nil!")
		end)
	```

	If you return a Promise from the tap handler callback, its value will be discarded but `tap` will still wait until it resolves before passing the original value through.

	@param tapHandler (...: any) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:tap(tapHandler)
	assert(isCallable(tapHandler), string.format(ERROR_NON_FUNCTION, "Promise:tap"))
	return self:_andThen(debug.traceback(nil, 2), function(...)
		local callbackReturn = tapHandler(...)

		if Promise.is(callbackReturn) then
			local length, values = pack(...)
			return callbackReturn:andThen(function()
				return unpack(values, 1, length)
			end)
		end

		return ...
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded.

	```lua
		promise:andThenCall(someFunction, "some", "arguments")
	```

	This is sugar for

	```lua
		promise:andThen(function()
		return someFunction("some", "arguments")
		end)
	```

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:andThenCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:andThenCall"))
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches an `andThen` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:andThenReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:andThen(function()
			return "some", "values"
		end)
	```

	:::caution
	Promises are eager, so if you pass a Promise to `andThenReturn`, it will begin executing before `andThenReturn` is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into `andThenReturn`, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].
	:::

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:andThenReturn(...)
	local length, values = pack(...)
	return self:_andThen(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled.

	Cancellations will propagate upwards and downwards through chained promises.

	Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call `andThen` twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled.

	```lua
		promise:cancel()
	```
]=]
function Promise.prototype:cancel()
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Cancelled

	if self._cancellationHook then
		self._cancellationHook()
	end

	if self._parent then
		self._parent:_consumerCancelled(self)
	end

	for child in pairs(self._consumers) do
		child:cancel()
	end

	self:_finalize()
end

--[[
	Used to decrease the number of consumers by 1, and if there are no more,
	cancel this promise.
]]
function Promise.prototype:_consumerCancelled(consumer)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._consumers[consumer] = nil

	if next(self._consumers) == nil then
		self:cancel()
	end
end

--[[
	Used to set a handler for when the promise resolves, rejects, or is
	cancelled. Returns a new promise chained from this promise.
]]
function Promise.prototype:_finally(traceback, finallyHandler, onlyOk)
	if not onlyOk then
		self._unhandledRejection = false
	end

	-- Return a promise chained off of this promise
	return Promise._new(traceback, function(resolve, reject)
		local finallyCallback = resolve
		if finallyHandler then
			finallyCallback = createAdvancer(traceback, finallyHandler, resolve, reject)
		end

		if onlyOk then
			local callback = finallyCallback
			finallyCallback = function(...)
				if self._status == Promise.Status.Rejected then
					return resolve(self)
				end

				return callback(...)
			end
		end

		if self._status == Promise.Status.Started then
			-- The promise is not settled, so queue this.
			table.insert(self._queuedFinally, finallyCallback)
		else
			-- The promise already settled or was cancelled, run the callback now.
			finallyCallback(self._status)
		end
	end, self)
end

--[=[
	Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, *or* cancelled.

	Returns a new promise chained from this promise.

	:::caution
	If the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `finally` or `done` will run in the case of cancellation.
	:::

	```lua
	local thing = createSomething()

	doSomethingWith(thing)
		:andThen(function()
			print("It worked!")
			-- do something..
		end)
		:catch(function()
			warn("Oh no it failed!")
		end)
		:finally(function()
			-- either way, destroy thing

			thing:Destroy()
		end)

	```

	@param finallyHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:finally(finallyHandler)
	assert(finallyHandler == nil or isCallable(finallyHandler), string.format(ERROR_NON_FUNCTION, "Promise:finally"))
	return self:_finally(debug.traceback(nil, 2), finallyHandler)
end

--[=[
	Same as `andThenCall`, except for `finally`.

	Attaches a `finally` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:finallyCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:finallyCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end)
end

--[=[
	Attaches a `finally` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:finallyReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:finally(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:finallyReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end)
end

--[=[
	Set a handler that will be called only if the Promise resolves or is cancelled. This method is similar to `finally`, except it doesn't catch rejections.

	:::caution
	`done` should be reserved specifically when you want to perform some operation after the Promise is finished (like `finally`), but you don't want to consume rejections (like in <a href="/roblox-lua-promise/lib/Examples.html#cancellable-animation-sequence">this example</a>). You should use `andThen` instead if you only care about the Resolved case.
	:::

	:::warning
	Like `finally`, if the Promise is cancelled, any Promises chained off of it with `andThen` won't run. Only Promises chained with `done` and `finally` will run in the case of cancellation.
	:::

	Returns a new promise chained from this promise.

	@param doneHandler (status: Status) -> ...any
	@return Promise<...any>
]=]
function Promise.prototype:done(doneHandler)
	assert(doneHandler == nil or isCallable(doneHandler), string.format(ERROR_NON_FUNCTION, "Promise:done"))
	return self:_finally(debug.traceback(nil, 2), doneHandler, true)
end

--[=[
	Same as `andThenCall`, except for `done`.

	Attaches a `done` handler to this Promise that calls the given callback with the predefined arguments.

	@param callback (...: any) -> any
	@param ...? any -- Additional arguments which will be passed to `callback`
	@return Promise
]=]
function Promise.prototype:doneCall(callback, ...)
	assert(isCallable(callback), string.format(ERROR_NON_FUNCTION, "Promise:doneCall"))
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return callback(unpack(values, 1, length))
	end, true)
end

--[=[
	Attaches a `done` handler to this Promise that discards the resolved value and returns the given value from it.

	```lua
		promise:doneReturn("some", "values")
	```

	This is sugar for

	```lua
		promise:done(function()
			return "some", "values"
		end)
	```

	@param ... any -- Values to return from the function
	@return Promise
]=]
function Promise.prototype:doneReturn(...)
	local length, values = pack(...)
	return self:_finally(debug.traceback(nil, 2), function()
		return unpack(values, 1, length)
	end, true)
end

--[=[
	Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.

	@yields
	@return Status -- The Status representing the fate of the Promise
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:awaitStatus()
	self._unhandledRejection = false

	if self._status == Promise.Status.Started then
		local bindable = Instance.new("BindableEvent")

		self:finally(function()
			bindable:Fire()
		end)

		bindable.Event:Wait()
		bindable:Destroy()
	end

	if self._status == Promise.Status.Resolved then
		return self._status, unpack(self._values, 1, self._valuesLength)
	elseif self._status == Promise.Status.Rejected then
		return self._status, unpack(self._values, 1, self._valuesLength)
	end

	return self._status
end

local function awaitHelper(status, ...)
	return status == Promise.Status.Resolved, ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with.

	:::caution
	If the Promise gets cancelled, this function will return `false`, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead.
	:::

	```lua
		local worked, value = getTheValue():await()

	if worked then
		print("got", value)
	else
		warn("it failed")
	end
	```

	@yields
	@return boolean -- `true` if the Promise successfully resolved
	@return ...any -- The values the Promise resolved or rejected with.
]=]
function Promise.prototype:await()
	return awaitHelper(self:awaitStatus())
end

local function expectHelper(status, ...)
	if status ~= Promise.Status.Resolved then
		error((...) == nil and "Expected Promise rejected with no value." or (...), 3)
	end

	return ...
end

--[=[
	Yields the current thread until the given Promise completes. Returns the values that the promise resolved with.

	```lua
	local worked = pcall(function()
		print("got", getTheValue():expect())
	end)

	if not worked then
		warn("it failed")
	end
	```

	This is essentially sugar for:

	```lua
	select(2, assert(promise:await()))
	```

	**Errors** if the Promise rejects or gets cancelled.

	@error any -- Errors with the rejection value if this Promise rejects or gets cancelled.
	@yields
	@return ...any -- The values the Promise resolved with.
]=]
function Promise.prototype:expect()
	return expectHelper(self:awaitStatus())
end

-- Backwards compatibility
Promise.prototype.awaitValue = Promise.prototype.expect

--[[
	Intended for use in tests.

	Similar to await(), but instead of yielding if the promise is unresolved,
	_unwrap will throw. This indicates an assumption that a promise has
	resolved.
]]
function Promise.prototype:_unwrap()
	if self._status == Promise.Status.Started then
		error("Promise has not resolved or rejected.", 2)
	end

	local success = self._status == Promise.Status.Resolved

	return success, unpack(self._values, 1, self._valuesLength)
end

function Promise.prototype:_resolve(...)
	if self._status ~= Promise.Status.Started then
		if Promise.is((...)) then
			(...):_consumerCancelled(self)
		end
		return
	end

	-- If the resolved value was a Promise, we chain onto it!
	if Promise.is((...)) then
		-- Without this warning, arguments sometimes mysteriously disappear
		if select("#", ...) > 1 then
			local message = string.format(
				"When returning a Promise from andThen, extra arguments are " .. "discarded! See:\n\n%s",
				self._source
			)
			warn(message)
		end

		local chainedPromise = ...

		local promise = chainedPromise:andThen(function(...)
			self:_resolve(...)
		end, function(...)
			local maybeRuntimeError = chainedPromise._values[1]

			-- Backwards compatibility < v2
			if chainedPromise._error then
				maybeRuntimeError = Error.new({
					error = chainedPromise._error,
					kind = Error.Kind.ExecutionError,
					context = "[No stack trace available as this Promise originated from an older version of the Promise library (< v2)]",
				})
			end

			if Error.isKind(maybeRuntimeError, Error.Kind.ExecutionError) then
				return self:_reject(maybeRuntimeError:extend({
					error = "This Promise was chained to a Promise that errored.",
					trace = "",
					context = string.format(
						"The Promise at:\n\n%s\n...Rejected because it was chained to the following Promise, which encountered an error:\n",
						self._source
					),
				}))
			end

			self:_reject(...)
		end)

		if promise._status == Promise.Status.Cancelled then
			self:cancel()
		elseif promise._status == Promise.Status.Started then
			-- Adopt ourselves into promise for cancellation propagation.
			self._parent = promise
			promise._consumers[self] = true
		end

		return
	end

	self._status = Promise.Status.Resolved
	self._valuesLength, self._values = pack(...)

	-- We assume that these callbacks will not throw errors.
	for _, callback in ipairs(self._queuedResolve) do
		coroutine.wrap(callback)(...)
	end

	self:_finalize()
end

function Promise.prototype:_reject(...)
	if self._status ~= Promise.Status.Started then
		return
	end

	self._status = Promise.Status.Rejected
	self._valuesLength, self._values = pack(...)

	-- If there are any rejection handlers, call those!
	if not isEmpty(self._queuedReject) then
		-- We assume that these callbacks will not throw errors.
		for _, callback in ipairs(self._queuedReject) do
			coroutine.wrap(callback)(...)
		end
	else
		-- At this point, no one was able to observe the error.
		-- An error handler might still be attached if the error occurred
		-- synchronously. We'll wait one tick, and if there are still no
		-- observers, then we should put a message in the console.

		local err = tostring((...))

		coroutine.wrap(function()
			Promise._timeEvent:Wait()

			-- Someone observed the error, hooray!
			if not self._unhandledRejection then
				return
			end

			-- Build a reasonable message
			local message = string.format("Unhandled Promise rejection:\n\n%s\n\n%s", err, self._source)

			for _, callback in ipairs(Promise._unhandledRejectionCallbacks) do
				task.spawn(callback, self, unpack(self._values, 1, self._valuesLength))
			end

			if Promise.TEST then
				-- Don't spam output when we're running tests.
				return
			end

			warn(message)
		end)()
	end

	self:_finalize()
end

--[[
	Calls any :finally handlers. We need this to be a separate method and
	queue because we must call all of the finally callbacks upon a success,
	failure, *and* cancellation.
]]
function Promise.prototype:_finalize()
	for _, callback in ipairs(self._queuedFinally) do
		-- Purposefully not passing values to callbacks here, as it could be the
		-- resolved values, or rejected errors. If the developer needs the values,
		-- they should use :andThen or :catch explicitly.
		coroutine.wrap(callback)(self._status)
	end

	self._queuedFinally = nil
	self._queuedReject = nil
	self._queuedResolve = nil

	-- Clear references to other Promises to allow gc
	if not Promise.TEST then
		self._parent = nil
		self._consumers = nil
	end
end

--[=[
	Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling `:now()`. This can be used to ensure your `andThen` handler occurs on the same frame as the root Promise execution.

	```lua
	doSomething()
		:now()
		:andThen(function(value)
			print("Got", value, "synchronously.")
		end)
	```

	If this Promise is still running, Rejected, or Cancelled, the Promise returned from `:now()` will reject with the `rejectionValue` if passed, otherwise with a `Promise.Error(Promise.Error.Kind.NotResolvedInTime)`. This can be checked with [[Error.isKind]].

	@param rejectionValue? any -- The value to reject with if the Promise isn't resolved
	@return Promise
]=]
function Promise.prototype:now(rejectionValue)
	local traceback = debug.traceback(nil, 2)
	if self._status == Promise.Status.Resolved then
		return self:_andThen(traceback, function(...)
			return ...
		end)
	else
		return Promise.reject(rejectionValue == nil and Error.new({
			kind = Error.Kind.NotResolvedInTime,
			error = "This Promise was not resolved in time for :now()",
			context = ":now() was called at:\n\n" .. traceback,
		}) or rejectionValue)
	end
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	```lua
	local function canFail(a, b, c)
		return Promise.new(function(resolve, reject)
			-- do something that can fail

			local failed, thing = doSomethingThatCanFail(a, b, c)

			if failed then
				reject("it failed")
			else
				resolve(thing)
			end
		end)
	end

	local MAX_RETRIES = 10
	local value = Promise.retry(canFail, MAX_RETRIES, "foo", "bar", "baz") -- args to send to canFail
	```

	@since 3.0.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param ...? P
]=]
function Promise.retry(callback, times, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			return Promise.retry(callback, times - 1, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Repeatedly calls a Promise-returning function up to `times` number of times, waiting `seconds` seconds between each
	retry, until the returned Promise resolves.

	If the amount of retries is exceeded, the function will return the latest rejected Promise.

	@since v3.2.0
	@param callback (...: P) -> Promise<T>
	@param times number
	@param seconds number
	@param ...? P
]=]
function Promise.retryWithDelay(callback, times, seconds, ...)
	assert(isCallable(callback), "Parameter #1 to Promise.retry must be a function")
	assert(type(times) == "number", "Parameter #2 (times) to Promise.retry must be a number")
	assert(type(seconds) == "number", "Parameter #3 (seconds) to Promise.retry must be a number")

	local args, length = { ... }, select("#", ...)

	return Promise.resolve(callback(...)):catch(function(...)
		if times > 0 then
			Promise.delay(seconds):await()

			return Promise.retryWithDelay(callback, times - 1, seconds, unpack(args, 1, length))
		else
			return Promise.reject(...)
		end
	end)
end

--[=[
	Converts an event into a Promise which resolves the next time the event fires.

	The optional `predicate` callback, if passed, will receive the event arguments and should return `true` or `false`, based on if this fired event should resolve the Promise or not. If `true`, the Promise resolves. If `false`, nothing happens and the predicate will be rerun the next time the event fires.

	The Promise will resolve with the event arguments.

	:::tip
	This function will work given any object with a `Connect` method. This includes all Roblox events.
	:::

	```lua
	-- Creates a Promise which only resolves when `somePart` is touched
	-- by a part named `"Something specific"`.
	return Promise.fromEvent(somePart.Touched, function(part)
		return part.Name == "Something specific"
	end)
	```

	@since 3.0.0
	@param event Event -- Any object with a `Connect` method. This includes all Roblox events.
	@param predicate? (...: P) -> boolean -- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again.
	@return Promise<P>
]=]
function Promise.fromEvent(event, predicate)
	predicate = predicate or function()
		return true
	end

	return Promise._new(debug.traceback(nil, 2), function(resolve, _, onCancel)
		local connection
		local shouldDisconnect = false

		local function disconnect()
			connection:Disconnect()
			connection = nil
		end

		-- We use shouldDisconnect because if the callback given to Connect is called before
		-- Connect returns, connection will still be nil. This happens with events that queue up
		-- events when there's nothing connected, such as RemoteEvents

		connection = event:Connect(function(...)
			local callbackValue = predicate(...)

			if callbackValue == true then
				resolve(...)

				if connection then
					disconnect()
				else
					shouldDisconnect = true
				end
			elseif type(callbackValue) ~= "boolean" then
				error("Promise.fromEvent predicate should always return a boolean")
			end
		end)

		if shouldDisconnect and connection then
			return disconnect()
		end

		onCancel(disconnect)
	end)
end

--[=[
	Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise
	is rejected, and the rejection is not observed with `:catch`.

	The callback is called with the actual promise that rejected, followed by the rejection values.

	@since v3.2.0
	@param callback (promise: Promise, ...: any) -- A callback that runs when an unhandled rejection happens.
	@return () -> () -- Function that unregisters the `callback` when called
]=]
function Promise.onUnhandledRejection(callback)
	table.insert(Promise._unhandledRejectionCallbacks, callback)

	return function()
		local index = table.find(Promise._unhandledRejectionCallbacks, callback)

		if index then
			table.remove(Promise._unhandledRejectionCallbacks, index)
		end
	end
end

return Promise
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="3">
        <Properties>
          <string name="Name">RuntimeLib</string>
          <string name="Source"><![CDATA[local Promise = require(script.Parent.Promise)

local RunService = game:GetService("RunService")

local OUTPUT_PREFIX = "roblox-ts: "
local NODE_MODULES = "node_modules"
local DEFAULT_SCOPE = "@rbxts"

local TS = {}

TS.Promise = Promise

local function isPlugin(context)
	return RunService:IsStudio() and context:FindFirstAncestorWhichIsA("Plugin") ~= nil
end

function TS.getModule(context, scope, moduleName)
	-- legacy call signature
	if moduleName == nil then
		moduleName = scope
		scope = DEFAULT_SCOPE
	end

	-- ensure modules have fully replicated
	if RunService:IsRunning() and RunService:IsClient() and not isPlugin(context) and not game:IsLoaded() then
		game.Loaded:Wait()
	end

	local object = context
	repeat
		local nodeModulesFolder = object:FindFirstChild(NODE_MODULES)
		if nodeModulesFolder then
			local scopeFolder = nodeModulesFolder:FindFirstChild(scope)
			if scopeFolder then
				local module = scopeFolder:FindFirstChild(moduleName)
				if module then
					return module
				end
			end
		end
		object = object.Parent
	until object == nil

	error(OUTPUT_PREFIX .. "Could not find module: " .. moduleName, 2)
end

-- This is a hash which TS.import uses as a kind of linked-list-like history of [Script who Loaded] -> Library
local currentlyLoading = {}
local registeredLibraries = {}

function TS.import(context, module, ...)
	for i = 1, select("#", ...) do
		module = module:WaitForChild((select(i, ...)))
	end

	if module.ClassName ~= "ModuleScript" then
		error(OUTPUT_PREFIX .. "Failed to import! Expected ModuleScript, got " .. module.ClassName, 2)
	end

	currentlyLoading[context] = module

	-- Check to see if a case like this occurs:
	-- module -> Module1 -> Module2 -> module

	-- WHERE currentlyLoading[module] is Module1
	-- and currentlyLoading[Module1] is Module2
	-- and currentlyLoading[Module2] is module

	local currentModule = module
	local depth = 0

	while currentModule do
		depth = depth + 1
		currentModule = currentlyLoading[currentModule]

		if currentModule == module then
			local str = currentModule.Name -- Get the string traceback

			for _ = 1, depth do
				currentModule = currentlyLoading[currentModule]
				str = str .. "  ⇒ " .. currentModule.Name
			end

			error(OUTPUT_PREFIX .. "Failed to import! Detected a circular dependency chain: " .. str, 2)
		end
	end

	if not registeredLibraries[module] then
		if _G[module] then
			error(
				OUTPUT_PREFIX
				.. "Invalid module access! Do you have multiple TS runtimes trying to import this? "
				.. module:GetFullName(),
				2
			)
		end

		_G[module] = TS
		registeredLibraries[module] = true -- register as already loaded for subsequent calls
	end

	local data = require(module)

	if currentlyLoading[context] == module then -- Thread-safe cleanup!
		currentlyLoading[context] = nil
	end

	return data
end

function TS.instanceof(obj, class)
	-- custom Class.instanceof() check
	if type(class) == "table" and type(class.instanceof) == "function" then
		return class.instanceof(obj)
	end

	-- metatable check
	if type(obj) == "table" then
		obj = getmetatable(obj)
		while obj ~= nil do
			if obj == class then
				return true
			end
			local mt = getmetatable(obj)
			if mt then
				obj = mt.__index
			else
				obj = nil
			end
		end
	end

	return false
end

function TS.async(callback)
	return function(...)
		local n = select("#", ...)
		local args = { ... }
		return Promise.new(function(resolve, reject)
			coroutine.wrap(function()
				local ok, result = pcall(callback, unpack(args, 1, n))
				if ok then
					resolve(result)
				else
					reject(result)
				end
			end)()
		end)
	end
end

function TS.await(promise)
	if not Promise.is(promise) then
		return promise
	end

	local status, value = promise:awaitStatus()
	if status == Promise.Status.Resolved then
		return value
	elseif status == Promise.Status.Rejected then
		error(value, 2)
	else
		error("The awaited Promise was cancelled", 2)
	end
end

local SIGN = 2 ^ 31
local COMPLEMENT = 2 ^ 32
local function bit_sign(num)
	-- Restores the sign after an unsigned conversion according to 2s complement.
	if bit32.btest(num, SIGN) then
		return num - COMPLEMENT
	else
		return num
	end
end

function TS.bit_lrsh(a, b)
	return bit_sign(bit32.arshift(a, b))
end

TS.TRY_RETURN = 1
TS.TRY_BREAK = 2
TS.TRY_CONTINUE = 3

function TS.try(func, catch, finally)
	local err, traceback
	local success, exitType, returns = xpcall(
		func,
		function(errInner)
			err = errInner
			traceback = debug.traceback()
		end
	)
	if not success and catch then
		local newExitType, newReturns = catch(err, traceback)
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	if finally then
		local newExitType, newReturns = finally()
		if newExitType then
			exitType, returns = newExitType, newReturns
		end
	end
	return exitType, returns
end

function TS.generator(callback)
	local co = coroutine.create(callback)
	return {
		next = function(...)
			if coroutine.status(co) == "dead" then
				return { done = true }
			else
				local success, value = coroutine.resume(co, ...)
				if success == false then
					error(value, 2)
				end
				return {
					value = value,
					done = coroutine.status(co) == "dead",
				}
			end
		end,
	}
end

return TS
]]></string>
        </Properties>
      </Item>
      <Item class="Folder" referent="4">
        <Properties>
          <string name="Name">node_modules</string>
        </Properties>
        <Item class="Folder" referent="5">
          <Properties>
            <string name="Name">@rbxts</string>
          </Properties>
          <Item class="Folder" referent="6">
            <Properties>
              <string name="Name">compiler-types</string>
            </Properties>
            <Item class="Folder" referent="7">
              <Properties>
                <string name="Name">types</string>
              </Properties>
            </Item>
          </Item>
          <Item class="Folder" referent="8">
            <Properties>
              <string name="Name">roact</string>
            </Properties>
            <Item class="Folder" referent="9">
              <Properties>
                <string name="Name">.git</string>
              </Properties>
              <Item class="Folder" referent="10">
                <Properties>
                  <string name="Name">hooks</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="11">
                <Properties>
                  <string name="Name">info</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="12">
                <Properties>
                  <string name="Name">logs</string>
                </Properties>
                <Item class="Folder" referent="13">
                  <Properties>
                    <string name="Name">refs</string>
                  </Properties>
                  <Item class="Folder" referent="14">
                    <Properties>
                      <string name="Name">heads</string>
                    </Properties>
                  </Item>
                  <Item class="Folder" referent="15">
                    <Properties>
                      <string name="Name">remotes</string>
                    </Properties>
                    <Item class="Folder" referent="16">
                      <Properties>
                        <string name="Name">origin</string>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
              </Item>
              <Item class="Folder" referent="17">
                <Properties>
                  <string name="Name">objects</string>
                </Properties>
                <Item class="Folder" referent="18">
                  <Properties>
                    <string name="Name">00</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="19">
                  <Properties>
                    <string name="Name">01</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="20">
                  <Properties>
                    <string name="Name">02</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="21">
                  <Properties>
                    <string name="Name">03</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="22">
                  <Properties>
                    <string name="Name">05</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="23">
                  <Properties>
                    <string name="Name">06</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="24">
                  <Properties>
                    <string name="Name">07</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="25">
                  <Properties>
                    <string name="Name">08</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="26">
                  <Properties>
                    <string name="Name">0a</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="27">
                  <Properties>
                    <string name="Name">0b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="28">
                  <Properties>
                    <string name="Name">0d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="29">
                  <Properties>
                    <string name="Name">0e</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="30">
                  <Properties>
                    <string name="Name">0f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="31">
                  <Properties>
                    <string name="Name">11</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="32">
                  <Properties>
                    <string name="Name">12</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="33">
                  <Properties>
                    <string name="Name">14</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="34">
                  <Properties>
                    <string name="Name">15</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="35">
                  <Properties>
                    <string name="Name">16</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="36">
                  <Properties>
                    <string name="Name">18</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="37">
                  <Properties>
                    <string name="Name">1a</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="38">
                  <Properties>
                    <string name="Name">1b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="39">
                  <Properties>
                    <string name="Name">1c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="40">
                  <Properties>
                    <string name="Name">1d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="41">
                  <Properties>
                    <string name="Name">1e</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="42">
                  <Properties>
                    <string name="Name">1f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="43">
                  <Properties>
                    <string name="Name">20</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="44">
                  <Properties>
                    <string name="Name">22</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="45">
                  <Properties>
                    <string name="Name">23</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="46">
                  <Properties>
                    <string name="Name">24</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="47">
                  <Properties>
                    <string name="Name">26</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="48">
                  <Properties>
                    <string name="Name">29</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="49">
                  <Properties>
                    <string name="Name">2a</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="50">
                  <Properties>
                    <string name="Name">2b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="51">
                  <Properties>
                    <string name="Name">2c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="52">
                  <Properties>
                    <string name="Name">2d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="53">
                  <Properties>
                    <string name="Name">2e</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="54">
                  <Properties>
                    <string name="Name">2f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="55">
                  <Properties>
                    <string name="Name">30</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="56">
                  <Properties>
                    <string name="Name">33</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="57">
                  <Properties>
                    <string name="Name">34</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="58">
                  <Properties>
                    <string name="Name">35</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="59">
                  <Properties>
                    <string name="Name">37</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="60">
                  <Properties>
                    <string name="Name">38</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="61">
                  <Properties>
                    <string name="Name">39</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="62">
                  <Properties>
                    <string name="Name">3a</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="63">
                  <Properties>
                    <string name="Name">3b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="64">
                  <Properties>
                    <string name="Name">3c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="65">
                  <Properties>
                    <string name="Name">3d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="66">
                  <Properties>
                    <string name="Name">3e</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="67">
                  <Properties>
                    <string name="Name">3f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="68">
                  <Properties>
                    <string name="Name">40</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="69">
                  <Properties>
                    <string name="Name">42</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="70">
                  <Properties>
                    <string name="Name">44</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="71">
                  <Properties>
                    <string name="Name">45</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="72">
                  <Properties>
                    <string name="Name">48</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="73">
                  <Properties>
                    <string name="Name">49</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="74">
                  <Properties>
                    <string name="Name">4a</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="75">
                  <Properties>
                    <string name="Name">4b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="76">
                  <Properties>
                    <string name="Name">4c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="77">
                  <Properties>
                    <string name="Name">4e</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="78">
                  <Properties>
                    <string name="Name">4f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="79">
                  <Properties>
                    <string name="Name">50</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="80">
                  <Properties>
                    <string name="Name">51</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="81">
                  <Properties>
                    <string name="Name">52</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="82">
                  <Properties>
                    <string name="Name">53</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="83">
                  <Properties>
                    <string name="Name">54</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="84">
                  <Properties>
                    <string name="Name">55</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="85">
                  <Properties>
                    <string name="Name">57</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="86">
                  <Properties>
                    <string name="Name">58</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="87">
                  <Properties>
                    <string name="Name">59</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="88">
                  <Properties>
                    <string name="Name">5a</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="89">
                  <Properties>
                    <string name="Name">5b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="90">
                  <Properties>
                    <string name="Name">5c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="91">
                  <Properties>
                    <string name="Name">5d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="92">
                  <Properties>
                    <string name="Name">5e</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="93">
                  <Properties>
                    <string name="Name">5f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="94">
                  <Properties>
                    <string name="Name">62</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="95">
                  <Properties>
                    <string name="Name">64</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="96">
                  <Properties>
                    <string name="Name">65</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="97">
                  <Properties>
                    <string name="Name">68</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="98">
                  <Properties>
                    <string name="Name">69</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="99">
                  <Properties>
                    <string name="Name">6a</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="100">
                  <Properties>
                    <string name="Name">6b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="101">
                  <Properties>
                    <string name="Name">6c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="102">
                  <Properties>
                    <string name="Name">6d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="103">
                  <Properties>
                    <string name="Name">6e</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="104">
                  <Properties>
                    <string name="Name">6f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="105">
                  <Properties>
                    <string name="Name">70</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="106">
                  <Properties>
                    <string name="Name">71</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="107">
                  <Properties>
                    <string name="Name">73</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="108">
                  <Properties>
                    <string name="Name">74</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="109">
                  <Properties>
                    <string name="Name">75</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="110">
                  <Properties>
                    <string name="Name">77</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="111">
                  <Properties>
                    <string name="Name">78</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="112">
                  <Properties>
                    <string name="Name">7b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="113">
                  <Properties>
                    <string name="Name">7c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="114">
                  <Properties>
                    <string name="Name">7d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="115">
                  <Properties>
                    <string name="Name">7e</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="116">
                  <Properties>
                    <string name="Name">7f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="117">
                  <Properties>
                    <string name="Name">81</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="118">
                  <Properties>
                    <string name="Name">82</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="119">
                  <Properties>
                    <string name="Name">84</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="120">
                  <Properties>
                    <string name="Name">85</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="121">
                  <Properties>
                    <string name="Name">87</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="122">
                  <Properties>
                    <string name="Name">88</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="123">
                  <Properties>
                    <string name="Name">89</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="124">
                  <Properties>
                    <string name="Name">8b</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="125">
                  <Properties>
                    <string name="Name">8c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="126">
                  <Properties>
                    <string name="Name">8d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="127">
                  <Properties>
                    <string name="Name">8f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="128">
                  <Properties>
                    <string name="Name">90</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="129">
                  <Properties>
                    <string name="Name">91</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="130">
                  <Properties>
                    <string name="Name">92</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="131">
                  <Properties>
                    <string name="Name">93</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="132">
                  <Properties>
                    <string name="Name">94</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="133">
                  <Properties>
                    <string name="Name">95</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="134">
                  <Properties>
                    <string name="Name">97</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="135">
                  <Properties>
                    <string name="Name">98</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="136">
                  <Properties>
                    <string name="Name">9c</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="137">
                  <Properties>
                    <string name="Name">9d</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="138">
                  <Properties>
                    <string name="Name">9f</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="139">
                  <Properties>
                    <string name="Name">a2</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="140">
                  <Properties>
                    <string name="Name">a3</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="141">
                  <Properties>
                    <string name="Name">a5</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="142">
                  <Properties>
                    <string name="Name">a7</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="143">
                  <Properties>
                    <string name="Name">a8</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="144">
                  <Properties>
                    <string name="Name">a9</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="145">
                  <Properties>
                    <string name="Name">aa</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="146">
                  <Properties>
                    <string name="Name">ab</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="147">
                  <Properties>
                    <string name="Name">ac</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="148">
                  <Properties>
                    <string name="Name">ae</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="149">
                  <Properties>
                    <string name="Name">af</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="150">
                  <Properties>
                    <string name="Name">b0</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="151">
                  <Properties>
                    <string name="Name">b1</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="152">
                  <Properties>
                    <string name="Name">b2</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="153">
                  <Properties>
                    <string name="Name">b4</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="154">
                  <Properties>
                    <string name="Name">b5</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="155">
                  <Properties>
                    <string name="Name">b7</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="156">
                  <Properties>
                    <string name="Name">b8</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="157">
                  <Properties>
                    <string name="Name">b9</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="158">
                  <Properties>
                    <string name="Name">ba</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="159">
                  <Properties>
                    <string name="Name">bb</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="160">
                  <Properties>
                    <string name="Name">bc</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="161">
                  <Properties>
                    <string name="Name">bd</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="162">
                  <Properties>
                    <string name="Name">be</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="163">
                  <Properties>
                    <string name="Name">c0</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="164">
                  <Properties>
                    <string name="Name">c5</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="165">
                  <Properties>
                    <string name="Name">c6</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="166">
                  <Properties>
                    <string name="Name">c7</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="167">
                  <Properties>
                    <string name="Name">c8</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="168">
                  <Properties>
                    <string name="Name">c9</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="169">
                  <Properties>
                    <string name="Name">ca</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="170">
                  <Properties>
                    <string name="Name">cb</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="171">
                  <Properties>
                    <string name="Name">cc</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="172">
                  <Properties>
                    <string name="Name">cd</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="173">
                  <Properties>
                    <string name="Name">d0</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="174">
                  <Properties>
                    <string name="Name">d1</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="175">
                  <Properties>
                    <string name="Name">d2</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="176">
                  <Properties>
                    <string name="Name">d4</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="177">
                  <Properties>
                    <string name="Name">d5</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="178">
                  <Properties>
                    <string name="Name">d6</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="179">
                  <Properties>
                    <string name="Name">d7</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="180">
                  <Properties>
                    <string name="Name">d9</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="181">
                  <Properties>
                    <string name="Name">db</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="182">
                  <Properties>
                    <string name="Name">dc</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="183">
                  <Properties>
                    <string name="Name">dd</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="184">
                  <Properties>
                    <string name="Name">e0</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="185">
                  <Properties>
                    <string name="Name">e1</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="186">
                  <Properties>
                    <string name="Name">e2</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="187">
                  <Properties>
                    <string name="Name">e3</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="188">
                  <Properties>
                    <string name="Name">e4</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="189">
                  <Properties>
                    <string name="Name">e5</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="190">
                  <Properties>
                    <string name="Name">e6</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="191">
                  <Properties>
                    <string name="Name">e7</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="192">
                  <Properties>
                    <string name="Name">e8</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="193">
                  <Properties>
                    <string name="Name">e9</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="194">
                  <Properties>
                    <string name="Name">ea</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="195">
                  <Properties>
                    <string name="Name">eb</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="196">
                  <Properties>
                    <string name="Name">ec</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="197">
                  <Properties>
                    <string name="Name">ee</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="198">
                  <Properties>
                    <string name="Name">ef</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="199">
                  <Properties>
                    <string name="Name">f0</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="200">
                  <Properties>
                    <string name="Name">f3</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="201">
                  <Properties>
                    <string name="Name">f4</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="202">
                  <Properties>
                    <string name="Name">f5</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="203">
                  <Properties>
                    <string name="Name">f6</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="204">
                  <Properties>
                    <string name="Name">f8</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="205">
                  <Properties>
                    <string name="Name">f9</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="206">
                  <Properties>
                    <string name="Name">fb</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="207">
                  <Properties>
                    <string name="Name">fc</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="208">
                  <Properties>
                    <string name="Name">fd</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="209">
                  <Properties>
                    <string name="Name">fe</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="210">
                  <Properties>
                    <string name="Name">ff</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="211">
                  <Properties>
                    <string name="Name">info</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="212">
                  <Properties>
                    <string name="Name">pack</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="Folder" referent="213">
                <Properties>
                  <string name="Name">refs</string>
                </Properties>
                <Item class="Folder" referent="214">
                  <Properties>
                    <string name="Name">heads</string>
                  </Properties>
                </Item>
                <Item class="Folder" referent="215">
                  <Properties>
                    <string name="Name">remotes</string>
                  </Properties>
                  <Item class="Folder" referent="216">
                    <Properties>
                      <string name="Name">origin</string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="Folder" referent="217">
                  <Properties>
                    <string name="Name">tags</string>
                  </Properties>
                </Item>
              </Item>
            </Item>
            <Item class="Folder" referent="218">
              <Properties>
                <string name="Name">.vscode</string>
              </Properties>
              <Item class="ModuleScript" referent="219">
                <Properties>
                  <string name="Name">settings</string>
                  <string name="Source">return {
	["[typescript]"] = {
		["editor.defaultFormatter"] = "esbenp.prettier-vscode",
		["editor.formatOnSave"] = true,
	},
	["[typescriptreact]"] = {
		["editor.defaultFormatter"] = "esbenp.prettier-vscode",
		["editor.formatOnSave"] = true,
	},
}</string>
                </Properties>
              </Item>
            </Item>
            <Item class="Folder" referent="220">
              <Properties>
                <string name="Name">node_modules</string>
              </Properties>
              <Item class="ModuleScript" referent="221">
                <Properties>
                  <string name="Name">.package-lock</string>
                  <string name="Source">return {
	lockfileVersion = 3,
	name = "@rbxts/roact",
	packages = {
		["node_modules/@rbxts/compiler-types"] = {
			dev = true,
			integrity = "sha512-iWeioe5WziBTnY+FIT7aQ5bimlw81PYZ5d9WO0h1kX3joEigXPQpn2yHGRxzrqIssqQr47Y6fwknklaaQ6IPMQ==",
			resolved = "https://registry.npmjs.org/@rbxts/compiler-types/-/compiler-types-1.3.3-types.1.tgz",
			version = "1.3.3-types.1",
		},
		["node_modules/@rbxts/types"] = {
			dev = true,
			integrity = "sha512-yjS3NQyOglkchaV8FcqTRJSB6hSVLFsCcSem6BLLjLGlazRuvrbTO+ss0H/jYbA8FMumpEXzGrBsNTHmfdgbPQ==",
			resolved = "https://registry.npmjs.org/@rbxts/types/-/types-1.0.641.tgz",
			version = "1.0.641",
		},
	},
	requires = true,
	version = "1.4.4-ts.0",
}</string>
                </Properties>
              </Item>
              <Item class="Folder" referent="222">
                <Properties>
                  <string name="Name">@rbxts</string>
                </Properties>
                <Item class="Folder" referent="223">
                  <Properties>
                    <string name="Name">compiler-types</string>
                  </Properties>
                  <Item class="Folder" referent="224">
                    <Properties>
                      <string name="Name">types</string>
                    </Properties>
                  </Item>
                </Item>
                <Item class="Folder" referent="225">
                  <Properties>
                    <string name="Name">types</string>
                  </Properties>
                  <Item class="Folder" referent="226">
                    <Properties>
                      <string name="Name">include</string>
                    </Properties>
                    <Item class="Folder" referent="227">
                      <Properties>
                        <string name="Name">generated</string>
                      </Properties>
                    </Item>
                  </Item>
                </Item>
              </Item>
            </Item>
            <Item class="ModuleScript" referent="228">
              <Properties>
                <string name="Name">package-lock</string>
                <string name="Source">return {
	dependencies = {
		["@rbxts/compiler-types"] = {
			dev = true,
			integrity = "sha512-iWeioe5WziBTnY+FIT7aQ5bimlw81PYZ5d9WO0h1kX3joEigXPQpn2yHGRxzrqIssqQr47Y6fwknklaaQ6IPMQ==",
			resolved = "https://registry.npmjs.org/@rbxts/compiler-types/-/compiler-types-1.3.3-types.1.tgz",
			version = "1.3.3-types.1",
		},
		["@rbxts/types"] = {
			dev = true,
			integrity = "sha512-yjS3NQyOglkchaV8FcqTRJSB6hSVLFsCcSem6BLLjLGlazRuvrbTO+ss0H/jYbA8FMumpEXzGrBsNTHmfdgbPQ==",
			resolved = "https://registry.npmjs.org/@rbxts/types/-/types-1.0.641.tgz",
			version = "1.0.641",
		},
	},
	lockfileVersion = 2,
	name = "@rbxts/roact",
	packages = {
		[""] = {
			devDependencies = {
				["@rbxts/compiler-types"] = "^1.3.3-types.1",
				["@rbxts/types"] = "^1.0.641",
			},
			name = "@rbxts/roact",
			version = "1.4.4-ts.0",
		},
		["node_modules/@rbxts/compiler-types"] = {
			dev = true,
			integrity = "sha512-iWeioe5WziBTnY+FIT7aQ5bimlw81PYZ5d9WO0h1kX3joEigXPQpn2yHGRxzrqIssqQr47Y6fwknklaaQ6IPMQ==",
			resolved = "https://registry.npmjs.org/@rbxts/compiler-types/-/compiler-types-1.3.3-types.1.tgz",
			version = "1.3.3-types.1",
		},
		["node_modules/@rbxts/types"] = {
			dev = true,
			integrity = "sha512-yjS3NQyOglkchaV8FcqTRJSB6hSVLFsCcSem6BLLjLGlazRuvrbTO+ss0H/jYbA8FMumpEXzGrBsNTHmfdgbPQ==",
			resolved = "https://registry.npmjs.org/@rbxts/types/-/types-1.0.641.tgz",
			version = "1.0.641",
		},
	},
	requires = true,
	version = "1.4.4-ts.0",
}</string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="229">
              <Properties>
                <string name="Name">src</string>
                <string name="Source"><![CDATA[--~strict
--[[
	Packages up the internals of Roact and exposes a public API for it.
]]

local GlobalConfig = require(script.GlobalConfig)
local createReconciler = require(script.createReconciler)
local createReconcilerCompat = require(script.createReconcilerCompat)
local RobloxRenderer = require(script.RobloxRenderer)
local strict = require(script.strict)
local Binding = require(script.Binding)

local robloxReconciler = createReconciler(RobloxRenderer)
local reconcilerCompat = createReconcilerCompat(robloxReconciler)

local Roact = strict({
	Component = require(script.Component),
	createElement = require(script.createElement),
	createFragment = require(script.createFragment),
	oneChild = require(script.oneChild),
	PureComponent = require(script.PureComponent),
	None = require(script.None),
	Portal = require(script.Portal),
	createRef = require(script.createRef),
	forwardRef = require(script.forwardRef),
	createBinding = Binding.create,
	joinBindings = Binding.join,
	createContext = require(script.createContext),

	Change = require(script.PropMarkers.Change),
	Children = require(script.PropMarkers.Children),
	Event = require(script.PropMarkers.Event),
	Ref = require(script.PropMarkers.Ref),

	mount = robloxReconciler.mountVirtualTree,
	unmount = robloxReconciler.unmountVirtualTree,
	update = robloxReconciler.updateVirtualTree,

	reify = reconcilerCompat.reify,
	teardown = reconcilerCompat.teardown,
	reconcile = reconcilerCompat.reconcile,

	setGlobalConfig = GlobalConfig.set,

	-- APIs that may change in the future without warning
	UNSTABLE = {},
})

return Roact
]]></string>
              </Properties>
              <Item class="ModuleScript" referent="230">
                <Properties>
                  <string name="Name">Binding</string>
                  <string name="Source"><![CDATA[local createSignal = require(script.Parent.createSignal)
local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local BindingImpl = Symbol.named("BindingImpl")

local BindingInternalApi = {}

local bindingPrototype = {}

function bindingPrototype:getValue()
	return BindingInternalApi.getValue(self)
end

function bindingPrototype:map(predicate)
	return BindingInternalApi.map(self, predicate)
end

local BindingPublicMeta = {
	__index = bindingPrototype,
	__tostring = function(self)
		return string.format("RoactBinding(%s)", tostring(self:getValue()))
	end,
}

function BindingInternalApi.update(binding, newValue)
	return binding[BindingImpl].update(newValue)
end

function BindingInternalApi.subscribe(binding, callback)
	return binding[BindingImpl].subscribe(callback)
end

function BindingInternalApi.getValue(binding)
	return binding[BindingImpl].getValue()
end

function BindingInternalApi.create(initialValue)
	local impl = {
		value = initialValue,
		changeSignal = createSignal(),
	}

	function impl.subscribe(callback)
		return impl.changeSignal:subscribe(callback)
	end

	function impl.update(newValue)
		impl.value = newValue
		impl.changeSignal:fire(newValue)
	end

	function impl.getValue()
		return impl.value
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta), impl.update
end

function BindingInternalApi.map(upstreamBinding, predicate)
	if config.typeChecks then
		assert(Type.of(upstreamBinding) == Type.Binding, "Expected arg #1 to be a binding")
		assert(typeof(predicate) == "function", "Expected arg #1 to be a function")
	end

	local impl = {}

	function impl.subscribe(callback)
		return BindingInternalApi.subscribe(upstreamBinding, function(newValue)
			callback(predicate(newValue))
		end)
	end

	function impl.update(_newValue)
		error("Bindings created by Binding:map(fn) cannot be updated directly", 2)
	end

	function impl.getValue()
		return predicate(upstreamBinding:getValue())
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

function BindingInternalApi.join(upstreamBindings)
	if config.typeChecks then
		assert(typeof(upstreamBindings) == "table", "Expected arg #1 to be of type table")

		for key, value in pairs(upstreamBindings) do
			if Type.of(value) ~= Type.Binding then
				local message = ("Expected arg #1 to contain only bindings, but key %q had a non-binding value"):format(
					tostring(key)
				)
				error(message, 2)
			end
		end
	end

	local impl = {}

	local function getValue()
		local value = {}

		for key, upstream in pairs(upstreamBindings) do
			value[key] = upstream:getValue()
		end

		return value
	end

	function impl.subscribe(callback)
		local disconnects = {}

		for key, upstream in pairs(upstreamBindings) do
			disconnects[key] = BindingInternalApi.subscribe(upstream, function(_newValue)
				callback(getValue())
			end)
		end

		return function()
			if disconnects == nil then
				return
			end

			for _, disconnect in pairs(disconnects) do
				disconnect()
			end

			disconnects = nil :: any
		end
	end

	function impl.update(_newValue)
		error("Bindings created by joinBindings(...) cannot be updated directly", 2)
	end

	function impl.getValue()
		return getValue()
	end

	return setmetatable({
		[Type] = Type.Binding,
		[BindingImpl] = impl,
	}, BindingPublicMeta)
end

return BindingInternalApi
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="231">
                <Properties>
                  <string name="Name">Component</string>
                  <string name="Source"><![CDATA[local assign = require(script.Parent.assign)
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)
local invalidSetStateMessages = require(script.Parent.invalidSetStateMessages)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

--[[
	Calling setState during certain lifecycle allowed methods has the potential
	to create an infinitely updating component. Rather than time out, we exit
	with an error if an unreasonable number of self-triggering updates occur
]]
local MAX_PENDING_UPDATES = 100

local InternalData = Symbol.named("InternalData")

local componentMissingRenderMessage = [[
The component %q is missing the `render` method.
`render` must be defined when creating a Roact component!]]

local tooManyUpdatesMessage = [[
The component %q has reached the setState update recursion limit.
When using `setState` in `didUpdate`, make sure that it won't repeat infinitely!]]

local componentClassMetatable = {}

function componentClassMetatable:__tostring()
	return self.__componentName
end

local Component = {}
setmetatable(Component, componentClassMetatable)

Component[Type] = Type.StatefulComponentClass
Component.__index = Component
Component.__componentName = "Component"

--[[
	A method called by consumers of Roact to create a new component class.
	Components can not be extended beyond this point, with the exception of
	PureComponent.
]]
function Component:extend(name)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentClass, "Invalid `self` argument to `extend`.")
		assert(typeof(name) == "string", "Component class name must be a string")
	end

	local class = {}

	for key, value in pairs(self) do
		-- Roact opts to make consumers use composition over inheritance, which
		-- lines up with React.
		-- https://reactjs.org/docs/composition-vs-inheritance.html
		if key ~= "extend" then
			class[key] = value
		end
	end

	class[Type] = Type.StatefulComponentClass
	class.__index = class
	class.__componentName = name

	setmetatable(class, componentClassMetatable)

	return class
end

function Component:__getDerivedState(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getDerivedState`")
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	if componentClass.getDerivedStateFromProps ~= nil then
		local derivedState = componentClass.getDerivedStateFromProps(incomingProps, incomingState)

		if derivedState ~= nil then
			if config.typeChecks then
				assert(typeof(derivedState) == "table", "getDerivedStateFromProps must return a table!")
			end

			return derivedState
		end
	end

	return nil
end

function Component:setState(mapState)
	if config.typeChecks then
		assert(Type.of(self) == Type.StatefulComponentInstance, "Invalid `self` argument to `extend`.")
	end

	local internalData = self[InternalData]
	local lifecyclePhase = internalData.lifecyclePhase

	--[[
		When preparing to update, render, or unmount, it is not safe
		to call `setState` as it will interfere with in-flight updates. It's
		also disallowed during unmounting
	]]
	if
		lifecyclePhase == ComponentLifecyclePhase.ShouldUpdate
		or lifecyclePhase == ComponentLifecyclePhase.WillUpdate
		or lifecyclePhase == ComponentLifecyclePhase.Render
	then
		local messageTemplate = invalidSetStateMessages[internalData.lifecyclePhase]

		local message = messageTemplate:format(tostring(internalData.componentClass))
		error(message, 2)
	elseif lifecyclePhase == ComponentLifecyclePhase.WillUnmount then
		-- Should not print error message. See https://github.com/facebook/react/pull/22114
		return
	end

	local pendingState = internalData.pendingState

	local partialState
	if typeof(mapState) == "function" then
		partialState = mapState(pendingState or self.state, self.props)

		-- Abort the state update if the given state updater function returns nil
		if partialState == nil then
			return
		end
	elseif typeof(mapState) == "table" then
		partialState = mapState
	else
		error("Invalid argument to setState, expected function or table", 2)
	end

	local newState
	if pendingState ~= nil then
		newState = assign(pendingState, partialState)
	else
		newState = assign({}, self.state, partialState)
	end

	if lifecyclePhase == ComponentLifecyclePhase.Init then
		-- If `setState` is called in `init`, we can skip triggering an update!
		local derivedState = self:__getDerivedState(self.props, newState)
		self.state = assign(newState, derivedState)
	elseif
		lifecyclePhase == ComponentLifecyclePhase.DidMount
		or lifecyclePhase == ComponentLifecyclePhase.DidUpdate
		or lifecyclePhase == ComponentLifecyclePhase.ReconcileChildren
	then
		--[[
			During certain phases of the component lifecycle, it's acceptable to
			allow `setState` but defer the update until we're done with ones in flight.
			We do this by collapsing it into any pending updates we have.
		]]
		local derivedState = self:__getDerivedState(self.props, newState)
		internalData.pendingState = assign(newState, derivedState)
	elseif lifecyclePhase == ComponentLifecyclePhase.Idle then
		-- Outside of our lifecycle, the state update is safe to make immediately
		self:__update(nil, newState)
	else
		local messageTemplate = invalidSetStateMessages.default

		local message = messageTemplate:format(tostring(internalData.componentClass))

		error(message, 2)
	end
end

--[[
	Returns the stack trace of where the element was created that this component
	instance's properties are based on.

	Intended to be used primarily by diagnostic tools.
]]
function Component:getElementTraceback()
	return self[InternalData].virtualNode.currentElement.source
end

--[[
	Returns a snapshot of this component given the current props and state. Must
	be overridden by consumers of Roact and should be a pure function with
	regards to props and state.

	TODO (#199): Accept props and state as arguments.
]]
function Component:render()
	local internalData = self[InternalData]

	local message = componentMissingRenderMessage:format(tostring(internalData.componentClass))

	error(message, 0)
end

--[[
	Retrieves the context value corresponding to the given key. Can return nil
	if a requested context key is not present
]]
function Component:__getContext(key)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__getContext`")
		internalAssert(key ~= nil, "Context key cannot be nil")
	end

	local virtualNode = self[InternalData].virtualNode
	local context = virtualNode.context

	return context[key]
end

--[[
	Adds a new context entry to this component's context table (which will be
	passed down to child components).
]]
function Component:__addContext(key, value)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__addContext`")
	end
	local virtualNode = self[InternalData].virtualNode

	-- Make sure we store a reference to the component's original, unmodified
	-- context the virtual node. In the reconciler, we'll restore the original
	-- context if we need to replace the node (this happens when a node gets
	-- re-rendered as a different component)
	if virtualNode.originalContext == nil then
		virtualNode.originalContext = virtualNode.context
	end

	-- Build a new context table on top of the existing one, then apply it to
	-- our virtualNode
	local existing = virtualNode.context
	virtualNode.context = assign({}, existing, { [key] = value })
end

--[[
	Performs property validation if the static method validateProps is declared.
	validateProps should follow assert's expected arguments:
	(false, message: string) | true. The function may return a message in the
	true case; it will be ignored. If this fails, the function will throw the
	error.
]]
function Component:__validateProps(props)
	if not config.propValidation then
		return
	end

	local validator = self[InternalData].componentClass.validateProps

	if validator == nil then
		return
	end

	if typeof(validator) ~= "function" then
		error(
			("validateProps must be a function, but it is a %s.\nCheck the definition of the component %q."):format(
				typeof(validator),
				self.__componentName
			)
		)
	end

	local success, failureReason = validator(props)

	if not success then
		failureReason = failureReason or "<Validator function did not supply a message>"
		error(
			("Property validation failed in %s: %s\n\n%s"):format(
				self.__componentName,
				tostring(failureReason),
				self:getElementTraceback() or "<enable element tracebacks>"
			),
			0
		)
	end
end

--[[
	An internal method used by the reconciler to construct a new component
	instance and attach it to the given virtualNode.
]]
function Component:__mount(reconciler, virtualNode)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentClass, "Invalid use of `__mount`")
		internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #2 to be of type VirtualNode")
	end

	local currentElement = virtualNode.currentElement
	local hostParent = virtualNode.hostParent

	-- Contains all the information that we want to keep from consumers of
	-- Roact, or even other parts of the codebase like the reconciler.
	local internalData = {
		reconciler = reconciler,
		virtualNode = virtualNode,
		componentClass = self,
		lifecyclePhase = ComponentLifecyclePhase.Init,
		pendingState = nil,
	}

	local instance = {
		[Type] = Type.StatefulComponentInstance,
		[InternalData] = internalData,
	}

	setmetatable(instance, self)

	virtualNode.instance = instance

	local props = currentElement.props

	if self.defaultProps ~= nil then
		props = assign({}, self.defaultProps, props)
	end

	instance:__validateProps(props)

	instance.props = props

	local newContext = assign({}, virtualNode.legacyContext)
	instance._context = newContext

	instance.state = assign({}, instance:__getDerivedState(instance.props, {}))

	if instance.init ~= nil then
		instance:init(instance.props)
		assign(instance.state, instance:__getDerivedState(instance.props, instance.state))
	end

	-- It's possible for init() to redefine _context!
	virtualNode.legacyContext = instance._context

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render
	local renderResult = instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)

	if instance.didMount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidMount
		instance:didMount()
	end

	if internalData.pendingState ~= nil then
		-- __update will handle pendingState, so we don't pass any new element or state
		instance:__update(nil, nil)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
end

--[[
	Internal method used by the reconciler to clean up any resources held by
	this component instance.
]]
function Component:__unmount()
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__unmount`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	if self.willUnmount ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUnmount
		self:willUnmount()
	end

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end
end

--[[
	Internal method used by setState (to trigger updates based on state) and by
	the reconciler (to trigger updates based on props)

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__update(updatedElement, updatedState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__update`")
		internalAssert(
			Type.of(updatedElement) == Type.Element or updatedElement == nil,
			"Expected arg #1 to be of type Element or nil"
		)
		internalAssert(
			typeof(updatedState) == "table" or updatedState == nil,
			"Expected arg #2 to be of type table or nil"
		)
	end

	local internalData = self[InternalData]
	local componentClass = internalData.componentClass

	local newProps = self.props
	if updatedElement ~= nil then
		newProps = updatedElement.props

		if componentClass.defaultProps ~= nil then
			newProps = assign({}, componentClass.defaultProps, newProps)
		end

		self:__validateProps(newProps)
	end

	local updateCount = 0
	repeat
		local finalState
		local pendingState = nil

		-- Consume any pending state we might have
		if internalData.pendingState ~= nil then
			pendingState = internalData.pendingState
			internalData.pendingState = nil
		end

		-- Consume a standard update to state or props
		if updatedState ~= nil or newProps ~= self.props then
			if pendingState == nil then
				finalState = updatedState or self.state
			else
				finalState = assign(pendingState, updatedState)
			end

			local derivedState = self:__getDerivedState(newProps, finalState)

			if derivedState ~= nil then
				finalState = assign({}, finalState, derivedState)
			end

			updatedState = nil
		else
			finalState = pendingState
		end

		if not self:__resolveUpdate(newProps, finalState) then
			-- If the update was short-circuited, bubble the result up to the caller
			return false
		end

		updateCount = updateCount + 1

		if updateCount > MAX_PENDING_UPDATES then
			error(tooManyUpdatesMessage:format(tostring(internalData.componentClass)), 3)
		end
	until internalData.pendingState == nil

	return true
end

--[[
	Internal method used by __update to apply new props and state

	Returns true if the update was completed, false if it was cancelled by shouldUpdate
]]
function Component:__resolveUpdate(incomingProps, incomingState)
	if config.internalTypeChecks then
		internalAssert(Type.of(self) == Type.StatefulComponentInstance, "Invalid use of `__resolveUpdate`")
	end

	local internalData = self[InternalData]
	local virtualNode = internalData.virtualNode
	local reconciler = internalData.reconciler

	local oldProps = self.props
	local oldState = self.state

	if incomingProps == nil then
		incomingProps = oldProps
	end
	if incomingState == nil then
		incomingState = oldState
	end

	if self.shouldUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.ShouldUpdate
		local continueWithUpdate = self:shouldUpdate(incomingProps, incomingState)

		if not continueWithUpdate then
			internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
			return false
		end
	end

	if self.willUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.WillUpdate
		self:willUpdate(incomingProps, incomingState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Render

	self.props = incomingProps
	self.state = incomingState

	local renderResult = virtualNode.instance:render()

	internalData.lifecyclePhase = ComponentLifecyclePhase.ReconcileChildren
	reconciler.updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, renderResult)

	if self.didUpdate ~= nil then
		internalData.lifecyclePhase = ComponentLifecyclePhase.DidUpdate
		self:didUpdate(oldProps, oldState)
	end

	internalData.lifecyclePhase = ComponentLifecyclePhase.Idle
	return true
end

return Component
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="232">
                <Properties>
                  <string name="Name">ComponentLifecyclePhase</string>
                  <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local ComponentLifecyclePhase = strict({
	-- Component methods
	Init = Symbol.named("init"),
	Render = Symbol.named("render"),
	ShouldUpdate = Symbol.named("shouldUpdate"),
	WillUpdate = Symbol.named("willUpdate"),
	DidMount = Symbol.named("didMount"),
	DidUpdate = Symbol.named("didUpdate"),
	WillUnmount = Symbol.named("willUnmount"),

	-- Phases describing reconciliation status
	ReconcileChildren = Symbol.named("reconcileChildren"),
	Idle = Symbol.named("idle"),
}, "ComponentLifecyclePhase")

return ComponentLifecyclePhase
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="233">
                <Properties>
                  <string name="Name">Config</string>
                  <string name="Source"><![CDATA[--[[
	Exposes an interface to set global configuration values for Roact.

	Configuration can only occur once, and should only be done by an application
	using Roact, not a library.

	Any keys that aren't recognized will cause errors. Configuration is only
	intended for configuring Roact itself, not extensions or libraries.

	Configuration is expected to be set immediately after loading Roact. Setting
	configuration values after an application starts may produce unpredictable
	behavior.
]]

-- Every valid configuration value should be non-nil in this table.
local defaultConfig = {
	-- Enables asserts for internal Roact APIs. Useful for debugging Roact itself.
	["internalTypeChecks"] = false,
	-- Enables stricter type asserts for Roact's public API.
	["typeChecks"] = false,
	-- Enables storage of `debug.traceback()` values on elements for debugging.
	["elementTracing"] = false,
	-- Enables validation of component props in stateful components.
	["propValidation"] = false,
}

-- Build a list of valid configuration values up for debug messages.
local defaultConfigKeys = {}
for key in pairs(defaultConfig) do
	table.insert(defaultConfigKeys, key)
end

local Config = {}

function Config.new()
	local self = {}

	self._currentConfig = setmetatable({}, {
		__index = function(_, key)
			local message = ("Invalid global configuration key %q. Valid configuration keys are: %s"):format(
				tostring(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end,
	})

	-- We manually bind these methods here so that the Config's methods can be
	-- used without passing in self, since they eventually get exposed on the
	-- root Roact object.
	self.set = function(...)
		return Config.set(self, ...)
	end

	self.get = function(...)
		return Config.get(self, ...)
	end

	self.scoped = function(...)
		return Config.scoped(self, ...)
	end

	self.set(defaultConfig)

	return self
end

function Config:set(configValues)
	-- Validate values without changing any configuration.
	-- We only want to apply this configuration if it's valid!
	for key, value in pairs(configValues) do
		if defaultConfig[key] == nil then
			local message = ("Invalid global configuration key %q (type %s). Valid configuration keys are: %s"):format(
				tostring(key),
				typeof(key),
				table.concat(defaultConfigKeys, ", ")
			)

			error(message, 3)
		end

		-- Right now, all configuration values must be boolean.
		if typeof(value) ~= "boolean" then
			local message = (
				"Invalid value %q (type %s) for global configuration key %q. Valid values are: true, false"
			):format(tostring(value), typeof(value), tostring(key))

			error(message, 3)
		end

		self._currentConfig[key] = value
	end
end

function Config:get()
	return self._currentConfig
end

function Config:scoped(configValues, callback)
	local previousValues = {}
	for key, value in pairs(self._currentConfig) do
		previousValues[key] = value
	end

	self.set(configValues)

	local success, result = pcall(callback)

	self.set(previousValues)

	assert(success, result)
end

return Config
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="234">
                <Properties>
                  <string name="Name">ElementKind</string>
                  <string name="Source"><![CDATA[--[[
	Contains markers for annotating the type of an element.

	Use `ElementKind` as a key, and values from it as the value.

		local element = {
			[ElementKind] = ElementKind.Host,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)
local Portal = require(script.Parent.Portal)

local ElementKind = newproxy(true)

local ElementKindInternal = {
	Portal = Symbol.named("Portal"),
	Host = Symbol.named("Host"),
	Function = Symbol.named("Function"),
	Stateful = Symbol.named("Stateful"),
	Fragment = Symbol.named("Fragment"),
}

function ElementKindInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[ElementKind]
end

local componentTypesToKinds = {
	["string"] = ElementKindInternal.Host,
	["function"] = ElementKindInternal.Function,
	["table"] = ElementKindInternal.Stateful,
}

function ElementKindInternal.fromComponent(component)
	if component == Portal then
		return ElementKind.Portal
	else
		return componentTypesToKinds[typeof(component)]
	end
end

getmetatable(ElementKind).__index = ElementKindInternal

strict(ElementKindInternal, "ElementKind")

return ElementKind
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="235">
                <Properties>
                  <string name="Name">ElementUtils</string>
                  <string name="Source"><![CDATA[--!strict
local Type = require(script.Parent.Type)
local Symbol = require(script.Parent.Symbol)

local function noop()
	return nil
end

local ElementUtils = {}

--[[
	A signal value indicating that a child should use its parent's key, because
	it has no key of its own.

	This occurs when you return only one element from a function component or
	stateful render function.
]]
ElementUtils.UseParentKey = Symbol.named("UseParentKey")

type Iterator<K, V> = ({ [K]: V }, K?) -> (K?, V?)
type Element = { [any]: any }
--[[
	Returns an iterator over the children of an element.
	`elementOrElements` may be one of:
	* a boolean
	* nil
	* a single element
	* a fragment
	* a table of elements

	If `elementOrElements` is a boolean or nil, this will return an iterator with
	zero elements.

	If `elementOrElements` is a single element, this will return an iterator with
	one element: a tuple where the first value is ElementUtils.UseParentKey, and
	the second is the value of `elementOrElements`.

	If `elementOrElements` is a fragment or a table, this will return an iterator
	over all the elements of the array.

	If `elementOrElements` is none of the above, this function will throw.
]]
function ElementUtils.iterateElements<K>(elementOrElements): (Iterator<K, Element>, any, nil)
	local richType = Type.of(elementOrElements)

	-- Single child
	if richType == Type.Element then
		local called = false

		return function(_, _)
			if called then
				return nil
			else
				called = true
				return ElementUtils.UseParentKey, elementOrElements
			end
		end
	end

	local regularType = typeof(elementOrElements)

	if elementOrElements == nil or regularType == "boolean" then
		return (noop :: any) :: Iterator<K, Element>
	end

	if regularType == "table" then
		return pairs(elementOrElements)
	end

	error("Invalid elements")
end

--[[
	Gets the child corresponding to a given key, respecting Roact's rules for
	children. Specifically:
	* If `elements` is nil or a boolean, this will return `nil`, regardless of
		the key given.
	* If `elements` is a single element, this will return `nil`, unless the key
		is ElementUtils.UseParentKey.
	* If `elements` is a table of elements, this will return `elements[key]`.
]]
function ElementUtils.getElementByKey(elements, hostKey)
	if elements == nil or typeof(elements) == "boolean" then
		return nil
	end

	if Type.of(elements) == Type.Element then
		if hostKey == ElementUtils.UseParentKey then
			return elements
		end

		return nil
	end

	if typeof(elements) == "table" then
		return elements[hostKey]
	end

	error("Invalid elements")
end

return ElementUtils
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="236">
                <Properties>
                  <string name="Name">GlobalConfig</string>
                  <string name="Source"><![CDATA[--[[
	Exposes a single instance of a configuration as Roact's GlobalConfig.
]]

local Config = require(script.Parent.Config)

return Config.new()
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="237">
                <Properties>
                  <string name="Name">Logging</string>
                  <string name="Source"><![CDATA[--[[
	Centralized place to handle logging. Lets us:
	- Unit test log output via `Logging.capture`
	- Disable verbose log messages when not debugging Roact

	This should be broken out into a separate library with the addition of
	scoping and logging configuration.
]]

-- Determines whether log messages will go to stdout/stderr
local outputEnabled = true

-- A set of LogInfo objects that should have messages inserted into them.
-- This is a set so that nested calls to Logging.capture will behave.
local collectors = {}

-- A set of all stack traces that have called warnOnce.
local onceUsedLocations = {}

--[[
	Indent a potentially multi-line string with the given number of tabs, in
	addition to any indentation the string already has.
]]
local function indent(source, indentLevel)
	local indentString = ("\t"):rep(indentLevel)

	return indentString .. source:gsub("\n", "\n" .. indentString)
end

--[[
	Indents a list of strings and then concatenates them together with newlines
	into a single string.
]]
local function indentLines(lines, indentLevel)
	local outputBuffer = {}

	for _, line in ipairs(lines) do
		table.insert(outputBuffer, indent(line, indentLevel))
	end

	return table.concat(outputBuffer, "\n")
end

local logInfoMetatable = {}

--[[
	Automatic coercion to strings for LogInfo objects to enable debugging them
	more easily.
]]
function logInfoMetatable:__tostring()
	local outputBuffer = { "LogInfo {" }

	local errorCount = #self.errors
	local warningCount = #self.warnings
	local infosCount = #self.infos

	if errorCount + warningCount + infosCount == 0 then
		table.insert(outputBuffer, "\t(no messages)")
	end

	if errorCount > 0 then
		table.insert(outputBuffer, ("\tErrors (%d) {"):format(errorCount))
		table.insert(outputBuffer, indentLines(self.errors, 2))
		table.insert(outputBuffer, "\t}")
	end

	if warningCount > 0 then
		table.insert(outputBuffer, ("\tWarnings (%d) {"):format(warningCount))
		table.insert(outputBuffer, indentLines(self.warnings, 2))
		table.insert(outputBuffer, "\t}")
	end

	if infosCount > 0 then
		table.insert(outputBuffer, ("\tInfos (%d) {"):format(infosCount))
		table.insert(outputBuffer, indentLines(self.infos, 2))
		table.insert(outputBuffer, "\t}")
	end

	table.insert(outputBuffer, "}")

	return table.concat(outputBuffer, "\n")
end

local function createLogInfo()
	local logInfo = {
		errors = {},
		warnings = {},
		infos = {},
	}

	setmetatable(logInfo, logInfoMetatable)

	return logInfo
end

local Logging = {}

--[[
	Invokes `callback`, capturing all output that happens during its execution.

	Output will not go to stdout or stderr and will instead be put into a
	LogInfo object that is returned. If `callback` throws, the error will be
	bubbled up to the caller of `Logging.capture`.
]]
function Logging.capture(callback)
	local collector = createLogInfo()

	local wasOutputEnabled = outputEnabled
	outputEnabled = false
	collectors[collector] = true

	local success, result = pcall(callback)

	collectors[collector] = nil
	outputEnabled = wasOutputEnabled

	assert(success, result)

	return collector
end

--[[
	Issues a warning with an automatically attached stack trace.
]]
function Logging.warn(messageTemplate, ...)
	local message = messageTemplate:format(...)

	for collector in pairs(collectors) do
		table.insert(collector.warnings, message)
	end

	-- debug.traceback inserts a leading newline, so we trim it here
	local trace = debug.traceback("", 2):sub(2)
	local fullMessage = ("%s\n%s"):format(message, indent(trace, 1))

	if outputEnabled then
		warn(fullMessage)
	end
end

--[[
	Issues a warning like `Logging.warn`, but only outputs once per call site.

	This is useful for marking deprecated functions that might be called a lot;
	using `warnOnce` instead of `warn` will reduce output noise while still
	correctly marking all call sites.
]]
function Logging.warnOnce(messageTemplate, ...)
	local trace = debug.traceback()

	if onceUsedLocations[trace] then
		return
	end

	onceUsedLocations[trace] = true
	Logging.warn(messageTemplate, ...)
end

return Logging
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="238">
                <Properties>
                  <string name="Name">None</string>
                  <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

-- Marker used to specify that the value is nothing, because nil cannot be
-- stored in tables.
local None = Symbol.named("None")

return None
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="239">
                <Properties>
                  <string name="Name">NoopRenderer</string>
                  <string name="Source"><![CDATA[--[[
	Reference renderer intended for use in tests as well as for documenting the
	minimum required interface for a Roact renderer.
]]

local NoopRenderer = {}

function NoopRenderer.isHostObject(target)
	-- Attempting to use NoopRenderer to target a Roblox instance is almost
	-- certainly a mistake.
	return target == nil
end

function NoopRenderer.mountHostNode(_reconciler, _node) end

function NoopRenderer.unmountHostNode(_reconciler, _node) end

function NoopRenderer.updateHostNode(_reconciler, node, _newElement)
	return node
end

return NoopRenderer
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="240">
                <Properties>
                  <string name="Name">Portal</string>
                  <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)

local Portal = Symbol.named("Portal")

return Portal
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="241">
                <Properties>
                  <string name="Name">PropMarkers</string>
                </Properties>
                <Item class="ModuleScript" referent="242">
                  <Properties>
                    <string name="Name">Change</string>
                    <string name="Source"><![CDATA[--[[
	Change is used to generate special prop keys that can be used to connect to
	GetPropertyChangedSignal.

	Generally, Change is indexed by a Roblox property name:

		Roact.createElement("TextBox", {
			[Roact.Change.Text] = function(rbx)
				print("The TextBox", rbx, "changed text to", rbx.Text)
			end,
		})
]]

local Type = require(script.Parent.Parent.Type)

local Change = {}

local changeMetatable = {
	__tostring = function(self)
		return ("RoactHostChangeEvent(%s)"):format(self.name)
	end,
}

setmetatable(Change, {
	__index = function(_self, propertyName)
		local changeListener = {
			[Type] = Type.HostChangeEvent,
			name = propertyName,
		}

		setmetatable(changeListener, changeMetatable)
		Change[propertyName] = changeListener

		return changeListener
	end,
})

return Change
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="243">
                  <Properties>
                    <string name="Name">Children</string>
                    <string name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Children = Symbol.named("Children")

return Children
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="244">
                  <Properties>
                    <string name="Name">Event</string>
                    <string name="Source"><![CDATA[--[[
	Index into `Event` to get a prop key for attaching to an event on a Roblox
	Instance.

	Example:

		Roact.createElement("TextButton", {
			Text = "Hello, world!",

			[Roact.Event.MouseButton1Click] = function(rbx)
				print("Clicked", rbx)
			end
		})
]]

local Type = require(script.Parent.Parent.Type)

local Event = {}

local eventMetatable = {
	__tostring = function(self)
		return ("RoactHostEvent(%s)"):format(self.name)
	end,
}

setmetatable(Event, {
	__index = function(_self, eventName)
		local event = {
			[Type] = Type.HostEvent,
			name = eventName,
		}

		setmetatable(event, eventMetatable)

		Event[eventName] = event

		return event
	end,
})

return Event
]]></string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="245">
                  <Properties>
                    <string name="Name">Ref</string>
                    <string name="Source"><![CDATA[local Symbol = require(script.Parent.Parent.Symbol)

local Ref = Symbol.named("Ref")

return Ref
]]></string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="246">
                <Properties>
                  <string name="Name">PureComponent</string>
                  <string name="Source"><![CDATA[--[[
	A version of Component with a `shouldUpdate` method that forces the
	resulting component to be pure.
]]

local Component = require(script.Parent.Component)

local PureComponent = Component:extend("PureComponent")

-- When extend()ing a component, you don't get an extend method.
-- This is to promote composition over inheritance.
-- PureComponent is an exception to this rule.
PureComponent.extend = Component.extend

function PureComponent:shouldUpdate(newProps, newState)
	-- In a vast majority of cases, if state updated, something has updated.
	-- We don't bother checking in this case.
	if newState ~= self.state then
		return true
	end

	if newProps == self.props then
		return false
	end

	for key, value in pairs(newProps) do
		if self.props[key] ~= value then
			return true
		end
	end

	for key, value in pairs(self.props) do
		if newProps[key] ~= value then
			return true
		end
	end

	return false
end

return PureComponent
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="247">
                <Properties>
                  <string name="Name">RobloxRenderer</string>
                  <string name="Source"><![CDATA[--[[
	Renderer that deals in terms of Roblox Instances. This is the most
	well-supported renderer after NoopRenderer and is currently the only
	renderer that does anything.
]]

local Binding = require(script.Parent.Binding)
local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local SingleEventManager = require(script.Parent.SingleEventManager)
local getDefaultInstanceProperty = require(script.Parent.getDefaultInstanceProperty)
local Ref = require(script.Parent.PropMarkers.Ref)
local Type = require(script.Parent.Type)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local applyPropsError = [[
Error applying props:
	%s
In element:
%s
]]

local updatePropsError = [[
Error updating props:
	%s
In element:
%s
]]

local function identity(...)
	return ...
end

local function applyRef(ref, newHostObject)
	if ref == nil then
		return
	end

	if typeof(ref) == "function" then
		ref(newHostObject)
	elseif Type.of(ref) == Type.Binding then
		Binding.update(ref, newHostObject)
	else
		-- TODO (#197): Better error message
		error(("Invalid ref: Expected type Binding but got %s"):format(typeof(ref)))
	end
end

local function setRobloxInstanceProperty(hostObject, key, newValue)
	if newValue == nil then
		local hostClass = hostObject.ClassName
		local _, defaultValue = getDefaultInstanceProperty(hostClass, key)
		newValue = defaultValue
	end

	-- Assign the new value to the object
	hostObject[key] = newValue

	return
end

local function removeBinding(virtualNode, key)
	local disconnect = virtualNode.bindings[key]
	disconnect()
	virtualNode.bindings[key] = nil
end

local function attachBinding(virtualNode, key, newBinding)
	local function updateBoundProperty(newValue)
		local success, errorMessage = xpcall(function()
			setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
		end, identity)

		if not success then
			local source = virtualNode.currentElement.source

			if source == nil then
				source = "<enable element tracebacks>"
			end

			local fullMessage = updatePropsError:format(errorMessage, source)
			error(fullMessage, 0)
		end
	end

	if virtualNode.bindings == nil then
		virtualNode.bindings = {}
	end

	virtualNode.bindings[key] = Binding.subscribe(newBinding, updateBoundProperty)

	updateBoundProperty(newBinding:getValue())
end

local function detachAllBindings(virtualNode)
	if virtualNode.bindings ~= nil then
		for _, disconnect in pairs(virtualNode.bindings) do
			disconnect()
		end
		virtualNode.bindings = nil
	end
end

local function applyProp(virtualNode, key, newValue, oldValue)
	if newValue == oldValue then
		return
	end

	if key == Ref or key == Children then
		-- Refs and children are handled in a separate pass
		return
	end

	local internalKeyType = Type.of(key)

	if internalKeyType == Type.HostEvent or internalKeyType == Type.HostChangeEvent then
		if virtualNode.eventManager == nil then
			virtualNode.eventManager = SingleEventManager.new(virtualNode.hostObject)
		end

		local eventName = key.name

		if internalKeyType == Type.HostChangeEvent then
			virtualNode.eventManager:connectPropertyChange(eventName, newValue)
		else
			virtualNode.eventManager:connectEvent(eventName, newValue)
		end

		return
	end

	local newIsBinding = Type.of(newValue) == Type.Binding
	local oldIsBinding = Type.of(oldValue) == Type.Binding

	if oldIsBinding then
		removeBinding(virtualNode, key)
	end

	if newIsBinding then
		attachBinding(virtualNode, key, newValue)
	else
		setRobloxInstanceProperty(virtualNode.hostObject, key, newValue)
	end
end

local function applyProps(virtualNode, props)
	for propKey, value in pairs(props) do
		applyProp(virtualNode, propKey, value, nil)
	end
end

local function updateProps(virtualNode, oldProps, newProps)
	-- Apply props that were added or updated
	for propKey, newValue in pairs(newProps) do
		local oldValue = oldProps[propKey]

		applyProp(virtualNode, propKey, newValue, oldValue)
	end

	-- Clean up props that were removed
	for propKey, oldValue in pairs(oldProps) do
		local newValue = newProps[propKey]

		if newValue == nil then
			applyProp(virtualNode, propKey, nil, oldValue)
		end
	end
end

local RobloxRenderer = {}

function RobloxRenderer.isHostObject(target)
	return typeof(target) == "Instance"
end

function RobloxRenderer.mountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement
	local hostParent = virtualNode.hostParent
	local hostKey = virtualNode.hostKey

	if config.internalTypeChecks then
		internalAssert(ElementKind.of(element) == ElementKind.Host, "Element at given node is not a host Element")
	end
	if config.typeChecks then
		assert(element.props.Name == nil, "Name can not be specified as a prop to a host component in Roact.")
		assert(element.props.Parent == nil, "Parent can not be specified as a prop to a host component in Roact.")
	end

	local instance = Instance.new(element.component)
	virtualNode.hostObject = instance

	local success, errorMessage = xpcall(function()
		applyProps(virtualNode, element.props)
	end, identity)

	if not success then
		local source = element.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = applyPropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	instance.Name = tostring(hostKey)

	local children = element.props[Children]

	if children ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	instance.Parent = hostParent
	virtualNode.hostObject = instance

	applyRef(element.props[Ref], instance)

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end
end

function RobloxRenderer.unmountHostNode(reconciler, virtualNode)
	local element = virtualNode.currentElement

	applyRef(element.props[Ref], nil)

	for _, childNode in pairs(virtualNode.children) do
		reconciler.unmountVirtualNode(childNode)
	end

	detachAllBindings(virtualNode)

	virtualNode.hostObject:Destroy()
end

function RobloxRenderer.updateHostNode(reconciler, virtualNode, newElement)
	local oldProps = virtualNode.currentElement.props
	local newProps = newElement.props

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:suspend()
	end

	-- If refs changed, detach the old ref and attach the new one
	if oldProps[Ref] ~= newProps[Ref] then
		applyRef(oldProps[Ref], nil)
		applyRef(newProps[Ref], virtualNode.hostObject)
	end

	local success, errorMessage = xpcall(function()
		updateProps(virtualNode, oldProps, newProps)
	end, identity)

	if not success then
		local source = newElement.source

		if source == nil then
			source = "<enable element tracebacks>"
		end

		local fullMessage = updatePropsError:format(errorMessage, source)
		error(fullMessage, 0)
	end

	local children = newElement.props[Children]
	if children ~= nil or oldProps[Children] ~= nil then
		reconciler.updateVirtualNodeWithChildren(virtualNode, virtualNode.hostObject, children)
	end

	if virtualNode.eventManager ~= nil then
		virtualNode.eventManager:resume()
	end

	return virtualNode
end

return RobloxRenderer
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="248">
                <Properties>
                  <string name="Name">SingleEventManager</string>
                  <string name="Source"><![CDATA[--[[
	A manager for a single host virtual node's connected events.
]]

local Logging = require(script.Parent.Logging)

local CHANGE_PREFIX = "Change."

local EventStatus = {
	-- No events are processed at all; they're silently discarded
	Disabled = "Disabled",

	-- Events are stored in a queue; listeners are invoked when the manager is resumed
	Suspended = "Suspended",

	-- Event listeners are invoked as the events fire
	Enabled = "Enabled",
}

local SingleEventManager = {}
SingleEventManager.__index = SingleEventManager

function SingleEventManager.new(instance)
	local self = setmetatable({
		-- The queue of suspended events
		_suspendedEventQueue = {},

		-- All the event connections being managed
		-- Events are indexed by a string key
		_connections = {},

		-- All the listeners being managed
		-- These are stored distinctly from the connections
		-- Connections can have their listeners replaced at runtime
		_listeners = {},

		-- The suspension status of the manager
		-- Managers start disabled and are "resumed" after the initial render
		_status = EventStatus.Disabled,

		-- If true, the manager is processing queued events right now.
		_isResuming = false,

		-- The Roblox instance the manager is managing
		_instance = instance,
	}, SingleEventManager)

	return self
end

function SingleEventManager:connectEvent(key, listener)
	self:_connect(key, self._instance[key], listener)
end

function SingleEventManager:connectPropertyChange(key, listener)
	local success, event = pcall(function()
		return self._instance:GetPropertyChangedSignal(key)
	end)

	if not success then
		error(("Cannot get changed signal on property %q: %s"):format(tostring(key), event), 0)
	end

	self:_connect(CHANGE_PREFIX .. key, event, listener)
end

function SingleEventManager:_connect(eventKey, event, listener)
	-- If the listener doesn't exist we can just disconnect the existing connection
	if listener == nil then
		if self._connections[eventKey] ~= nil then
			self._connections[eventKey]:Disconnect()
			self._connections[eventKey] = nil
		end

		self._listeners[eventKey] = nil
	else
		if self._connections[eventKey] == nil then
			self._connections[eventKey] = event:Connect(function(...)
				if self._status == EventStatus.Enabled then
					self._listeners[eventKey](self._instance, ...)
				elseif self._status == EventStatus.Suspended then
					-- Store this event invocation to be fired when resume is
					-- called.

					local argumentCount = select("#", ...)
					table.insert(self._suspendedEventQueue, { eventKey, argumentCount, ... })
				end
			end)
		end

		self._listeners[eventKey] = listener
	end
end

function SingleEventManager:suspend()
	self._status = EventStatus.Suspended
end

function SingleEventManager:resume()
	-- If we're already resuming events for this instance, trying to resume
	-- again would cause a disaster.
	if self._isResuming then
		return
	end

	self._isResuming = true

	local index = 1

	-- More events might be added to the queue when evaluating events, so we
	-- need to be careful in order to preserve correct evaluation order.
	while index <= #self._suspendedEventQueue do
		local eventInvocation = self._suspendedEventQueue[index]
		local listener = self._listeners[eventInvocation[1]]
		local argumentCount = eventInvocation[2]

		-- The event might have been disconnected since suspension started; in
		-- this case, we drop the event.
		if listener ~= nil then
			-- Wrap the listener in a coroutine to catch errors and handle
			-- yielding correctly.
			local listenerCo = coroutine.create(listener)
			local success, result = coroutine.resume(
				listenerCo,
				self._instance,
				unpack(eventInvocation, 3, 2 + argumentCount)
			)

			-- If the listener threw an error, we log it as a warning, since
			-- there's no way to write error text in Roblox Lua without killing
			-- our thread!
			if not success then
				Logging.warn("%s", result)
			end
		end

		index = index + 1
	end

	self._isResuming = false
	self._status = EventStatus.Enabled
	self._suspendedEventQueue = {}
end

return SingleEventManager
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="249">
                <Properties>
                  <string name="Name">Symbol</string>
                  <string name="Source"><![CDATA[--!strict
--[[
	A 'Symbol' is an opaque marker type.

	Symbols have the type 'userdata', but when printed to the console, the name
	of the symbol is shown.
]]

local Symbol = {}

--[[
	Creates a Symbol with the given name.

	When printed or coerced to a string, the symbol will turn into the string
	given as its name.
]]
function Symbol.named(name)
	assert(type(name) == "string", "Symbols must be created using a string name!")

	local self = newproxy(true)

	local wrappedName = ("Symbol(%s)"):format(name)

	getmetatable(self).__tostring = function()
		return wrappedName
	end

	return self
end

return Symbol
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="250">
                <Properties>
                  <string name="Name">Type</string>
                  <string name="Source"><![CDATA[--[[
	Contains markers for annotating objects with types.

	To set the type of an object, use `Type` as a key and the actual marker as
	the value:

		local foo = {
			[Type] = Type.Foo,
		}
]]

local Symbol = require(script.Parent.Symbol)
local strict = require(script.Parent.strict)

local Type = newproxy(true)

local TypeInternal = {}

local function addType(name)
	TypeInternal[name] = Symbol.named("Roact" .. name)
end

addType("Binding")
addType("Element")
addType("HostChangeEvent")
addType("HostEvent")
addType("StatefulComponentClass")
addType("StatefulComponentInstance")
addType("VirtualNode")
addType("VirtualTree")

function TypeInternal.of(value)
	if typeof(value) ~= "table" then
		return nil
	end

	return value[Type]
end

getmetatable(Type).__index = TypeInternal

getmetatable(Type).__tostring = function()
	return "RoactType"
end

strict(TypeInternal, "Type")

return Type
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="251">
                <Properties>
                  <string name="Name">assertDeepEqual</string>
                  <string name="Source"><![CDATA[--!strict
--[[
	A utility used to assert that two objects are value-equal recursively. It
	outputs fairly nicely formatted messages to help diagnose why two objects
	would be different.

	This should only be used in tests.
]]

local function deepEqual(a: any, b: any): (boolean, string?)
	if typeof(a) ~= typeof(b) then
		local message = ("{1} is of type %s, but {2} is of type %s"):format(typeof(a), typeof(b))
		return false, message
	end

	if typeof(a) == "table" then
		local visitedKeys = {}

		for key, value in pairs(a) do
			visitedKeys[key] = true

			local success, innerMessage = deepEqual(value, b[key])
			if not success and innerMessage then
				local message = innerMessage
					:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
					:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

				return false, message
			end
		end

		for key, value in pairs(b) do
			if not visitedKeys[key] then
				local success, innerMessage = deepEqual(value, a[key])

				if not success and innerMessage then
					local message = innerMessage
						:gsub("{1}", ("{1}[%s]"):format(tostring(key)))
						:gsub("{2}", ("{2}[%s]"):format(tostring(key)))

					return false, message
				end
			end
		end

		return true, nil
	end

	if a == b then
		return true, nil
	end

	local message = "{1} ~= {2}"
	return false, message
end

local function assertDeepEqual(a, b)
	local success, innerMessageTemplate = deepEqual(a, b)

	if not success and innerMessageTemplate then
		local innerMessage = innerMessageTemplate:gsub("{1}", "first"):gsub("{2}", "second")

		local message = ("Values were not deep-equal.\n%s"):format(innerMessage)

		error(message, 2)
	end
end

return assertDeepEqual
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="252">
                <Properties>
                  <string name="Name">assign</string>
                  <string name="Source"><![CDATA[local None = require(script.Parent.None)

--[[
	Merges values from zero or more tables onto a target table. If a value is
	set to None, it will instead be removed from the table.

	This function is identical in functionality to JavaScript's Object.assign.
]]
local function assign(target, ...)
	for index = 1, select("#", ...) do
		local source = select(index, ...)

		if source ~= nil then
			for key, value in pairs(source) do
				if value == None then
					target[key] = nil
				else
					target[key] = value
				end
			end
		end
	end

	return target
end

return assign
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="253">
                <Properties>
                  <string name="Name">createContext</string>
                  <string name="Source"><![CDATA[local Symbol = require(script.Parent.Symbol)
local createFragment = require(script.Parent.createFragment)
local createSignal = require(script.Parent.createSignal)
local Children = require(script.Parent.PropMarkers.Children)
local Component = require(script.Parent.Component)

--[[
	Construct the value that is assigned to Roact's context storage.
]]
local function createContextEntry(currentValue)
	return {
		value = currentValue,
		onUpdate = createSignal(),
	}
end

local function createProvider(context)
	local Provider = Component:extend("Provider")

	function Provider:init(props)
		self.contextEntry = createContextEntry(props.value)
		self:__addContext(context.key, self.contextEntry)
	end

	function Provider:willUpdate(nextProps)
		-- If the provided value changed, immediately update the context entry.
		--
		-- During this update, any components that are reachable will receive
		-- this updated value at the same time as any props and state updates
		-- that are being applied.
		if nextProps.value ~= self.props.value then
			self.contextEntry.value = nextProps.value
		end
	end

	function Provider:didUpdate(prevProps)
		-- If the provided value changed, after we've updated every reachable
		-- component, fire a signal to update the rest.
		--
		-- This signal will notify all context consumers. It's expected that
		-- they will compare the last context value they updated with and only
		-- trigger an update on themselves if this value is different.
		--
		-- This codepath will generally only update consumer components that has
		-- a component implementing shouldUpdate between them and the provider.
		if prevProps.value ~= self.props.value then
			self.contextEntry.onUpdate:fire(self.props.value)
		end
	end

	function Provider:render()
		return createFragment(self.props[Children])
	end

	return Provider
end

local function createConsumer(context)
	local Consumer = Component:extend("Consumer")

	function Consumer.validateProps(props)
		if type(props.render) ~= "function" then
			return false, "Consumer expects a `render` function"
		else
			return true
		end
	end

	function Consumer:init(_props)
		-- This value may be nil, which indicates that our consumer is not a
		-- descendant of a provider for this context item.
		self.contextEntry = self:__getContext(context.key)
	end

	function Consumer:render()
		-- Render using the latest available for this context item.
		--
		-- We don't store this value in state in order to have more fine-grained
		-- control over our update behavior.
		local value
		if self.contextEntry ~= nil then
			value = self.contextEntry.value
		else
			value = context.defaultValue
		end

		return self.props.render(value)
	end

	function Consumer:didUpdate()
		-- Store the value that we most recently updated with.
		--
		-- This value is compared in the contextEntry onUpdate hook below.
		if self.contextEntry ~= nil then
			self.lastValue = self.contextEntry.value
		end
	end

	function Consumer:didMount()
		if self.contextEntry ~= nil then
			-- When onUpdate is fired, a new value has been made available in
			-- this context entry, but we may have already updated in the same
			-- update cycle.
			--
			-- To avoid sending a redundant update, we compare the new value
			-- with the last value that we updated with (set in didUpdate) and
			-- only update if they differ. This may happen when an update from a
			-- provider was blocked by an intermediate component that returned
			-- false from shouldUpdate.
			self.disconnect = self.contextEntry.onUpdate:subscribe(function(newValue)
				if newValue ~= self.lastValue then
					-- Trigger a dummy state update.
					self:setState({})
				end
			end)
		end
	end

	function Consumer:willUnmount()
		if self.disconnect ~= nil then
			self.disconnect()
			self.disconnect = nil
		end
	end

	return Consumer
end

local Context = {}
Context.__index = Context

function Context.new(defaultValue)
	return setmetatable({
		defaultValue = defaultValue,
		key = Symbol.named("ContextKey"),
	}, Context)
end

function Context:__tostring()
	return "RoactContext"
end

local function createContext(defaultValue)
	local context = Context.new(defaultValue)

	return {
		Provider = createProvider(context),
		Consumer = createConsumer(context),
	}
end

return createContext
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="254">
                <Properties>
                  <string name="Name">createElement</string>
                  <string name="Source"><![CDATA[local Children = require(script.Parent.PropMarkers.Children)
local ElementKind = require(script.Parent.ElementKind)
local Logging = require(script.Parent.Logging)
local Type = require(script.Parent.Type)

local config = require(script.Parent.GlobalConfig).get()

local multipleChildrenMessage = [[
The prop `Roact.Children` was defined but was overridden by the third parameter to createElement!
This can happen when a component passes props through to a child element but also uses the `children` argument:

	Roact.createElement("Frame", passedProps, {
		child = ...
	})

Instead, consider using a utility function to merge tables of children together:

	local children = mergeTables(passedProps[Roact.Children], {
		child = ...
	})

	local fullProps = mergeTables(passedProps, {
		[Roact.Children] = children
	})

	Roact.createElement("Frame", fullProps)]]

--[[
	Creates a new element representing the given component.

	Elements are lightweight representations of what a component instance should
	look like.

	Children is a shorthand for specifying `Roact.Children` as a key inside
	props. If specified, the passed `props` table is mutated!
]]
local function createElement(component, props, children)
	if config.typeChecks then
		assert(component ~= nil, "`component` is required")
		assert(typeof(props) == "table" or props == nil, "`props` must be a table or nil")
		assert(typeof(children) == "table" or children == nil, "`children` must be a table or nil")
	end

	if props == nil then
		props = {}
	end

	if children ~= nil then
		if props[Children] ~= nil then
			Logging.warnOnce(multipleChildrenMessage)
		end

		props[Children] = children
	end

	local elementKind = ElementKind.fromComponent(component)

	local element = {
		[Type] = Type.Element,
		[ElementKind] = elementKind,
		component = component,
		props = props,
	}

	if config.elementTracing then
		-- We trim out the leading newline since there's no way to specify the
		-- trace level without also specifying a message.
		element.source = debug.traceback("", 2):sub(2)
	end

	return element
end

return createElement
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="255">
                <Properties>
                  <string name="Name">createFragment</string>
                  <string name="Source"><![CDATA[local ElementKind = require(script.Parent.ElementKind)
local Type = require(script.Parent.Type)

local function createFragment(elements)
	return {
		[Type] = Type.Element,
		[ElementKind] = ElementKind.Fragment,
		elements = elements,
	}
end

return createFragment
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="256">
                <Properties>
                  <string name="Name">createReconciler</string>
                  <string name="Source"><![CDATA[--!nonstrict
local Type = require(script.Parent.Type)
local ElementKind = require(script.Parent.ElementKind)
local ElementUtils = require(script.Parent.ElementUtils)
local Children = require(script.Parent.PropMarkers.Children)
local Symbol = require(script.Parent.Symbol)
local internalAssert = require(script.Parent.internalAssert)

local config = require(script.Parent.GlobalConfig).get()

local InternalData = Symbol.named("InternalData")

--[[
	The reconciler is the mechanism in Roact that constructs the virtual tree
	that later gets turned into concrete objects by the renderer.

	Roact's reconciler is constructed with the renderer as an argument, which
	enables switching to different renderers for different platforms or
	scenarios.

	When testing the reconciler itself, it's common to use `NoopRenderer` with
	spies replacing some methods. The default (and only) reconciler interface
	exposed by Roact right now uses `RobloxRenderer`.
]]
local function createReconciler(renderer)
	local reconciler
	local mountVirtualNode
	local updateVirtualNode
	local unmountVirtualNode

	--[[
		Unmount the given virtualNode, replacing it with a new node described by
		the given element.

		Preserves host properties, depth, and legacyContext from parent.
	]]
	local function replaceVirtualNode(virtualNode, newElement)
		local hostParent = virtualNode.hostParent
		local hostKey = virtualNode.hostKey
		local depth = virtualNode.depth
		local parent = virtualNode.parent

		-- If the node that is being replaced has modified context, we need to
		-- use the original *unmodified* context for the new node
		-- The `originalContext` field will be nil if the context was unchanged
		local context = virtualNode.originalContext or virtualNode.context
		local parentLegacyContext = virtualNode.parentLegacyContext

		-- If updating this node has caused a component higher up the tree to re-render
		-- and updateChildren to be re-entered then this node could already have been
		-- unmounted in the previous updateChildren pass.
		if not virtualNode.wasUnmounted then
			unmountVirtualNode(virtualNode)
		end
		local newNode = mountVirtualNode(newElement, hostParent, hostKey, context, parentLegacyContext)

		-- mountVirtualNode can return nil if the element is a boolean
		if newNode ~= nil then
			newNode.depth = depth
			newNode.parent = parent
		end

		return newNode
	end

	--[[
		Utility to update the children of a virtual node based on zero or more
		updated children given as elements.
	]]
	local function updateChildren(virtualNode, hostParent, newChildElements)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		virtualNode.updateChildrenCount = virtualNode.updateChildrenCount + 1

		local currentUpdateChildrenCount = virtualNode.updateChildrenCount

		local removeKeys = {}

		-- Changed or removed children
		for childKey, childNode in pairs(virtualNode.children) do
			local newElement = ElementUtils.getElementByKey(newChildElements, childKey)
			local newNode = updateVirtualNode(childNode, newElement)

			-- If updating this node has caused a component higher up the tree to re-render
			-- and updateChildren to be re-entered for this virtualNode then
			-- this result is invalid and needs to be disgarded.
			if virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then
				if newNode and newNode ~= virtualNode.children[childKey] then
					unmountVirtualNode(newNode)
				end
				return
			end

			if newNode ~= nil then
				virtualNode.children[childKey] = newNode
			else
				removeKeys[childKey] = true
			end
		end

		for childKey in pairs(removeKeys) do
			virtualNode.children[childKey] = nil
		end

		-- Added children
		for childKey, newElement in ElementUtils.iterateElements(newChildElements) do
			local concreteKey = childKey
			if childKey == ElementUtils.UseParentKey then
				concreteKey = virtualNode.hostKey
			end

			if virtualNode.children[childKey] == nil then
				local childNode = mountVirtualNode(
					newElement,
					hostParent,
					concreteKey,
					virtualNode.context,
					virtualNode.legacyContext
				)

				-- If updating this node has caused a component higher up the tree to re-render
				-- and updateChildren to be re-entered for this virtualNode then
				-- this result is invalid and needs to be discarded.
				if virtualNode.updateChildrenCount ~= currentUpdateChildrenCount then
					if childNode then
						unmountVirtualNode(childNode)
					end
					return
				end

				-- mountVirtualNode can return nil if the element is a boolean
				if childNode ~= nil then
					childNode.depth = virtualNode.depth + 1
					childNode.parent = virtualNode
					virtualNode.children[childKey] = childNode
				end
			end
		end
	end

	local function updateVirtualNodeWithChildren(virtualNode, hostParent, newChildElements)
		updateChildren(virtualNode, hostParent, newChildElements)
	end

	local function updateVirtualNodeWithRenderResult(virtualNode, hostParent, renderResult)
		if Type.of(renderResult) == Type.Element or renderResult == nil or typeof(renderResult) == "boolean" then
			updateChildren(virtualNode, hostParent, renderResult)
		else
			error(
				("%s\n%s"):format(
					"Component returned invalid children:",
					virtualNode.currentElement.source or "<enable element tracebacks>"
				),
				0
			)
		end
	end

	--[[
		Unmounts the given virtual node and releases any held resources.
	]]
	function unmountVirtualNode(virtualNode)
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end

		virtualNode.wasUnmounted = true

		local kind = ElementKind.of(virtualNode.currentElement)

		-- selene: allow(if_same_then_else)
		if kind == ElementKind.Host then
			renderer.unmountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Stateful then
			virtualNode.instance:__unmount()
		elseif kind == ElementKind.Portal then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		elseif kind == ElementKind.Fragment then
			for _, childNode in pairs(virtualNode.children) do
				unmountVirtualNode(childNode)
			end
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end
	end

	local function updateFunctionVirtualNode(virtualNode, newElement)
		local children = newElement.component(newElement.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)

		return virtualNode
	end

	local function updatePortalVirtualNode(virtualNode, newElement)
		local oldElement = virtualNode.currentElement
		local oldTargetHostParent = oldElement.props.target

		local targetHostParent = newElement.props.target

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		if targetHostParent ~= oldTargetHostParent then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local children = newElement.props[Children]

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)

		return virtualNode
	end

	local function updateFragmentVirtualNode(virtualNode, newElement)
		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, newElement.elements)

		return virtualNode
	end

	--[[
		Update the given virtual node using a new element describing what it
		should transform into.

		`updateVirtualNode` will return a new virtual node that should replace
		the passed in virtual node. This is because a virtual node can be
		updated with an element referencing a different component!

		In that case, `updateVirtualNode` will unmount the input virtual node,
		mount a new virtual node, and return it in this case, while also issuing
		a warning to the user.
	]]
	function updateVirtualNode(virtualNode, newElement, newState: { [any]: any }?): { [any]: any }?
		if config.internalTypeChecks then
			internalAssert(Type.of(virtualNode) == Type.VirtualNode, "Expected arg #1 to be of type VirtualNode")
		end
		if config.typeChecks then
			assert(
				Type.of(newElement) == Type.Element or typeof(newElement) == "boolean" or newElement == nil,
				"Expected arg #2 to be of type Element, boolean, or nil"
			)
		end

		-- If nothing changed, we can skip this update
		if virtualNode.currentElement == newElement and newState == nil then
			return virtualNode
		end

		if typeof(newElement) == "boolean" or newElement == nil then
			unmountVirtualNode(virtualNode)
			return nil
		end

		if virtualNode.currentElement.component ~= newElement.component then
			return replaceVirtualNode(virtualNode, newElement)
		end

		local kind = ElementKind.of(newElement)

		local shouldContinueUpdate = true

		if kind == ElementKind.Host then
			virtualNode = renderer.updateHostNode(reconciler, virtualNode, newElement)
		elseif kind == ElementKind.Function then
			virtualNode = updateFunctionVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Stateful then
			shouldContinueUpdate = virtualNode.instance:__update(newElement, newState)
		elseif kind == ElementKind.Portal then
			virtualNode = updatePortalVirtualNode(virtualNode, newElement)
		elseif kind == ElementKind.Fragment then
			virtualNode = updateFragmentVirtualNode(virtualNode, newElement)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end

		-- Stateful components can abort updates via shouldUpdate. If that
		-- happens, we should stop doing stuff at this point.
		if not shouldContinueUpdate then
			return virtualNode
		end

		virtualNode.currentElement = newElement

		return virtualNode
	end

	--[[
		Constructs a new virtual node but not does mount it.
	]]
	local function createVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(
				renderer.isHostObject(hostParent) or hostParent == nil,
				"Expected arg #2 to be a host object"
			)
			internalAssert(typeof(context) == "table" or context == nil, "Expected arg #4 to be of type table or nil")
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		return {
			[Type] = Type.VirtualNode,
			currentElement = element,
			depth = 1,
			parent = nil,
			children = {},
			hostParent = hostParent,
			hostKey = hostKey,
			updateChildrenCount = 0,
			wasUnmounted = false,

			-- Legacy Context API
			-- A table of context values inherited from the parent node
			legacyContext = legacyContext,

			-- A saved copy of the parent context, used when replacing a node
			parentLegacyContext = legacyContext,

			-- Context API
			-- A table of context values inherited from the parent node
			context = context or {},

			-- A saved copy of the unmodified context; this will be updated when
			-- a component adds new context and used when a node is replaced
			originalContext = nil,
		}
	end

	local function mountFunctionVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local children = element.component(element.props)

		updateVirtualNodeWithRenderResult(virtualNode, virtualNode.hostParent, children)
	end

	local function mountPortalVirtualNode(virtualNode)
		local element = virtualNode.currentElement

		local targetHostParent = element.props.target
		local children = element.props[Children]

		assert(renderer.isHostObject(targetHostParent), "Expected target to be host object")

		updateVirtualNodeWithChildren(virtualNode, targetHostParent, children)
	end

	local function mountFragmentVirtualNode(virtualNode)
		local element = virtualNode.currentElement
		local children = element.elements

		updateVirtualNodeWithChildren(virtualNode, virtualNode.hostParent, children)
	end

	--[[
		Constructs a new virtual node and mounts it, but does not place it into
		the tree.
	]]
	function mountVirtualNode(element, hostParent, hostKey, context, legacyContext)
		if config.internalTypeChecks then
			internalAssert(
				renderer.isHostObject(hostParent) or hostParent == nil,
				"Expected arg #2 to be a host object"
			)
			internalAssert(
				typeof(legacyContext) == "table" or legacyContext == nil,
				"Expected arg #5 to be of type table or nil"
			)
		end
		if config.typeChecks then
			assert(hostKey ~= nil, "Expected arg #3 to be non-nil")
			assert(
				Type.of(element) == Type.Element or typeof(element) == "boolean",
				"Expected arg #1 to be of type Element or boolean"
			)
		end

		-- Boolean values render as nil to enable terse conditional rendering.
		if typeof(element) == "boolean" then
			return nil
		end

		local kind = ElementKind.of(element)

		local virtualNode = createVirtualNode(element, hostParent, hostKey, context, legacyContext)

		if kind == ElementKind.Host then
			renderer.mountHostNode(reconciler, virtualNode)
		elseif kind == ElementKind.Function then
			mountFunctionVirtualNode(virtualNode)
		elseif kind == ElementKind.Stateful then
			element.component:__mount(reconciler, virtualNode)
		elseif kind == ElementKind.Portal then
			mountPortalVirtualNode(virtualNode)
		elseif kind == ElementKind.Fragment then
			mountFragmentVirtualNode(virtualNode)
		else
			error(("Unknown ElementKind %q"):format(tostring(kind)), 2)
		end

		return virtualNode
	end

	--[[
		Constructs a new Roact virtual tree, constructs a root node for
		it, and mounts it.
	]]
	local function mountVirtualTree(element, hostParent, hostKey)
		if config.typeChecks then
			assert(Type.of(element) == Type.Element, "Expected arg #1 to be of type Element")
			assert(renderer.isHostObject(hostParent) or hostParent == nil, "Expected arg #2 to be a host object")
		end

		if hostKey == nil then
			hostKey = "RoactTree"
		end

		local tree = {
			[Type] = Type.VirtualTree,
			[InternalData] = {
				-- The root node of the tree, which starts into the hierarchy of
				-- Roact component instances.
				rootNode = nil,
				mounted = true,
			},
		}

		tree[InternalData].rootNode = mountVirtualNode(element, hostParent, hostKey)

		return tree
	end

	--[[
		Unmounts the virtual tree, freeing all of its resources.

		No further operations should be done on the tree after it's been
		unmounted, as indicated by its the `mounted` field.
	]]
	local function unmountVirtualTree(tree)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(internalData.mounted, "Cannot unmounted a Roact tree that has already been unmounted")
		end

		internalData.mounted = false

		if internalData.rootNode ~= nil then
			unmountVirtualNode(internalData.rootNode)
		end
	end

	--[[
		Utility method for updating the root node of a virtual tree given a new
		element.
	]]
	local function updateVirtualTree(tree, newElement)
		local internalData = tree[InternalData]
		if config.typeChecks then
			assert(Type.of(tree) == Type.VirtualTree, "Expected arg #1 to be a Roact handle")
			assert(Type.of(newElement) == Type.Element, "Expected arg #2 to be a Roact Element")
		end

		internalData.rootNode = updateVirtualNode(internalData.rootNode, newElement)

		return tree
	end

	reconciler = {
		mountVirtualTree = mountVirtualTree,
		unmountVirtualTree = unmountVirtualTree,
		updateVirtualTree = updateVirtualTree,

		createVirtualNode = createVirtualNode,
		mountVirtualNode = mountVirtualNode,
		unmountVirtualNode = unmountVirtualNode,
		updateVirtualNode = updateVirtualNode,
		updateVirtualNodeWithChildren = updateVirtualNodeWithChildren,
		updateVirtualNodeWithRenderResult = updateVirtualNodeWithRenderResult,
	}

	return reconciler
end

return createReconciler
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="257">
                <Properties>
                  <string name="Name">createReconcilerCompat</string>
                  <string name="Source"><![CDATA[--[[
	Contains deprecated methods from Reconciler. Broken out so that removing
	this shim is easy -- just delete this file and remove it from init.
]]

local Logging = require(script.Parent.Logging)

local reifyMessage = [[
Roact.reify has been renamed to Roact.mount and will be removed in a future release.
Check the call to Roact.reify at:
]]

local teardownMessage = [[
Roact.teardown has been renamed to Roact.unmount and will be removed in a future release.
Check the call to Roact.teardown at:
]]

local reconcileMessage = [[
Roact.reconcile has been renamed to Roact.update and will be removed in a future release.
Check the call to Roact.reconcile at:
]]

local function createReconcilerCompat(reconciler)
	local compat = {}

	function compat.reify(...)
		Logging.warnOnce(reifyMessage)

		return reconciler.mountVirtualTree(...)
	end

	function compat.teardown(...)
		Logging.warnOnce(teardownMessage)

		return reconciler.unmountVirtualTree(...)
	end

	function compat.reconcile(...)
		Logging.warnOnce(reconcileMessage)

		return reconciler.updateVirtualTree(...)
	end

	return compat
end

return createReconcilerCompat
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="258">
                <Properties>
                  <string name="Name">createRef</string>
                  <string name="Source"><![CDATA[--[[
	A ref is nothing more than a binding with a special field 'current'
	that maps to the getValue method of the binding
]]
local Binding = require(script.Parent.Binding)

local function createRef()
	local binding, _ = Binding.create(nil)

	local ref = {}

	--[[
		A ref is just redirected to a binding via its metatable
	]]
	setmetatable(ref, {
		__index = function(_self, key)
			if key == "current" then
				return binding:getValue()
			else
				return binding[key]
			end
		end,
		__newindex = function(_self, key, value)
			if key == "current" then
				error("Cannot assign to the 'current' property of refs", 2)
			end

			binding[key] = value
		end,
		__tostring = function(_self)
			return ("RoactRef(%s)"):format(tostring(binding:getValue()))
		end,
	})

	return ref
end

return createRef
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="259">
                <Properties>
                  <string name="Name">createSignal</string>
                  <string name="Source"><![CDATA[--[[
	This is a simple signal implementation that has a dead-simple API.

		local signal = createSignal()

		local disconnect = signal:subscribe(function(foo)
			print("Cool foo:", foo)
		end)

		signal:fire("something")

		disconnect()
]]

local function createSignal()
	local connections = {}
	local suspendedConnections = {}
	local firing = false

	local function subscribe(_self, callback)
		assert(typeof(callback) == "function", "Can only subscribe to signals with a function.")

		local connection = {
			callback = callback,
			disconnected = false,
		}

		-- If the callback is already registered, don't add to the suspendedConnection. Otherwise, this will disable
		-- the existing one.
		if firing and not connections[callback] then
			suspendedConnections[callback] = connection
		end

		connections[callback] = connection

		local function disconnect()
			assert(not connection.disconnected, "Listeners can only be disconnected once.")

			connection.disconnected = true
			connections[callback] = nil
			suspendedConnections[callback] = nil
		end

		return disconnect
	end

	local function fire(_self, ...)
		firing = true
		for callback, connection in pairs(connections) do
			if not connection.disconnected and not suspendedConnections[callback] then
				callback(...)
			end
		end

		firing = false

		for callback, _ in pairs(suspendedConnections) do
			suspendedConnections[callback] = nil
		end
	end

	return {
		subscribe = subscribe,
		fire = fire,
	}
end

return createSignal
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="260">
                <Properties>
                  <string name="Name">createSpy</string>
                  <string name="Source"><![CDATA[--[[
	A utility used to create a function spy that can be used to robustly test
	that functions are invoked the correct number of times and with the correct
	number of arguments.

	This should only be used in tests.
]]

local assertDeepEqual = require(script.Parent.assertDeepEqual)

local function createSpy(inner)
	local self = {}
	self.callCount = 0
	self.values = {}
	self.valuesLength = 0
	self.value = function(...)
		self.callCount = self.callCount + 1
		self.values = { ... }
		self.valuesLength = select("#", ...)

		if inner ~= nil then
			return inner(...)
		end
		return nil
	end

	self.assertCalledWith = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(self.valuesLength, len), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assert(self.values[i] == expected, "value differs")
		end
	end

	self.assertCalledWithDeepEqual = function(_, ...)
		local len = select("#", ...)

		if self.valuesLength ~= len then
			error(("Expected %d arguments, but was called with %d arguments"):format(self.valuesLength, len), 2)
		end

		for i = 1, len do
			local expected = select(i, ...)

			assertDeepEqual(self.values[i], expected)
		end
	end

	self.captureValues = function(_, ...)
		local len = select("#", ...)
		local result = {}

		assert(self.valuesLength == len, "length of expected values differs from stored values")

		for i = 1, len do
			local key = select(i, ...)
			result[key] = self.values[i]
		end

		return result
	end

	setmetatable(self, {
		__index = function(_, key)
			error(("%q is not a valid member of spy"):format(key))
		end,
	})

	return self
end

return createSpy
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="261">
                <Properties>
                  <string name="Name">forwardRef</string>
                  <string name="Source"><![CDATA[local assign = require(script.Parent.assign)
local None = require(script.Parent.None)
local Ref = require(script.Parent.PropMarkers.Ref)

local config = require(script.Parent.GlobalConfig).get()

local excludeRef = {
	[Ref] = None,
}

--[[
	Allows forwarding of refs to underlying host components. Accepts a render
	callback which accepts props and a ref, and returns an element.
]]
local function forwardRef(render)
	if config.typeChecks then
		assert(typeof(render) == "function", "Expected arg #1 to be a function")
	end

	return function(props)
		local ref = props[Ref]
		local propsWithoutRef = assign({}, props, excludeRef)

		return render(propsWithoutRef, ref)
	end
end

return forwardRef
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="262">
                <Properties>
                  <string name="Name">getDefaultInstanceProperty</string>
                  <string name="Source"><![CDATA[--[[
	Attempts to get the default value of a given property on a Roblox instance.

	This is used by the reconciler in cases where a prop was previously set on a
	primitive component, but is no longer present in a component's new props.

	Eventually, Roblox might provide a nicer API to query the default property
	of an object without constructing an instance of it.
]]

local Symbol = require(script.Parent.Symbol)

local Nil = Symbol.named("Nil")
local _cachedPropertyValues = {}

local function getDefaultInstanceProperty(className, propertyName)
	local classCache = _cachedPropertyValues[className]

	if classCache then
		local propValue = classCache[propertyName]

		-- We have to use a marker here, because Lua doesn't distinguish
		-- between 'nil' and 'not in a table'
		if propValue == Nil then
			return true, nil
		end

		if propValue ~= nil then
			return true, propValue
		end
	else
		classCache = {}
		_cachedPropertyValues[className] = classCache
	end

	local created = Instance.new(className)
	local ok, defaultValue = pcall(function()
		return created[propertyName]
	end)

	created:Destroy()

	if ok then
		if defaultValue == nil then
			classCache[propertyName] = Nil
		else
			classCache[propertyName] = defaultValue
		end
	end

	return ok, defaultValue
end

return getDefaultInstanceProperty
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="263">
                <Properties>
                  <string name="Name">internalAssert</string>
                  <string name="Source"><![CDATA[local function internalAssert(condition, message)
	if not condition then
		error(message .. " (This is probably a bug in Roact!)", 3)
	end
end

return internalAssert
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="264">
                <Properties>
                  <string name="Name">invalidSetStateMessages</string>
                  <string name="Source"><![CDATA[--[[
	These messages are used by Component to help users diagnose when they're
	calling setState in inappropriate places.

	The indentation may seem odd, but it's necessary to avoid introducing extra
	whitespace into the error messages themselves.
]]
local ComponentLifecyclePhase = require(script.Parent.ComponentLifecyclePhase)

local invalidSetStateMessages = {}

invalidSetStateMessages[ComponentLifecyclePhase.WillUpdate] = [[
setState cannot be used in the willUpdate lifecycle method.
Consider using the didUpdate method instead, or using getDerivedStateFromProps.

Check the definition of willUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.ShouldUpdate] = [[
setState cannot be used in the shouldUpdate lifecycle method.
shouldUpdate must be a pure function that only depends on props and state.

Check the definition of shouldUpdate in the component %q.]]

invalidSetStateMessages[ComponentLifecyclePhase.Render] = [[
setState cannot be used in the render method.
render must be a pure function that only depends on props and state.

Check the definition of render in the component %q.]]

invalidSetStateMessages["default"] = [[
setState can not be used in the current situation, because Roact doesn't know
which part of the lifecycle this component is in.

This is a bug in Roact.
It was triggered by the component %q.
]]

return invalidSetStateMessages
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="265">
                <Properties>
                  <string name="Name">oneChild</string>
                  <string name="Source"><![CDATA[--[[
	Retrieves at most one child from the children passed to a component.

	If passed nil or an empty table, will return nil.

	Throws an error if passed more than one child.
]]
local function oneChild(children)
	if not children then
		return nil
	end

	local key, child = next(children)

	if not child then
		return nil
	end

	local after = next(children, key)

	if after then
		error("Expected at most child, had more than one child.", 2)
	end

	return child
end

return oneChild
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="266">
                <Properties>
                  <string name="Name">strict</string>
                  <string name="Source"><![CDATA[--!strict
local function strict(t: { [any]: any }, name: string?)
	-- FIXME Luau: Need to define a new variable since reassigning `name = ...`
	-- doesn't narrow the type
	local newName = name or tostring(t)

	return setmetatable(t, {
		__index = function(_self, key)
			local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), newName)

			error(message, 2)
		end,

		__newindex = function(_self, key, _value)
			local message = ("%q (%s) is not a valid member of %s"):format(tostring(key), typeof(key), newName)

			error(message, 2)
		end,
	})
end

return strict
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="267">
                <Properties>
                  <string name="Name">ts</string>
                  <string name="Source"><![CDATA[local Roact = require(script.Parent)

local createElement	= require(script.Parent.createElement)

local Change = require(script.Parent.PropMarkers.Change)
local Event = require(script.Parent.PropMarkers.Event)
local Ref = require(script.Parent.PropMarkers.Ref)

local Symbol = require(script.Parent.Symbol)
local Type = require(script.Parent.Type)

-- unlock
local metatable = getmetatable(Roact)
setmetatable(Roact, nil)

-- allow super(), but do nothing
Roact.Component.constructor = function() end

function Roact.ClassComponent(class)
	local componentClass = Roact.Component:extend(tostring(class))
	setmetatable(class, nil)

	for key, value in class do
		-- need to use componentClass as __index
		if key == "__index" then
			continue
		end
		-- map constructor onto :init()
		if key == "constructor" then
			key = "init"
		end
		componentClass[key] = value
	end

	return componentClass
end

Roact.Fragment = Symbol.named("Roact.Fragment")

local HOST_COMPONENT_NAME_MAPPING = {
	billboardgui = "BillboardGui",
	camera = "Camera",
	canvasgroup = "CanvasGroup",
	frame = "Frame",
	imagebutton = "ImageButton",
	imagelabel = "ImageLabel",
	screengui = "ScreenGui",
	scrollingframe = "ScrollingFrame",
	surfacegui = "SurfaceGui",
	textbox = "TextBox",
	textbutton = "TextButton",
	textlabel = "TextLabel",
	uiaspectratioconstraint = "UIAspectRatioConstraint",
	uicorner = "UICorner",
	uigradient = "UIGradient",
	uigridlayout = "UIGridLayout",
	uilistlayout = "UIListLayout",
	uipadding = "UIPadding",
	uipagelayout = "UIPageLayout",
	uiscale = "UIScale",
	uisizeconstraint = "UISizeConstraint",
	uistroke = "UIStroke",
	uitablelayout = "UITableLayout",
	uitextsizeconstraint = "UITextSizeConstraint",
	viewportframe = "ViewportFrame",
}

function Roact.jsx(component, props, children)
	local newChildren = {}
	if children then
		local i = 1
		for _, child in children do
			local key = child.props.Key
			if key then
				child.props.Key = nil
				newChildren[key] = child
			else
				newChildren[i] = child
				i += 1
			end
		end
	end

	if component == Roact.Fragment then
		return Roact.createFragment(newChildren)
	end

	component = HOST_COMPONENT_NAME_MAPPING[component] or component

	if props ~= nil then
		if props.Change ~= nil then
			for key, value in props.Change do
				props[Change[key]] = value
			end
			props.Change = nil
		end

		if props.Event ~= nil then
			for key, value in props.Event do
				props[Event[key]] = value
			end
			props.Event = nil
		end

		if props.Ref ~= nil then
			props[Ref] = props.Ref
			props.Ref = nil
		end
	end

	-- TODO: we don't know if this is a top-level component with Key?
	-- return Roact.createFragment({ [props.Key] = Roact.createElement(component, props, newChildren) })

	return Roact.createElement(component, props, newChildren)
end

-- relock
setmetatable(Roact, metatable)

return Roact
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="268">
            <Properties>
              <string name="Name">services</string>
              <string name="Source"><![CDATA[return setmetatable({}, {
	__index = function(self, serviceName)
		local service = game:GetService(serviceName)
		self[serviceName] = service
		return service
	end,
})
]]></string>
            </Properties>
          </Item>
          <Item class="Folder" referent="269">
            <Properties>
              <string name="Name">testez</string>
            </Properties>
            <Item class="ModuleScript" referent="270">
              <Properties>
                <string name="Name">src</string>
                <string name="Source">local Expectation = require(script.Expectation)
local TestBootstrap = require(script.TestBootstrap)
local TestEnum = require(script.TestEnum)
local TestPlan = require(script.TestPlan)
local TestPlanner = require(script.TestPlanner)
local TestResults = require(script.TestResults)
local TestRunner = require(script.TestRunner)
local TestSession = require(script.TestSession)
local TextReporter = require(script.Reporters.TextReporter)
local TextReporterQuiet = require(script.Reporters.TextReporterQuiet)
local TeamCityReporter = require(script.Reporters.TeamCityReporter)

local function run(testRoot, callback)
	local modules = TestBootstrap:getModules(testRoot)
	local plan = TestPlanner.createPlan(modules)
	local results = TestRunner.runPlan(plan)

	callback(results)
end

local TestEZ = {
	run = run,

	Expectation = Expectation,
	TestBootstrap = TestBootstrap,
	TestEnum = TestEnum,
	TestPlan = TestPlan,
	TestPlanner = TestPlanner,
	TestResults = TestResults,
	TestRunner = TestRunner,
	TestSession = TestSession,

	Reporters = {
		TextReporter = TextReporter,
		TextReporterQuiet = TextReporterQuiet,
		TeamCityReporter = TeamCityReporter,
	},
}

return TestEZ</string>
              </Properties>
              <Item class="ModuleScript" referent="271">
                <Properties>
                  <string name="Name">Context</string>
                  <string name="Source"><![CDATA[--[[
	The Context object implements a write-once key-value store. It also allows
	for a new Context object to inherit the entries from an existing one.
]]
local Context = {}

function Context.new(parent)
	local meta = {}
	local index = {}
	meta.__index = index

	if parent then
		for key, value in pairs(getmetatable(parent).__index) do
			index[key] = value
		end
	end

	function meta.__newindex(_obj, key, value)
		assert(index[key] == nil, string.format("Cannot reassign %s in context", tostring(key)))
		index[key] = value
	end

	return setmetatable({}, meta)
end

return Context
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="272">
                <Properties>
                  <string name="Name">Expectation</string>
                  <string name="Source"><![CDATA[--[[
	Allows creation of expectation statements designed for behavior-driven
	testing (BDD). See Chai (JS) or RSpec (Ruby) for examples of other BDD
	frameworks.

	The Expectation class is exposed to tests as a function called `expect`:

		expect(5).to.equal(5)
		expect(foo()).to.be.ok()

	Expectations can be negated using .never:

		expect(true).never.to.equal(false)

	Expectations throw errors when their conditions are not met.
]]

local Expectation = {}

--[[
	These keys don't do anything except make expectations read more cleanly
]]
local SELF_KEYS = {
	to = true,
	be = true,
	been = true,
	have = true,
	was = true,
	at = true,
}

--[[
	These keys invert the condition expressed by the Expectation.
]]
local NEGATION_KEYS = {
	never = true,
}

--[[
	Extension of Lua's 'assert' that lets you specify an error level.
]]
local function assertLevel(condition, message, level)
	message = message or "Assertion failed!"
	level = level or 1

	if not condition then
		error(message, level + 1)
	end
end

--[[
	Returns a version of the given method that can be called with either . or :
]]
local function bindSelf(self, method)
	return function(firstArg, ...)
		if firstArg == self then
			return method(self, ...)
		else
			return method(self, firstArg, ...)
		end
	end
end

local function formatMessage(result, trueMessage, falseMessage)
	if result then
		return trueMessage
	else
		return falseMessage
	end
end

--[[
	Create a new expectation
]]
function Expectation.new(value)
	local self = {
		value = value,
		successCondition = true,
		condition = false,
		matchers = {},
		_boundMatchers = {},
	}

	setmetatable(self, Expectation)

	self.a = bindSelf(self, self.a)
	self.an = self.a
	self.ok = bindSelf(self, self.ok)
	self.equal = bindSelf(self, self.equal)
	self.throw = bindSelf(self, self.throw)
	self.near = bindSelf(self, self.near)

	return self
end

function Expectation.checkMatcherNameCollisions(name)
	if SELF_KEYS[name] or NEGATION_KEYS[name] or Expectation[name] then
		return false
	end

	return true
end

function Expectation:extend(matchers)
	self.matchers = matchers or {}

	for name, implementation in pairs(self.matchers) do
		self._boundMatchers[name] = bindSelf(self, function(_self, ...)
			local result = implementation(self.value, ...)
			local pass = result.pass == self.successCondition

			assertLevel(pass, result.message, 3)
			self:_resetModifiers()
			return self
		end)
	end

	return self
end

function Expectation.__index(self, key)
	-- Keys that don't do anything except improve readability
	if SELF_KEYS[key] then
		return self
	end

	-- Invert your assertion
	if NEGATION_KEYS[key] then
		local newExpectation = Expectation.new(self.value):extend(self.matchers)
		newExpectation.successCondition = not self.successCondition

		return newExpectation
	end

	if self._boundMatchers[key] then
		return self._boundMatchers[key]
	end

	-- Fall back to methods provided by Expectation
	return Expectation[key]
end

--[[
	Called by expectation terminators to reset modifiers in a statement.

	This makes chains like:

		expect(5)
			.never.to.equal(6)
			.to.equal(5)

	Work as expected.
]]
function Expectation:_resetModifiers()
	self.successCondition = true
end

--[[
	Assert that the expectation value is the given type.

	expect(5).to.be.a("number")
]]
function Expectation:a(typeName)
	local result = (typeof(self.value) == typeName) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		),
		("Expected value not of type %q, got value %q of type %s"):format(
			typeName,
			tostring(self.value),
			type(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

-- Make alias public on class
Expectation.an = Expectation.a

--[[
	Assert that our expectation value is not nil
]]
function Expectation:ok()
	local result = (self.value ~= nil) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q to be non-nil"):format(
			tostring(self.value)
		),
		("Expected value %q to be nil"):format(
			tostring(self.value)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value
]]
function Expectation:equal(otherValue)
	local result = (self.value == otherValue) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value %q (%s), got %q (%s) instead"):format(
			tostring(otherValue),
			type(otherValue),
			tostring(self.value),
			type(self.value)
		),
		("Expected anything but value %q (%s)"):format(
			tostring(otherValue),
			type(otherValue)
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our expectation value is equal to another value within some
	inclusive limit.
]]
function Expectation:near(otherValue, limit)
	assert(type(self.value) == "number", "Expectation value must be a number to use 'near'")
	assert(type(otherValue) == "number", "otherValue must be a number")
	assert(type(limit) == "number" or limit == nil, "limit must be a number or nil")

	limit = limit or 1e-7

	local result = (math.abs(self.value - otherValue) <= limit) == self.successCondition

	local message = formatMessage(self.successCondition,
		("Expected value to be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		),
		("Expected value to not be near %f (within %f) but got %f instead"):format(
			otherValue,
			limit,
			self.value
		)
	)

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

--[[
	Assert that our functoid expectation value throws an error when called.
	An optional error message can be passed to assert that the error message
	contains the given value.
]]
function Expectation:throw(messageSubstring)
	local ok, err = pcall(self.value)
	local result = ok ~= self.successCondition

	if messageSubstring and not ok then
		if self.successCondition then
			result = err:find(messageSubstring, 1, true) ~= nil
		else
			result = err:find(messageSubstring, 1, true) == nil
		end
	end

	local message

	if messageSubstring then
		message = formatMessage(self.successCondition,
			("Expected function to throw an error containing %q, but it %s"):format(
				messageSubstring,
				err and ("threw: %s"):format(err) or "did not throw."
			),
			("Expected function to never throw an error containing %q, but it threw: %s"):format(
				messageSubstring,
				tostring(err)
			)
		)
	else
		message = formatMessage(self.successCondition,
			"Expected function to throw an error, but it did not throw.",
			("Expected function to succeed, but it threw an error: %s"):format(
				tostring(err)
			)
		)
	end

	assertLevel(result, message, 3)
	self:_resetModifiers()

	return self
end

return Expectation
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="273">
                <Properties>
                  <string name="Name">ExpectationContext</string>
                  <string name="Source"><![CDATA[local Expectation = require(script.Parent.Expectation)
local checkMatcherNameCollisions = Expectation.checkMatcherNameCollisions

local function copy(t)
	local result = {}

	for key, value in pairs(t) do
		result[key] = value
	end

	return result
end

local ExpectationContext = {}
ExpectationContext.__index = ExpectationContext

function ExpectationContext.new(parent)
	local self = {
		_extensions = parent and copy(parent._extensions) or {},
	}

	return setmetatable(self, ExpectationContext)
end

function ExpectationContext:startExpectationChain(...)
	return Expectation.new(...):extend(self._extensions)
end

function ExpectationContext:extend(config)
	for key, value in pairs(config) do
		assert(self._extensions[key] == nil, string.format("Cannot reassign %q in expect.extend", key))
		assert(checkMatcherNameCollisions(key), string.format("Cannot overwrite matcher %q; it already exists", key))

		self._extensions[key] = value
	end
end

return ExpectationContext
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="274">
                <Properties>
                  <string name="Name">LifecycleHooks</string>
                  <string name="Source"><![CDATA[local TestEnum = require(script.Parent.TestEnum)

local LifecycleHooks = {}
LifecycleHooks.__index = LifecycleHooks

function LifecycleHooks.new()
	local self = {
		_stack = {},
	}
	return setmetatable(self, LifecycleHooks)
end

--[[
	Returns an array of `beforeEach` hooks in FIFO order
]]
function LifecycleHooks:getBeforeEachHooks()
	local key = TestEnum.NodeType.BeforeEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, hook)
		end
	end

	return hooks
end

--[[
	Returns an array of `afterEach` hooks in FILO order
]]
function LifecycleHooks:getAfterEachHooks()
	local key = TestEnum.NodeType.AfterEach
	local hooks = {}

	for _, level in ipairs(self._stack) do
		for _, hook in ipairs(level[key]) do
			table.insert(hooks, 1, hook)
		end
	end

	return hooks
end

--[[
	Pushes uncalled beforeAll and afterAll hooks back up the stack
]]
function LifecycleHooks:popHooks()
	table.remove(self._stack, #self._stack)
end

function LifecycleHooks:pushHooksFrom(planNode)
	assert(planNode ~= nil)

	table.insert(self._stack, {
		[TestEnum.NodeType.BeforeAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeAll),
		[TestEnum.NodeType.AfterAll] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterAll),
		[TestEnum.NodeType.BeforeEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.BeforeEach),
		[TestEnum.NodeType.AfterEach] = self:_getHooksOfType(planNode.children, TestEnum.NodeType.AfterEach),
	})
end

--[[
	Get the beforeAll hooks from the current level.
]]
function LifecycleHooks:getBeforeAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.BeforeAll]
end

--[[
	Get the afterAll hooks from the current level.
]]
function LifecycleHooks:getAfterAllHooks()
	return self._stack[#self._stack][TestEnum.NodeType.AfterAll]
end

function LifecycleHooks:_getHooksOfType(nodes, key)
	local hooks = {}

	for _, node in ipairs(nodes) do
		if node.type == key then
			table.insert(hooks, node.callback)
		end
	end

	return hooks
end

return LifecycleHooks
]]></string>
                </Properties>
              </Item>
              <Item class="Folder" referent="275">
                <Properties>
                  <string name="Name">Reporters</string>
                </Properties>
                <Item class="ModuleScript" referent="276">
                  <Properties>
                    <string name="Name">TeamCityReporter</string>
                    <string name="Source">local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local TeamCityReporter = {}

local function teamCityEscape(str)
	str = string.gsub(str, "([]|'[])","|%1")
	str = string.gsub(str, "\r", "|r")
	str = string.gsub(str, "\n", "|n")
	return str
end

local function teamCityEnterSuite(suiteName)
	return string.format("##teamcity[testSuiteStarted name='%s']", teamCityEscape(suiteName))
end

local function teamCityLeaveSuite(suiteName)
	return string.format("##teamcity[testSuiteFinished name='%s']", teamCityEscape(suiteName))
end

local function teamCityEnterCase(caseName)
	return string.format("##teamcity[testStarted name='%s']", teamCityEscape(caseName))
end

local function teamCityLeaveCase(caseName)
	return string.format("##teamcity[testFinished name='%s']", teamCityEscape(caseName))
end

local function teamCityFailCase(caseName, errorMessage)
	return string.format("##teamcity[testFailed name='%s' message='%s']",
		teamCityEscape(caseName), teamCityEscape(errorMessage))
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0
	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end
	if node.planNode.type == TestEnum.NodeType.Describe then
		table.insert(buffer, teamCityEnterSuite(node.planNode.phrase))
		for _, child in ipairs(node.children) do
			reportNode(child, buffer, level + 1)
		end
		table.insert(buffer, teamCityLeaveSuite(node.planNode.phrase))
	else
		table.insert(buffer, teamCityEnterCase(node.planNode.phrase))
		if node.status == TestEnum.TestStatus.Failure then
			table.insert(buffer, teamCityFailCase(node.planNode.phrase, table.concat(node.errors,"\n")))
		end
		table.insert(buffer, teamCityLeaveCase(node.planNode.phrase))
	end
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TeamCityReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TeamCityReporter</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="277">
                  <Properties>
                    <string name="Name">TextReporter</string>
                    <string name="Source">--[[
	The TextReporter uses the results from a completed test to output text to
	standard output and TestService.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporter = {}

local function compareNodes(a, b)
	return a.planNode.phrase:lower() &lt; b.planNode.phrase:lower()
end

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	else
		line = ("%s%s"):format(
			INDENT:rep(level),
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}
	table.sort(node.children, compareNodes)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporter.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporter</string>
                  </Properties>
                </Item>
                <Item class="ModuleScript" referent="278">
                  <Properties>
                    <string name="Name">TextReporterQuiet</string>
                    <string name="Source">--[[
	Copy of TextReporter that doesn't output successful tests.

	This should be temporary, it's just a workaround to make CI environments
	happy in the short-term.
]]

local TestService = game:GetService("TestService")

local TestEnum = require(script.Parent.Parent.TestEnum)

local INDENT = (" "):rep(3)
local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}
local UNKNOWN_STATUS_SYMBOL = "?"

local TextReporterQuiet = {}

local function reportNode(node, buffer, level)
	buffer = buffer or {}
	level = level or 0

	if node.status == TestEnum.TestStatus.Skipped then
		return buffer
	end

	local line

	if node.status ~= TestEnum.TestStatus.Success then
		local symbol = STATUS_SYMBOLS[node.status] or UNKNOWN_STATUS_SYMBOL

		line = ("%s[%s] %s"):format(
			INDENT:rep(level),
			symbol,
			node.planNode.phrase
		)
	end

	table.insert(buffer, line)

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, level + 1)
	end

	return buffer
end

local function reportRoot(node)
	local buffer = {}

	for _, child in ipairs(node.children) do
		reportNode(child, buffer, 0)
	end

	return buffer
end

local function report(root)
	local buffer = reportRoot(root)

	return table.concat(buffer, "\n")
end

function TextReporterQuiet.report(results)
	local resultBuffer = {
		"Test results:",
		report(results),
		("%d passed, %d failed, %d skipped"):format(
			results.successCount,
			results.failureCount,
			results.skippedCount
		)
	}

	print(table.concat(resultBuffer, "\n"))

	if results.failureCount > 0 then
		print(("%d test nodes reported failures."):format(results.failureCount))
	end

	if #results.errors > 0 then
		print("Errors reported by tests:")
		print("")

		for _, message in ipairs(results.errors) do
			TestService:Error(message)

			-- Insert a blank line after each error
			print("")
		end
	end
end

return TextReporterQuiet</string>
                  </Properties>
                </Item>
              </Item>
              <Item class="ModuleScript" referent="279">
                <Properties>
                  <string name="Name">TestBootstrap</string>
                  <string name="Source">--[[
	Provides an interface to quickly run and report tests from a given object.
]]

local TestPlanner = require(script.Parent.TestPlanner)
local TestRunner = require(script.Parent.TestRunner)
local TextReporter = require(script.Parent.Reporters.TextReporter)

local TestBootstrap = {}

local function stripSpecSuffix(name)
	return (name:gsub("%.spec$", ""))
end
local function isSpecScript(aScript)
	return aScript:IsA("ModuleScript") and aScript.Name:match("%.spec$")
end

local function getPath(module, root)
	root = root or game

	local path = {}
	local last = module

	if last.Name == "init.spec" then
		-- Use the directory's node for init.spec files.
		last = last.Parent
	end

	while last ~= nil and last ~= root do
		table.insert(path, stripSpecSuffix(last.Name))
		last = last.Parent
	end
	table.insert(path, stripSpecSuffix(root.Name))

	return path
end

local function toStringPath(tablePath)
	local stringPath = ""
	local first = true
	for _, element in ipairs(tablePath) do
		if first then
			stringPath = element
			first = false
		else
			stringPath = element .. " " .. stringPath
		end
	end
	return stringPath
end

function TestBootstrap:getModulesImpl(root, modules, current)
	modules = modules or {}
	current = current or root

	if isSpecScript(current) then
		local method = require(current)
		local path = getPath(current, root)
		local pathString = toStringPath(path)

		table.insert(modules, {
			method = method,
			path = path,
			pathStringForSorting = pathString:lower()
		})
	end
end

--[[
	Find all the ModuleScripts in this tree that are tests.
]]
function TestBootstrap:getModules(root)
	local modules = {}

	self:getModulesImpl(root, modules)

	for _, child in ipairs(root:GetDescendants()) do
		self:getModulesImpl(root, modules, child)
	end

	return modules
end

--[[
	Runs all test and reports the results using the given test reporter.

	If no reporter is specified, a reasonable default is provided.

	This function demonstrates the expected workflow with this testing system:
	1. Locate test modules
	2. Generate test plan
	3. Run test plan
	4. Report test results

	This means we could hypothetically present a GUI to the developer that shows
	the test plan before we execute it, allowing them to toggle specific tests
	before they're run, but after they've been identified!
]]
function TestBootstrap:run(roots, reporter, otherOptions)
	reporter = reporter or TextReporter

	otherOptions = otherOptions or {}
	local showTimingInfo = otherOptions["showTimingInfo"] or false
	local testNamePattern = otherOptions["testNamePattern"]
	local extraEnvironment = otherOptions["extraEnvironment"] or {}

	if type(roots) ~= "table" then
		error(("Bad argument #1 to TestBootstrap:run. Expected table, got %s"):format(typeof(roots)), 2)
	end

	local startTime = tick()

	local modules = {}
	for _, subRoot in ipairs(roots) do
		local newModules = self:getModules(subRoot)

		for _, newModule in ipairs(newModules) do
			table.insert(modules, newModule)
		end
	end

	local afterModules = tick()

	local plan = TestPlanner.createPlan(modules, testNamePattern, extraEnvironment)
	local afterPlan = tick()

	local results = TestRunner.runPlan(plan)
	local afterRun = tick()

	reporter.report(results)
	local afterReport = tick()

	if showTimingInfo then
		local timing = {
			("Took %f seconds to locate test modules"):format(afterModules - startTime),
			("Took %f seconds to create test plan"):format(afterPlan - afterModules),
			("Took %f seconds to run tests"):format(afterRun - afterPlan),
			("Took %f seconds to report tests"):format(afterReport - afterRun),
		}

		print(table.concat(timing, "\n"))
	end

	return results
end

return TestBootstrap</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="280">
                <Properties>
                  <string name="Name">TestEnum</string>
                  <string name="Source">--[[
	Constants used throughout the testing framework.
]]

local TestEnum = {}

TestEnum.TestStatus = {
	Success = "Success",
	Failure = "Failure",
	Skipped = "Skipped"
}

TestEnum.NodeType = {
	Describe = "Describe",
	It = "It",
	BeforeAll = "BeforeAll",
	AfterAll = "AfterAll",
	BeforeEach = "BeforeEach",
	AfterEach = "AfterEach"
}

TestEnum.NodeModifier = {
	None = "None",
	Skip = "Skip",
	Focus = "Focus"
}

return TestEnum</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="281">
                <Properties>
                  <string name="Name">TestPlan</string>
                  <string name="Source"><![CDATA[--[[
	Represents a tree of tests that have been loaded but not necessarily
	executed yet.

	TestPlan objects are produced by TestPlanner.
]]

local TestEnum = require(script.Parent.TestEnum)
local Expectation = require(script.Parent.Expectation)

local function newEnvironment(currentNode, extraEnvironment)
	local env = {}

	if extraEnvironment then
		if type(extraEnvironment) ~= "table" then
			error(("Bad argument #2 to newEnvironment. Expected table, got %s"):format(
				typeof(extraEnvironment)), 2)
		end

		for key, value in pairs(extraEnvironment) do
			env[key] = value
		end
	end

	local function addChild(phrase, callback, nodeType, nodeModifier)
		local node = currentNode:addChild(phrase, nodeType, nodeModifier)
		node.callback = callback
		if nodeType == TestEnum.NodeType.Describe then
			node:expand()
		end
		return node
	end

	function env.describeFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Focus)
	end

	function env.describeSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.Skip)
	end

	function env.describe(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.Describe, TestEnum.NodeModifier.None)
	end

	function env.itFOCUS(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Focus)
	end

	function env.itSKIP(phrase, callback)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
	end

	function env.itFIXME(phrase, callback)
		local node = addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.Skip)
		warn("FIXME: broken test", node:getFullName())
	end

	function env.it(phrase, callback, nodeModifier)
		addChild(phrase, callback, TestEnum.NodeType.It, TestEnum.NodeModifier.None)
	end

	-- Incrementing counter used to ensure that beforeAll, afterAll, beforeEach, afterEach have unique phrases
	local lifecyclePhaseId = 0

	local lifecycleHooks = {
		[TestEnum.NodeType.BeforeAll] = "beforeAll",
		[TestEnum.NodeType.AfterAll] = "afterAll",
		[TestEnum.NodeType.BeforeEach] = "beforeEach",
		[TestEnum.NodeType.AfterEach] = "afterEach"
	}

	for nodeType, name in pairs(lifecycleHooks) do
		env[name] = function(callback)
			addChild(name .. "_" .. tostring(lifecyclePhaseId), callback, nodeType, TestEnum.NodeModifier.None)
			lifecyclePhaseId = lifecyclePhaseId + 1
		end
	end

	function env.FIXME(optionalMessage)
		warn("FIXME: broken test", currentNode:getFullName(), optionalMessage or "")

		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	function env.FOCUS()
		currentNode.modifier = TestEnum.NodeModifier.Focus
	end

	function env.SKIP()
		currentNode.modifier = TestEnum.NodeModifier.Skip
	end

	--[[
		This function is deprecated. Calling it is a no-op beyond generating a
		warning.
	]]
	function env.HACK_NO_XPCALL()
		warn("HACK_NO_XPCALL is deprecated. It is now safe to yield in an " ..
			"xpcall, so this is no longer necessary. It can be safely deleted.")
	end

	env.fit = env.itFOCUS
	env.xit = env.itSKIP
	env.fdescribe = env.describeFOCUS
	env.xdescribe = env.describeSKIP

	env.expect = setmetatable({
		extend = function(...)
			error("Cannot call \"expect.extend\" from within a \"describe\" node.")
		end,
	}, {
		__call = function(_self, ...)
			return Expectation.new(...)
		end,
	})

	return env
end

local TestNode = {}
TestNode.__index = TestNode

--[[
	Create a new test node. A pointer to the test plan, a phrase to describe it
	and the type of node it is are required. The modifier is optional and will
	be None if left blank.
]]
function TestNode.new(plan, phrase, nodeType, nodeModifier)
	nodeModifier = nodeModifier or TestEnum.NodeModifier.None

	local node = {
		plan = plan,
		phrase = phrase,
		type = nodeType,
		modifier = nodeModifier,
		children = {},
		callback = nil,
		parent = nil,
	}

	node.environment = newEnvironment(node, plan.extraEnvironment)
	return setmetatable(node, TestNode)
end

local function getModifier(name, pattern, modifier)
	if pattern and (modifier == nil or modifier == TestEnum.NodeModifier.None) then
		if name:match(pattern) then
			return TestEnum.NodeModifier.Focus
		else
			return TestEnum.NodeModifier.Skip
		end
	end
	return modifier
end

function TestNode:addChild(phrase, nodeType, nodeModifier)
	if nodeType == TestEnum.NodeType.It then
		for _, child in pairs(self.children) do
			if child.phrase == phrase then
				error("Duplicate it block found: " .. child:getFullName())
			end
		end
	end

	local childName = self:getFullName() .. " " .. phrase
	nodeModifier = getModifier(childName, self.plan.testNamePattern, nodeModifier)
	local child = TestNode.new(self.plan, phrase, nodeType, nodeModifier)
	child.parent = self
	table.insert(self.children, child)
	return child
end

--[[
	Join the names of all the nodes back to the parent.
]]
function TestNode:getFullName()
	if self.parent then
		local parentPhrase = self.parent:getFullName()
		if parentPhrase then
			return parentPhrase .. " " .. self.phrase
		end
	end
	return self.phrase
end

--[[
	Expand a node by setting its callback environment and then calling it. Any
	further it and describe calls within the callback will be added to the tree.
]]
function TestNode:expand()
	local originalEnv = getfenv(self.callback)
	local callbackEnv = setmetatable({}, { __index = originalEnv })
	for key, value in pairs(self.environment) do
		callbackEnv[key] = value
	end
	-- Copy 'script' directly to new env to make Studio debugger happy.
	-- Studio debugger does not look into __index, because of security reasons
	callbackEnv.script = originalEnv.script
	setfenv(self.callback, callbackEnv)

	local success, result = xpcall(self.callback, function(message)
		return debug.traceback(tostring(message), 2)
	end)

	if not success then
		self.loadError = result
	end
end

local TestPlan = {}
TestPlan.__index = TestPlan

--[[
	Create a new, empty TestPlan.
]]
function TestPlan.new(testNamePattern, extraEnvironment)
	local plan = {
		children = {},
		testNamePattern = testNamePattern,
		extraEnvironment = extraEnvironment,
	}

	return setmetatable(plan, TestPlan)
end

--[[
	Add a new child under the test plan's root node.
]]
function TestPlan:addChild(phrase, nodeType, nodeModifier)
	nodeModifier = getModifier(phrase, self.testNamePattern, nodeModifier)
	local child = TestNode.new(self, phrase, nodeType, nodeModifier)
	table.insert(self.children, child)
	return child
end

--[[
	Add a new describe node with the given method as a callback. Generates or
	reuses all the describe nodes along the path.
]]
function TestPlan:addRoot(path, method)
	local curNode = self
	for i = #path, 1, -1 do
		local nextNode = nil

		for _, child in ipairs(curNode.children) do
			if child.phrase == path[i] then
				nextNode = child
				break
			end
		end

		if nextNode == nil then
			nextNode = curNode:addChild(path[i], TestEnum.NodeType.Describe)
		end

		curNode = nextNode
	end

	curNode.callback = method
	curNode:expand()
end

--[[
	Calls the given callback on all nodes in the tree, traversed depth-first.
]]
function TestPlan:visitAllNodes(callback, root, level)
	root = root or self
	level = level or 0

	for _, child in ipairs(root.children) do
		callback(child, level)

		self:visitAllNodes(callback, child, level + 1)
	end
end

--[[
	Visualizes the test plan in a simple format, suitable for debugging the test
	plan's structure.
]]
function TestPlan:visualize()
	local buffer = {}
	self:visitAllNodes(function(node, level)
		table.insert(buffer, (" "):rep(3 * level) .. node.phrase)
	end)
	return table.concat(buffer, "\n")
end

--[[
	Gets a list of all nodes in the tree for which the given callback returns
	true.
]]
function TestPlan:findNodes(callback)
	local results = {}
	self:visitAllNodes(function(node)
		if callback(node) then
			table.insert(results, node)
		end
	end)
	return results
end

return TestPlan
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="282">
                <Properties>
                  <string name="Name">TestPlanner</string>
                  <string name="Source">--[[
	Turns a series of specification functions into a test plan.

	Uses a TestPlanBuilder to keep track of the state of the tree being built.
]]
local TestPlan = require(script.Parent.TestPlan)

local TestPlanner = {}

--[[
	Create a new TestPlan from a list of specification functions.

	These functions should call a combination of `describe` and `it` (and their
	variants), which will be turned into a test plan to be executed.

	Parameters:
		- modulesList - list of tables describing test modules {
			method, -- specification function described above
			path, -- array of parent entires, first element is the leaf that owns `method`
			pathStringForSorting -- a string representation of `path`, used for sorting of the test plan
		}
		- testNamePattern - Only tests matching this Lua pattern string will run. Pass empty or nil to run all tests
		- extraEnvironment - Lua table holding additional functions and variables to be injected into the specification
							function during execution
]]
function TestPlanner.createPlan(modulesList, testNamePattern, extraEnvironment)
	local plan = TestPlan.new(testNamePattern, extraEnvironment)

	table.sort(modulesList, function(a, b)
		return a.pathStringForSorting &lt; b.pathStringForSorting
	end)

	for _, module in ipairs(modulesList) do
		plan:addRoot(module.path, module.method)
	end

	return plan
end

return TestPlanner</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="283">
                <Properties>
                  <string name="Name">TestResults</string>
                  <string name="Source">--[[
	Represents a tree of test results.

	Each node in the tree corresponds directly to a node in a corresponding
	TestPlan, accessible via the 'planNode' field.

	TestResults objects are produced by TestRunner using TestSession as state.
]]

local TestEnum = require(script.Parent.TestEnum)

local STATUS_SYMBOLS = {
	[TestEnum.TestStatus.Success] = "+",
	[TestEnum.TestStatus.Failure] = "-",
	[TestEnum.TestStatus.Skipped] = "~"
}

local TestResults = {}

TestResults.__index = TestResults

--[[
	Create a new TestResults tree that's linked to the given TestPlan.
]]
function TestResults.new(plan)
	local self = {
		successCount = 0,
		failureCount = 0,
		skippedCount = 0,
		planNode = plan,
		children = {},
		errors = {}
	}

	setmetatable(self, TestResults)

	return self
end

--[[
	Create a new result node that can be inserted into a TestResult tree.
]]
function TestResults.createNode(planNode)
	local node = {
		planNode = planNode,
		children = {},
		errors = {},
		status = nil
	}

	return node
end

--[[
	Visit all test result nodes, depth-first.
]]
function TestResults:visitAllNodes(callback, root)
	root = root or self

	for _, child in ipairs(root.children) do
		callback(child)

		self:visitAllNodes(callback, child)
	end
end

--[[
	Creates a debug visualization of the test results.
]]
function TestResults:visualize(root, level)
	root = root or self
	level = level or 0

	local buffer = {}

	for _, child in ipairs(root.children) do
		if child.planNode.type == TestEnum.NodeType.It then
			local symbol = STATUS_SYMBOLS[child.status] or "?"
			local str = ("%s[%s] %s"):format(
				(" "):rep(3 * level),
				symbol,
				child.planNode.phrase
			)

			if child.messages and #child.messages > 0 then
				str = str .. "\n " .. (" "):rep(3 * level) .. table.concat(child.messages, "\n " .. (" "):rep(3 * level))
			end

			table.insert(buffer, str)
		else
			local str = ("%s%s"):format(
				(" "):rep(3 * level),
				child.planNode.phrase or ""
			)

			if child.status then
				str = str .. (" (%s)"):format(child.status)
			end

			table.insert(buffer, str)

			if #child.children > 0 then
				local text = self:visualize(child, level + 1)
				table.insert(buffer, text)
			end
		end
	end

	return table.concat(buffer, "\n")
end

return TestResults</string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="284">
                <Properties>
                  <string name="Name">TestRunner</string>
                  <string name="Source"><![CDATA[--[[
	Contains the logic to run a test plan and gather test results from it.

	TestRunner accepts a TestPlan object, executes the planned tests, and
	produces a TestResults object. While the tests are running, the system's
	state is contained inside a TestSession object.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestSession = require(script.Parent.TestSession)
local LifecycleHooks = require(script.Parent.LifecycleHooks)

local RUNNING_GLOBAL = "__TESTEZ_RUNNING_TEST__"

local TestRunner = {
	environment = {}
}

local function wrapExpectContextWithPublicApi(expectationContext)
	return setmetatable({
		extend = function(...)
			expectationContext:extend(...)
		end,
	}, {
		__call = function(_self, ...)
			return expectationContext:startExpectationChain(...)
		end,
	})
end

--[[
	Runs the given TestPlan and returns a TestResults object representing the
	results of the run.
]]
function TestRunner.runPlan(plan)
	local session = TestSession.new(plan)
	local lifecycleHooks = LifecycleHooks.new()

	local exclusiveNodes = plan:findNodes(function(node)
		return node.modifier == TestEnum.NodeModifier.Focus
	end)

	session.hasFocusNodes = #exclusiveNodes > 0

	TestRunner.runPlanNode(session, plan, lifecycleHooks)

	return session:finalize()
end

--[[
	Run the given test plan node and its descendants, using the given test
	session to store all of the results.
]]
function TestRunner.runPlanNode(session, planNode, lifecycleHooks)
	local function runCallback(callback, messagePrefix)
		local success = true
		local errorMessage
		-- Any code can check RUNNING_GLOBAL to fork behavior based on
		-- whether a test is running. We use this to avoid accessing
		-- protected APIs; it's a workaround that will go away someday.
		_G[RUNNING_GLOBAL] = true

		messagePrefix = messagePrefix or ""

		local testEnvironment = getfenv(callback)

		for key, value in pairs(TestRunner.environment) do
			testEnvironment[key] = value
		end

		testEnvironment.fail = function(message)
			if message == nil then
				message = "fail() was called."
			end

			success = false
			errorMessage = messagePrefix .. debug.traceback(tostring(message), 2)
		end

		testEnvironment.expect = wrapExpectContextWithPublicApi(session:getExpectationContext())

		local context = session:getContext()

		local nodeSuccess, nodeResult = xpcall(
			function()
				callback(context)
			end,
			function(message)
				return messagePrefix .. debug.traceback(tostring(message), 2)
			end
		)

		-- If a node threw an error, we prefer to use that message over
		-- one created by fail() if it was set.
		if not nodeSuccess then
			success = false
			errorMessage = nodeResult
		end

		_G[RUNNING_GLOBAL] = nil

		return success, errorMessage
	end

	local function runNode(childPlanNode)
		-- Errors can be set either via `error` propagating upwards or
		-- by a test calling fail([message]).

		for _, hook in ipairs(lifecycleHooks:getBeforeEachHooks()) do
			local success, errorMessage = runCallback(hook, "beforeEach hook: ")
			if not success then
				return false, errorMessage
			end
		end

		local testSuccess, testErrorMessage = runCallback(childPlanNode.callback)

		for _, hook in ipairs(lifecycleHooks:getAfterEachHooks()) do
			local success, errorMessage = runCallback(hook, "afterEach hook: ")
			if not success then
				if not testSuccess then
					return false, testErrorMessage .. "\nWhile cleaning up the failed test another error was found:\n" .. errorMessage
				end
				return false, errorMessage
			end
		end

		if not testSuccess then
			return false, testErrorMessage
		end

		return true, nil
	end

	lifecycleHooks:pushHooksFrom(planNode)

	local halt = false
	for _, hook in ipairs(lifecycleHooks:getBeforeAllHooks()) do
		local success, errorMessage = runCallback(hook, "beforeAll hook: ")
		if not success then
			session:addDummyError("beforeAll", errorMessage)
			halt = true
		end
	end

	if not halt then
		for _, childPlanNode in ipairs(planNode.children) do
			if childPlanNode.type == TestEnum.NodeType.It then
				session:pushNode(childPlanNode)
				if session:shouldSkip() then
					session:setSkipped()
				else
					local success, errorMessage = runNode(childPlanNode)

					if success then
						session:setSuccess()
					else
						session:setError(errorMessage)
					end
				end
				session:popNode()
			elseif childPlanNode.type == TestEnum.NodeType.Describe then
				session:pushNode(childPlanNode)
				TestRunner.runPlanNode(session, childPlanNode, lifecycleHooks)

				-- Did we have an error trying build a test plan?
				if childPlanNode.loadError then
					local message = "Error during planning: " .. childPlanNode.loadError
					session:setError(message)
				else
					session:setStatusFromChildren()
				end
				session:popNode()
			end
		end
	end

	for _, hook in ipairs(lifecycleHooks:getAfterAllHooks()) do
		local success, errorMessage = runCallback(hook, "afterAll hook: ")
		if not success then
			session:addDummyError("afterAll", errorMessage)
		end
	end

	lifecycleHooks:popHooks()
end

return TestRunner
]]></string>
                </Properties>
              </Item>
              <Item class="ModuleScript" referent="285">
                <Properties>
                  <string name="Name">TestSession</string>
                  <string name="Source"><![CDATA[--[[
	Represents the state relevant while executing a test plan.

	Used by TestRunner to produce a TestResults object.

	Uses the same tree building structure as TestPlanBuilder; TestSession keeps
	track of a stack of nodes that represent the current path through the tree.
]]

local TestEnum = require(script.Parent.TestEnum)
local TestResults = require(script.Parent.TestResults)
local Context = require(script.Parent.Context)
local ExpectationContext = require(script.Parent.ExpectationContext)

local TestSession = {}

TestSession.__index = TestSession

--[[
	Create a TestSession related to the given TestPlan.

	The resulting TestResults object will be linked to this TestPlan.
]]
function TestSession.new(plan)
	local self = {
		results = TestResults.new(plan),
		nodeStack = {},
		contextStack = {},
		expectationContextStack = {},
		hasFocusNodes = false
	}

	setmetatable(self, TestSession)

	return self
end

--[[
	Calculate success, failure, and skipped test counts in the tree at the
	current point in the execution.
]]
function TestSession:calculateTotals()
	local results = self.results

	results.successCount = 0
	results.failureCount = 0
	results.skippedCount = 0

	results:visitAllNodes(function(node)
		local status = node.status
		local nodeType = node.planNode.type

		if nodeType == TestEnum.NodeType.It then
			if status == TestEnum.TestStatus.Success then
				results.successCount = results.successCount + 1
			elseif status == TestEnum.TestStatus.Failure then
				results.failureCount = results.failureCount + 1
			elseif status == TestEnum.TestStatus.Skipped then
				results.skippedCount = results.skippedCount + 1
			end
		end
	end)
end

--[[
	Gathers all of the errors reported by tests and puts them at the top level
	of the TestResults object.
]]
function TestSession:gatherErrors()
	local results = self.results

	results.errors = {}

	results:visitAllNodes(function(node)
		if #node.errors > 0 then
			for _, message in ipairs(node.errors) do
				table.insert(results.errors, message)
			end
		end
	end)
end

--[[
	Calculates test totals, verifies the tree is valid, and returns results.
]]
function TestSession:finalize()
	if #self.nodeStack ~= 0 then
		error("Cannot finalize TestResults with nodes still on the stack!", 2)
	end

	self:calculateTotals()
	self:gatherErrors()

	return self.results
end

--[[
	Create a new test result node and push it onto the navigation stack.
]]
function TestSession:pushNode(planNode)
	local node = TestResults.createNode(planNode)
	local lastNode = self.nodeStack[#self.nodeStack] or self.results
	table.insert(lastNode.children, node)
	table.insert(self.nodeStack, node)

	local lastContext = self.contextStack[#self.contextStack]
	local context = Context.new(lastContext)
	table.insert(self.contextStack, context)

	local lastExpectationContext = self.expectationContextStack[#self.expectationContextStack]
	local expectationContext = ExpectationContext.new(lastExpectationContext)
	table.insert(self.expectationContextStack, expectationContext)
end

--[[
	Pops a node off of the navigation stack.
]]
function TestSession:popNode()
	assert(#self.nodeStack > 0, "Tried to pop from an empty node stack!")
	table.remove(self.nodeStack, #self.nodeStack)
	table.remove(self.contextStack, #self.contextStack)
	table.remove(self.expectationContextStack, #self.expectationContextStack)
end

--[[
	Gets the Context object for the current node.
]]
function TestSession:getContext()
	assert(#self.contextStack > 0, "Tried to get context from an empty stack!")
	return self.contextStack[#self.contextStack]
end


function TestSession:getExpectationContext()
	assert(#self.expectationContextStack > 0, "Tried to get expectationContext from an empty stack!")
	return self.expectationContextStack[#self.expectationContextStack]
end

--[[
	Tells whether the current test we're in should be skipped.
]]
function TestSession:shouldSkip()
	-- If our test tree had any exclusive tests, then normal tests are skipped!
	if self.hasFocusNodes then
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			-- Skipped tests are still skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end

			-- Focused tests are the only ones that aren't skipped
			if node.planNode.modifier == TestEnum.NodeModifier.Focus then
				return false
			end
		end

		return true
	else
		for i = #self.nodeStack, 1, -1 do
			local node = self.nodeStack[i]

			if node.planNode.modifier == TestEnum.NodeModifier.Skip then
				return true
			end
		end
	end

	return false
end

--[[
	Set the current node's status to Success.
]]
function TestSession:setSuccess()
	assert(#self.nodeStack > 0, "Attempting to set success status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Success
end

--[[
	Set the current node's status to Skipped.
]]
function TestSession:setSkipped()
	assert(#self.nodeStack > 0, "Attempting to set skipped status on empty stack")
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Skipped
end

--[[
	Set the current node's status to Failure and adds a message to its list of
	errors.
]]
function TestSession:setError(message)
	assert(#self.nodeStack > 0, "Attempting to set error status on empty stack")
	local last = self.nodeStack[#self.nodeStack]
	last.status = TestEnum.TestStatus.Failure
	table.insert(last.errors, message)
end

--[[
	Add a dummy child node to the current node to hold the given error. This
	allows an otherwise empty describe node to report an error in a more natural
	way.
]]
function TestSession:addDummyError(phrase, message)
	self:pushNode({type = TestEnum.NodeType.It, phrase = phrase})
	self:setError(message)
	self:popNode()
	self.nodeStack[#self.nodeStack].status = TestEnum.TestStatus.Failure
end

--[[
	Set the current node's status based on that of its children. If all children
	are skipped, mark it as skipped. If any are fails, mark it as failed.
	Otherwise, mark it as success.
]]
function TestSession:setStatusFromChildren()
	assert(#self.nodeStack > 0, "Attempting to set status from children on empty stack")

	local last = self.nodeStack[#self.nodeStack]
	local status = TestEnum.TestStatus.Success
	local skipped = true

	-- If all children were skipped, then we were skipped
	-- If any child failed, then we failed!
	for _, child in ipairs(last.children) do
		if child.status ~= TestEnum.TestStatus.Skipped then
			skipped = false

			if child.status == TestEnum.TestStatus.Failure then
				status = TestEnum.TestStatus.Failure
			end
		end
	end

	if skipped then
		status = TestEnum.TestStatus.Skipped
	end

	last.status = status
end

return TestSession
]]></string>
                </Properties>
              </Item>
            </Item>
          </Item>
          <Item class="Folder" referent="286">
            <Properties>
              <string name="Name">types</string>
            </Properties>
            <Item class="Folder" referent="287">
              <Properties>
                <string name="Name">include</string>
              </Properties>
              <Item class="Folder" referent="288">
                <Properties>
                  <string name="Name">generated</string>
                </Properties>
              </Item>
            </Item>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
  <Item class="ServerScriptService" referent="289">
    <Properties>
      <string name="Name">ServerScriptService</string>
    </Properties>
    <Item class="Folder" referent="290">
      <Properties>
        <string name="Name">diagnostics</string>
      </Properties>
    </Item>
    <Item class="Folder" referent="291">
      <Properties>
        <string name="Name">helpers</string>
      </Properties>
      <Item class="Folder" referent="292">
        <Properties>
          <string name="Name">util</string>
        </Properties>
        <Item class="ModuleScript" referent="293">
          <Properties>
            <string name="Name">ClassWithInstanceFoo</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local ClassWithInstanceFoo
do
	ClassWithInstanceFoo = setmetatable({}, {
		__tostring = function()
			return "ClassWithInstanceFoo"
		end,
	})
	ClassWithInstanceFoo.__index = ClassWithInstanceFoo
	function ClassWithInstanceFoo.new(...)
		local self = setmetatable({}, ClassWithInstanceFoo)
		return self:constructor(...) or self
	end
	function ClassWithInstanceFoo:constructor()
	end
	function ClassWithInstanceFoo:foo()
	end
end
return {
	ClassWithInstanceFoo = ClassWithInstanceFoo,
}
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="294">
          <Properties>
            <string name="Name">ClassWithStaticFoo</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local ClassWithStaticFoo
do
	ClassWithStaticFoo = setmetatable({}, {
		__tostring = function()
			return "ClassWithStaticFoo"
		end,
	})
	ClassWithStaticFoo.__index = ClassWithStaticFoo
	function ClassWithStaticFoo.new(...)
		local self = setmetatable({}, ClassWithStaticFoo)
		return self:constructor(...) or self
	end
	function ClassWithStaticFoo:constructor()
	end
	function ClassWithStaticFoo:foo()
	end
end
return {
	ClassWithStaticFoo = ClassWithStaticFoo,
}
]]></string>
          </Properties>
        </Item>
        <Item class="Script" referent="295">
          <Properties>
            <string name="Name">nonModule</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local x = 1
return {
	x = x,
}
]]></string>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="Script" referent="296">
      <Properties>
        <string name="Name">main</string>
        <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/testez/globals" />
local ServerScriptService = TS.import(script, game:GetService("ReplicatedStorage"), "include", "node_modules", "@rbxts", "services").ServerScriptService
local TestEZ = TS.import(script, game:GetService("ReplicatedStorage"), "include", "node_modules", "@rbxts", "testez", "src")
local results = TestEZ.TestBootstrap:run({ ServerScriptService.tests })
if #results.errors > 0 or results.failureCount > 0 then
	error("Tests failed!")
end
]]></string>
      </Properties>
    </Item>
    <Item class="Folder" referent="297">
      <Properties>
        <string name="Name">tests</string>
      </Properties>
      <Item class="ModuleScript" referent="298">
        <Properties>
          <string name="Name">array.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
return function()
	it("should support optional chain call on array index", function()
		local v = {
			onEnd = { function()
				assert(false, "first member should not be called")
			end, function(arg)
				local _arg0 = arg == "foo"
				assert(_arg0)
			end },
		}
		local n = 1
		local _result = v.onEnd[n + 1]
		if _result ~= nil then
			_result("foo")
		end
		v.onEnd[n + 1]("foo")
	end)
	it("should support optional chain method call on array index", function()
		local v = {
			onEnd = { function(self)
				assert(false, "first member should not be called")
			end, function(self, arg)
				local _arg0 = arg == "foo"
				assert(_arg0)
			end },
		}
		local n = 1
		local _self = v.onEnd
		local _result = _self[n + 1]
		if _result ~= nil then
			_result(_self, "foo")
		end
		local _fn = v.onEnd
		_fn[n + 1](_fn, "foo")
	end)
	it("should support element access", function()
		local arr = { 1, 2, 3 }
		expect(arr[1]).to.equal(1)
		expect(arr[2]).to.equal(2)
		expect(arr[3]).to.equal(3)
		expect(({ 1, 2, 3 })[1]).to.equal(1)
		expect(({ 1, 2, 3 })[2]).to.equal(2)
		expect(({ 1, 2, 3 })[3]).to.equal(3)
		local function foo()
			local result = { 1, 2, 3 }
			return result
		end
		expect(foo()[1]).to.equal(1)
		expect(foo()[2]).to.equal(2)
		expect(foo()[3]).to.equal(3)
		local i = 2
		local a = arr[i + 1]
		local b = arr[3]
		local _binding = arr
		local c = _binding[i + 1]
		local _binding_1 = arr
		local d = _binding_1[3]
		expect(a).to.equal(3)
		expect(b).to.equal(3)
		expect(c).to.equal(3)
		expect(d).to.equal(3)
		a = arr[i + 1]
		b = arr[3]
		local _binding_2 = arr
		c = _binding_2[i + 1]
		local _binding_3 = arr
		d = _binding_3[3]
		expect(a).to.equal(3)
		expect(b).to.equal(3)
		expect(c).to.equal(3)
		expect(d).to.equal(3)
		local function f(v)
			local a = {}
			a[v + 1] = 3
		end
		local Foo
		do
			local _inverse = {}
			Foo = setmetatable({}, {
				__index = _inverse,
			})
			Foo.A = 0
			_inverse[0] = "A"
			Foo.B = 1
			_inverse[1] = "B"
			Foo.C = 2
			_inverse[2] = "C"
		end
		local function g(v)
			local a = {}
			a[v + 1] = 3
		end
	end)
	it("should support.size()", function()
		expect(#({})).to.equal(0)
		expect(#({ 1 })).to.equal(1)
		expect(#({ 1, 2 })).to.equal(2)
		expect(#({ 1, 2, 3 })).to.equal(3)
	end)
	it("should support push", function()
		local a = {}
		table.insert(a, 123)
		expect(a[1]).to.equal(123)
		local Noodle
		do
			Noodle = setmetatable({}, {
				__tostring = function()
					return "Noodle"
				end,
			})
			Noodle.__index = Noodle
			function Noodle.new(...)
				local self = setmetatable({}, Noodle)
				return self:constructor(...) or self
			end
			function Noodle:constructor()
				self.strings = {}
			end
		end
		local noodle = Noodle.new()
		table.insert(noodle.strings, "Rigatoni")
		local strings = noodle.strings
		table.insert(strings, "Spaghetti")
		table.insert(strings, "Lasagna")
		local _value = #strings
		if _value ~= 0 and (_value == _value and _value) then
		end
		table.insert(noodle.strings, "Penne")
		expect(#noodle.strings).to.equal(4)
		expect(noodle.strings[1]).to.equal("Rigatoni")
		expect(noodle.strings[2]).to.equal("Spaghetti")
		expect(noodle.strings[3]).to.equal("Lasagna")
		expect(noodle.strings[4]).to.equal("Penne")
		local arr = { 0 }
		local _arr = arr
		local _arg2 = arr[2]
		-- ▼ Array.push ▼
		table.insert(_arr, 1)
		table.insert(_arr, 2)
		table.insert(_arr, _arg2)
		-- ▲ Array.push ▲
		expect(arr[1]).to.equal(0)
		expect(arr[2]).to.equal(1)
		expect(arr[3]).to.equal(2)
		expect(arr[4]).to.equal(nil)
		expect(#({ 1, 2 })).to.equal(2)
	end)
	it("should support pop", function()
		local a = { 456 }
		-- ▼ Array.pop ▼
		local _length = #a
		local _result = a[_length]
		a[_length] = nil
		-- ▲ Array.pop ▲
		local b = _result
		expect(b).to.equal(456)
		expect(#a).to.equal(0)
		expect(a[1]).never.to.be.ok()
	end)
	it("should support join", function()
		local a = { 1, 2, 3 }
		local b = { true, false, true }
		expect(table.concat(a, ", ")).to.equal("1, 2, 3")
		expect(table.concat({ 1, 2, 3 }, ", ")).to.equal("1, 2, 3")
		-- ▼ ReadonlyArray.join ▼
		local _result = table.create(#b)
		for _k, _v in b do
			_result[_k] = tostring(_v)
		end
		-- ▲ ReadonlyArray.join ▲
		expect(table.concat(_result, ", ")).to.equal("true, false, true")
		local _exp = { true, false, true }
		-- ▼ ReadonlyArray.join ▼
		local _result_1 = table.create(#_exp)
		for _k, _v in _exp do
			_result_1[_k] = tostring(_v)
		end
		-- ▲ ReadonlyArray.join ▲
		expect(table.concat(_result_1, ", ")).to.equal("true, false, true")
		local _exp_1 = { 1, "a", true }
		-- ▼ ReadonlyArray.join ▼
		local _result_2 = table.create(#_exp_1)
		for _k, _v in _exp_1 do
			_result_2[_k] = tostring(_v)
		end
		-- ▲ ReadonlyArray.join ▲
		expect(table.concat(_result_2, ", ")).to.equal("1, a, true")
	end)
	it("should support move", function()
		local a = { 1, 2, 3 }
		local b = { 0 }
		table.move(a, 2, 3, 1)
		expect(table.concat(a, ", ")).to.equal("2, 3, 3")
		local _b = b
		table.move(a, 1, 3, 2, _b)
		expect(table.concat(b, ", ")).to.equal("0, 2, 3, 3")
		table.move(b, 1, 2, 3)
		expect(table.concat(b, ", ")).to.equal("0, 2, 0, 2")
	end)
	it("should support shift", function()
		local a = { 1, 2, 3 }
		local b = table.remove(a, 1)
		expect(b).to.equal(1)
		expect(#a).to.equal(2)
		expect(a[1]).to.equal(2)
		expect(a[2]).to.equal(3)
	end)
	it("should support sort", function()
		local x = { 4, 2, 6, 2, 1 }
		table.sort(x)
		expect(x[1]).to.equal(1)
		expect(x[2]).to.equal(2)
		expect(x[3]).to.equal(2)
		expect(x[4]).to.equal(4)
		expect(x[5]).to.equal(6)
		local _arg0 = function(a, b)
			return a < b
		end
		table.sort(x, _arg0)
		expect(x).to.equal(x)
		expect(x[1]).to.equal(1)
		expect(x[2]).to.equal(2)
		expect(x[3]).to.equal(2)
		expect(x[4]).to.equal(4)
		expect(x[5]).to.equal(6)
		local _arg0_1 = function(a, b)
			return a > b
		end
		table.sort(x, _arg0_1)
		expect(x).to.equal(x)
		expect(x[1]).to.equal(6)
		expect(x[2]).to.equal(4)
		expect(x[3]).to.equal(2)
		expect(x[4]).to.equal(2)
		expect(x[5]).to.equal(1)
	end)
	it("should support unshift", function()
		local a = { 1, 2, 3 }
		table.insert(a, 1, 4)
		local b = #a
		table.insert(a, 1, 5)
		expect(a[1]).to.equal(5)
		expect(a[2]).to.equal(4)
		expect(a[3]).to.equal(1)
		expect(a[4]).to.equal(2)
		expect(a[5]).to.equal(3)
		expect(b).to.equal(4)
	end)
	it("should support indexOf", function()
		local a = { 7, 1, 8, 1, 9 }
		expect((table.find(a, 1) or 0) - 1).to.equal(1)
		expect((table.find(a, 2) or 0) - 1).to.equal(-1)
	end)
	it("should support every", function()
		local function even(value)
			return value % 2 == 0
		end
		local function odd(value)
			return not even(value)
		end
		local a = { 1, 2, 3, 4, 5, 6 }
		-- ▼ ReadonlyArray.every ▼
		local _result = true
		for _k, _v in a do
			if not even(_v, _k - 1, a) then
				_result = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result).to.equal(false)
		-- ▼ ReadonlyArray.every ▼
		local _result_1 = true
		for _k, _v in a do
			if not odd(_v, _k - 1, a) then
				_result_1 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_1).to.equal(false)
		local b = { 1, 3, 5 }
		-- ▼ ReadonlyArray.every ▼
		local _result_2 = true
		for _k, _v in b do
			if not even(_v, _k - 1, b) then
				_result_2 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_2).to.equal(false)
		-- ▼ ReadonlyArray.every ▼
		local _result_3 = true
		for _k, _v in b do
			if not odd(_v, _k - 1, b) then
				_result_3 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_3).to.equal(true)
		local c = { 2, 4, 6 }
		-- ▼ ReadonlyArray.every ▼
		local _result_4 = true
		for _k, _v in c do
			if not even(_v, _k - 1, c) then
				_result_4 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_4).to.equal(true)
		-- ▼ ReadonlyArray.every ▼
		local _result_5 = true
		for _k, _v in c do
			if not odd(_v, _k - 1, c) then
				_result_5 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_5).to.equal(false)
	end)
	it("should support some", function()
		local a = { 1, 2, 3 }
		local _arg0 = function(v)
			return v == 2
		end
		-- ▼ ReadonlyArray.some ▼
		local _result = false
		for _k, _v in a do
			if _arg0(_v, _k - 1, a) then
				_result = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		expect(_result).to.equal(true)
		local _arg0_1 = function(v)
			return v == 4
		end
		-- ▼ ReadonlyArray.some ▼
		local _result_1 = false
		for _k, _v in a do
			if _arg0_1(_v, _k - 1, a) then
				_result_1 = true
				break
			end
		end
		-- ▲ ReadonlyArray.some ▲
		expect(_result_1).to.equal(false)
	end)
	it("should support forEach", function()
		local bin = { 1, 2, 3 }
		local str = ""
		local _arg0 = function(v)
			str ..= tostring(v)
			return str
		end
		for _k, _v in bin do
			_arg0(_v, _k - 1, bin)
		end
		expect(str).to.equal("123")
	end)
	it("should support map", function()
		local a = { 1, 2, 3 }
		local _arg0 = function(v)
			return v + 1
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#a)
		for _k, _v in a do
			_newValue[_k] = _arg0(_v, _k - 1, a)
		end
		-- ▲ ReadonlyArray.map ▲
		local b = _newValue
		expect(b).never.to.equal(a)
		expect(b[1]).to.equal(2)
		expect(b[2]).to.equal(3)
		expect(b[3]).to.equal(4)
	end)
	it("should support filter", function()
		local a = { 1, 2, 3, 4, 5 }
		local _arg0 = function(v)
			return v % 2 == 0
		end
		-- ▼ ReadonlyArray.filter ▼
		local _newValue = {}
		local _length = 0
		for _k, _v in a do
			if _arg0(_v, _k - 1, a) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		-- ▲ ReadonlyArray.filter ▲
		local b = _newValue
		expect(b).never.to.equal(a)
		expect(#b).to.equal(2)
		expect(b[1]).to.equal(2)
		expect(b[2]).to.equal(4)
	end)
	it("should support reduce", function()
		local function reducer(accum, value)
			local _array = {}
			local _length = #_array
			local _accumLength = #accum
			table.move(accum, 1, _accumLength, _length + 1, _array)
			_length += _accumLength
			table.move(value, 1, #value, _length + 1, _array)
			return _array
		end
		local _exp = { { 0, 1 }, { 2, 3 }, { 4, 5 } }
		-- ▼ ReadonlyArray.reduce ▼
		if #_exp == 0 then
			error("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.")
		end
		local _result = _exp[1]
		local _callback = reducer
		for _i = 2, #_exp do
			_result = _callback(_result, _exp[_i], _i - 1, _exp)
		end
		-- ▲ ReadonlyArray.reduce ▲
		local a = _result
		expect(a[1]).to.equal(0)
		expect(a[2]).to.equal(1)
		expect(a[3]).to.equal(2)
		expect(a[4]).to.equal(3)
		expect(a[5]).to.equal(4)
		expect(a[6]).to.equal(5)
	end)
	it("should support reducing empty arrays only with a initialValue parameter", function()
		expect(function()
			local _arg0 = function(previous, current, index, arr)
				return previous .. current
			end
			local _exp = {}
			-- ▼ ReadonlyArray.reduce ▼
			if #_exp == 0 then
				error("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.")
			end
			local _result = _exp[1]
			local _callback = _arg0
			for _i = 2, #_exp do
				_result = _callback(_result, _exp[_i], _i - 1, _exp)
			end
			-- ▲ ReadonlyArray.reduce ▲
			return _result
		end).to:throw()
		local _arg0 = function(previous, current, index, arr)
			error("This should never run! [1]")
		end
		local _exp = {}
		-- ▼ ReadonlyArray.reduce ▼
		local _result = "a"
		local _callback = _arg0
		for _i = 1, #_exp do
			_result = _callback(_result, _exp[_i], _i - 1, _exp)
		end
		-- ▲ ReadonlyArray.reduce ▲
		expect(_result).to.equal("a")
	end)
	it("should support reducing arrays with an undefined initialValue", function()
		local _array = {}
		local _length = #_array
		for _char in string.gmatch("😂😄😃😊😉😍", utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		local _arg0 = function(previous, current, index, arr)
			local _exp = index
			local _condition = previous
			if not (_condition ~= 0 and (_condition == _condition and _condition)) then
				_condition = index
			end
			return _exp + _condition
		end
		-- ▼ ReadonlyArray.reduce ▼
		local _result = nil
		local _callback = _arg0
		for _i = 1, #_array do
			_result = _callback(_result, _array[_i], _i - 1, _array)
		end
		-- ▲ ReadonlyArray.reduce ▲
		expect(_result).to.equal(16)
		local _arg0_1 = function()
			error("Should not call the reducer function on an empty array! [1]")
		end
		local _exp = {}
		-- ▼ ReadonlyArray.reduce ▼
		local _result_1 = nil
		local _callback_1 = _arg0_1
		for _i = 1, #_exp do
			_result_1 = _callback_1(_result_1, _exp[_i], _i - 1, _exp)
		end
		-- ▲ ReadonlyArray.reduce ▲
		expect(_result_1).to.equal(nil)
	end)
	it("should support reducing single-element arrays without calling a reducer when no initialValue is passed in", function()
		local _arg0 = function()
			error("Should not call the reducer function on a single-element array with no initialValue! [1]")
		end
		local _exp = { 4 }
		-- ▼ ReadonlyArray.reduce ▼
		if #_exp == 0 then
			error("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.")
		end
		local _result = _exp[1]
		local _callback = _arg0
		for _i = 2, #_exp do
			_result = _callback(_result, _exp[_i], _i - 1, _exp)
		end
		-- ▲ ReadonlyArray.reduce ▲
		expect(_result).to.equal(4)
	end)
	it("should support reducing forwards or backwards", function()
		local _array = {}
		local _length = #_array
		for _char in string.gmatch("abcdef", utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		local _arg0 = function(previous, current)
			return previous .. current
		end
		-- ▼ ReadonlyArray.reduce ▼
		if #_array == 0 then
			error("Attempted to call `ReadonlyArray.reduce()` on an empty array without an initialValue.")
		end
		local _result = _array[1]
		local _callback = _arg0
		for _i = 2, #_array do
			_result = _callback(_result, _array[_i], _i - 1, _array)
		end
		-- ▲ ReadonlyArray.reduce ▲
		expect(_result).to.equal("abcdef")
		local _array_1 = {}
		local _length_1 = #_array_1
		for _char in string.gmatch("abcdef", utf8.charpattern) do
			_length_1 += 1
			_array_1[_length_1] = _char
		end
		local _arg0_1 = function(previous, current)
			return previous .. current
		end
		-- ▼ ReadonlyArray.reduce ▼
		local _result_1 = " "
		local _callback_1 = _arg0_1
		for _i = 1, #_array_1 do
			_result_1 = _callback_1(_result_1, _array_1[_i], _i - 1, _array_1)
		end
		-- ▲ ReadonlyArray.reduce ▲
		expect(_result_1).to.equal(" " .. "abcdef")
	end)
	it("should support Array.find", function()
		local a = { 1, 2, 3, 4, 5 }
		local _arg0 = function(v)
			return v % 2 == 0
		end
		-- ▼ ReadonlyArray.find ▼
		local _result
		for _i, _v in a do
			if _arg0(_v, _i - 1, a) == true then
				_result = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		local b = _result
		expect(b).to.equal(2)
		local _arg0_1 = function(v)
			return v == 6
		end
		-- ▼ ReadonlyArray.find ▼
		local _result_1
		for _i, _v in a do
			if _arg0_1(_v, _i - 1, a) == true then
				_result_1 = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		local c = _result_1
		expect(c).never.to.be.ok()
		local _arg0_2 = function(v)
			return v % 2 ~= 0
		end
		-- ▼ ReadonlyArray.find ▼
		local _result_2
		for _i, _v in a do
			if _arg0_2(_v, _i - 1, a) == true then
				_result_2 = _v
				break
			end
		end
		-- ▲ ReadonlyArray.find ▲
		local d = _result_2
		expect(d).to.equal(1)
	end)
	it("should allow spread 1", function()
		local a = { 1, 2, 3 }
		local _array = {}
		local _length = #_array
		local _aLength = #a
		table.move(a, 1, _aLength, _length + 1, _array)
		_length += _aLength
		_array[_length + 1] = 4
		_array[_length + 2] = 5
		_array[_length + 3] = 6
		local b = _array
		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(2)
		expect(b[3]).to.equal(3)
		expect(b[4]).to.equal(4)
		expect(b[5]).to.equal(5)
		expect(b[6]).to.equal(6)
		expect(#b).to.equal(6)
	end)
	it("should allow spread 2", function()
		local _array = {}
		local _length = #_array
		local _array_1 = { 1 }
		local _Length = #_array_1
		table.move(_array_1, 1, _Length, _length + 1, _array)
		_length += _Length
		local _array_2 = { 2 }
		table.move(_array_2, 1, #_array_2, _length + 1, _array)
		local c = _array
		expect(c[1]).to.equal(1)
		expect(c[2]).to.equal(2)
	end)
	it("should allow spread 3", function()
		local oldArr = { 2 }
		local counter = 0
		local _array = {}
		local _length = #_array
		counter += 1
		_array[_length + 1] = counter
		table.move(oldArr, 1, #oldArr, _length + 2, _array)
		local newArr = _array
		expect(newArr[1]).to.equal(1)
		expect(newArr[2]).to.equal(2)
	end)
	it("should allow spread 4", function()
		local counter = 0
		local _array = {}
		local _length = #_array
		counter += 1
		_array[_length + 1] = counter
		_length += 1
		for _char in string.gmatch("abc", utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		local newArr = _array
		expect(newArr[1]).to.equal(1)
		expect(newArr[2]).to.equal("a")
		expect(newArr[3]).to.equal("b")
		expect(newArr[4]).to.equal("c")
	end)
	it("should allow spread 5", function()
		local counter = 0
		local _array = {}
		local _length = #_array
		counter += 1
		_array[_length + 1] = counter
		_length += 1
		for _v in {
			[2] = true,
		} do
			_length += 1
			_array[_length] = _v
		end
		local newArr = _array
		expect(newArr[1]).to.equal(1)
		expect(newArr[2]).to.equal(2)
	end)
	it("should allow spread 6", function()
		local counter = 0
		local _array = {}
		local _length = #_array
		counter += 1
		_array[_length + 1] = { "a", counter }
		_length += 1
		for _k, _v in {
			b = 2,
		} do
			_length += 1
			_array[_length] = { _k, _v }
		end
		local newArr = _array
		expect(newArr[1][1]).to.equal("a")
		expect(newArr[1][2]).to.equal(1)
		expect(newArr[2][1]).to.equal("b")
		expect(newArr[2][2]).to.equal(2)
	end)
	it("should allow spread 7", function()
		local function foo()
			return TS.generator(function()
				coroutine.yield(2)
			end)
		end
		local counter = 0
		local _array = {}
		local _length = #_array
		counter += 1
		_array[_length + 1] = counter
		_length += 1
		for _result in foo().next do
			if _result.done then
				break
			end
			_length += 1
			_array[_length] = _result.value
		end
		local newArr = _array
		expect(newArr[1]).to.equal(1)
		expect(newArr[2]).to.equal(2)
	end)
	it("should copy on spread", function()
		local a = { 1, 2, 3 }
		local _array = {}
		local _length = #_array
		table.move(a, 1, #a, _length + 1, _array)
		local b = _array
		expect(a).never.to.equal(b)
		expect(#a).to.equal(#b)
		for i = 0, #a - 1 do
			expect(b[i + 1]).to.equal(a[i + 1])
		end
	end)
	it("should unpack spread into function calls", function()
		local function foo(...)
			local args = { ... }
			expect(args[1]).to.equal(1)
			expect(args[2]).to.equal(2)
			expect(args[3]).to.equal(3)
		end
		foo(unpack({ 1, 2, 3 }))
	end)
	it("should support Array.sort", function()
		local _exp = { "March", "Jan", "Feb", "Dec" }
		table.sort(_exp)
		local months = _exp
		expect(months[1]).to.equal("Dec")
		expect(months[2]).to.equal("Feb")
		expect(months[3]).to.equal("Jan")
		expect(months[4]).to.equal("March")
		local _exp_1 = { 1, 30, 4, 21, 100000 }
		table.sort(_exp_1)
		local array1 = _exp_1
		expect(array1[1]).to.equal(1)
		expect(array1[2]).to.equal(4)
		expect(array1[3]).to.equal(21)
		expect(array1[4]).to.equal(30)
		expect(array1[5]).to.equal(100000)
	end)
	it("should support Array.isEmpty", function()
		local _ = #({}) == 0
		local v = #({}) == 0
		local arr = {}
		local _1 = #arr == 0
		local x = #arr == 0
		expect(v).to.equal(true)
		table.insert(arr, "Nope")
		expect(#arr == 0).to.equal(false)
	end)
	it("should support Array.unorderedRemove", function()
		local arr = { 0, 1, 2, 3, 4, 5, 6, 7 }
		local i = 2
		local value
		i *= 2
		local _i = i
		-- ▼ Array.unorderedRemove ▼
		local _index = _i + 1
		local _length = #arr
		local _value = arr[_index]
		if _value ~= nil then
			arr[_index] = arr[_length]
			arr[_length] = nil
		end
		-- ▲ Array.unorderedRemove ▲
		expect(_value).to.equal(4)
		expect(#arr).to.equal(7)
		expect(arr[5]).to.equal(7)
		expect(arr[7]).to.equal(6)
	end)
	it("should support spreading non-apparent types", function()
		local function f(arr)
			local _array = {}
			local _length = #_array
			table.move(arr, 1, #arr, _length + 1, _array)
			return _array
		end
		f({ 0, 1 })
	end)
	it("should support Array constructor", function()
		expect(#table.create(10, nil) == 0).to.equal(true)
	end)
	it("should support Array.mapFiltered", function()
		local A
		do
			A = setmetatable({}, {
				__tostring = function()
					return "A"
				end,
			})
			A.__index = A
			function A.new(...)
				local self = setmetatable({}, A)
				return self:constructor(...) or self
			end
			function A:constructor()
			end
			function A:f()
				A.i += 1
				return if A.i > 5 then {
					x = A.i,
				} else nil
			end
			A.i = 0
		end
		local arr = { A.new(), A.new(), A.new(), A.new(), A.new(), A.new(), A.new(), A.new() }
		local _arg0 = function(a)
			return a:f()
		end
		-- ▼ ReadonlyArray.mapFiltered ▼
		local _newValue = {}
		local _length = 0
		for _k, _v in arr do
			local _result = _arg0(_v, _k - 1, arr)
			if _result ~= nil then
				_length += 1
				_newValue[_length] = _result
			end
		end
		-- ▲ ReadonlyArray.mapFiltered ▲
		local _arg0_1 = function(a, c)
			return a + c.x
		end
		-- ▼ ReadonlyArray.reduce ▼
		local _result = 0
		local _callback = _arg0_1
		for _i = 1, #_newValue do
			_result = _callback(_result, _newValue[_i], _i - 1, _newValue)
		end
		-- ▲ ReadonlyArray.reduce ▲
		expect(_result).to.equal(21)
	end)
	it("should support Array.filterUndefined", function()
		local function foo(...)
			local args = { ... }
			-- ▼ ReadonlyArray.filterUndefined ▼
			local _length = 0
			for _i in args do
				if _i > _length then
					_length = _i
				end
			end
			local _result = {}
			local _resultLength = 0
			for _i = 1, _length do
				local _v = args[_i]
				if _v ~= nil then
					_resultLength += 1
					_result[_resultLength] = _v
				end
			end
			-- ▲ ReadonlyArray.filterUndefined ▲
			local safeArgs = _result
			expect(safeArgs[1]).to.equal("A")
			expect(safeArgs[2]).to.equal("B")
			expect(safeArgs[3]).to.equal("C")
		end
		foo(nil, "A", nil, "B", nil, "C", nil)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="299">
        <Properties>
          <string name="Name">assignment.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support logical null coalescing assignment statement", function()
		local x
		if x == nil then
			x = true
		end
		expect(x).to.equal(true)
	end)
	it("should support logical or assignment statement", function()
		local x = false
		local _condition = x
		if not x then
			_condition = true
		end
		x = _condition
		expect(x).to.equal(true)
	end)
	it("should support logical and assignment statement", function()
		local x = true
		local _condition = x
		if x then
			_condition = false
		end
		x = _condition
		expect(x).to.equal(false)
	end)
	it("should support logical null coalescing assignment expression", function()
		local x
		if x == nil then
			x = true
		end
		expect(x).to.equal(true)
		expect(x).to.equal(true)
	end)
	it("should support logical or assignment expression", function()
		local x = false
		local _condition = x
		if not x then
			_condition = true
		end
		x = _condition
		expect(x).to.equal(true)
		expect(x).to.equal(true)
	end)
	it("should support logical and assignment expression", function()
		local x = true
		local _condition = x
		if x then
			_condition = false
		end
		x = _condition
		expect(x).to.equal(false)
		expect(x).to.equal(false)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="300">
        <Properties>
          <string name="Name">binary.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support binary expressions on properties", function()
		local foo = {
			bar = 1,
		}
		foo.bar += 1
		expect(foo.bar).to.equal(2)
	end)
	it("should support binary assignment on properties", function()
		local foo = {
			bar = 1,
		}
		foo.bar += 1
		expect(foo.bar).to.equal(2)
	end)
	it("should support computedPropertyAccessExpressions requiring precedingStatements", function()
		local x = 0
		local arr = { 3, 4, 5 }
		local function f()
			x += 1
			return x
		end
		local _index = f() + 1
		x += 1
		arr[_index] *= x
		expect((arr[_index])).to.equal(8)
		expect(x).to.equal(2)
		local numCalls = 0
		local function g()
			local _object = {}
			local _left = 2
			numCalls += 1
			_object[_left] = numCalls
			return _object
		end
		local i = 2
		local _exp = g()
		local _original = i
		i += 1
		_exp[_original] *= i
		expect((_exp[_original])).to.equal(3)
		expect(numCalls).to.equal(1)
		i = 0
		local _object = {}
		i += 1
		local _left = i
		i += 1
		_object[_left] = i
		local _original_1 = i
		i += 1
		local _index_1 = _original_1 - 1
		i += 1
		_object[_index_1] *= i
		expect((_object[_index_1])).to.equal(8)
		do
			do
				do
					local i = 0
					local _object_1 = {}
					local _left_1 = "jk"
					local _object_2 = {
						o = 3,
					}
					local _left_2 = "b"
					local _original_2 = i
					i += 1
					_object_2[_left_2] = _original_2
					_object_2.a4 = {
						[2] = i,
						k = 4,
					}
					function _object_2:g()
						self.b += 1
					end
					_object_2.no = function(self)
						self[5] *= 7
						return self[5]
					end
					_object_2[5] = 3
					_object_1[_left_1] = _object_2
					expect(_object_1.jk:no()).to.equal(21)
					expect(({
						o = 8,
						a = function(self)
							self.o += 1
							return self
						end,
						e = function(self)
							self.o += 1
							return self.o
						end,
					}):a():e()).to.equal(10)
				end
			end
		end
	end)
	it("should push WritableOperandNames", function()
		local numItems = 0
		local _class
		do
			_class = setmetatable({}, {
				__tostring = function()
					return "Anonymous"
				end,
			})
			_class.__index = _class
			function _class.new(...)
				local self = setmetatable({}, _class)
				return self:constructor(...) or self
			end
			function _class:constructor()
				local _original = numItems
				numItems += 1
				self.id = _original
			end
		end
		_class.new().id += 1
		expect(numItems).to.equal(1)
	end)
	it("should support unary expressions on indexed parenthesized expressions", function()
		-- issue #470
		local array = { 0 }
		-- prettier-ignore
		array[1] += 1
		expect(array[1]).to.equal(1)
	end)
	it("should support unary expressions on indexed call expressions", function()
		local array = { 0 }
		local function getArray()
			return array
		end
		getArray()[1] += 1
		expect(array[1]).to.equal(1)
	end)
	it("should always put parentheses around unary expressions", function()
		local buttonSize = 10
		local a = -(48 + 1 * (buttonSize + 4) + 4)
		local b = -48 + 1 * (buttonSize + 4) + 4
		expect(a).to.equal(-66)
		expect(b).to.equal(-30)
	end)
	it("should support set expressions with parenthesis around the left-hand side", function()
		local x = 5
		-- prettier-ignore
		x *= 9
		expect(x).to.equal(45)
		local o = {
			x = 3,
		}
		-- prettier-ignore
		o.x = 5
		expect(o.x).to.equal(5)
		-- prettier-ignore
		o.x = 8
		expect(o.x).to.equal(8)
	end)
	it("should support comma operator", function()
		local x = 0
		local _exp = expect(x).to.equal(0)
		x = 1
		expect(x).to.equal(1)
		local _exp_1 = expect(x).to.equal(1)
		x = 3
		expect(x).to.equal(3)
		expect((x + 2)).to.equal(5)
		local function a()
			return 1, 2
		end
		x = 8
		local _ = x
		local b = ({ a() })
		expect(b[1]).to.equal(1)
		expect(b[2]).to.equal(2)
		expect(x).to.equal(8)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="301">
        <Properties>
          <string name="Name">bitwise.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support bitwise operations", function()
		local a = 0b101
		local b = 0b110
		expect(bit32.bor(a, b)).to.equal(0b111)
		expect(bit32.band(a, b)).to.equal(0b100)
		expect(bit32.bxor(a, b)).to.equal(0b011)
		expect(bit32.lshift(a, 1)).to.equal(0b1010)
		expect(bit32.arshift(a, 1)).to.equal(0b10)
		expect(bit32.rshift(a, 1)).to.equal(0b10)
		expect(bit32.bor(a, 0)).to.equal(0b101)
		expect(bit32.bnot(a)).to.equal(4294967290)
		expect(bit32.bnot(b)).to.equal(4294967289)
	end)
	it("should support bitwise assignment", function()
		local a = 0b101
		a = bit32.bor(a, 0b110)
		expect(a).to.equal(0b111)
		local b = 0b101
		b = bit32.band(b, 0b110)
		expect(b).to.equal(0b100)
		local c = 0b101
		c = bit32.bxor(c, 0b110)
		expect(c).to.equal(0b011)
		local d = 0b101
		d = bit32.lshift(d, 1)
		expect(d).to.equal(0b1010)
		local e = 0b101
		e = bit32.arshift(e, 1)
		expect(e).to.equal(0b10)
		local f = -1
		f = bit32.rshift(f, 0)
		expect(f).to.equal(math.pow(2, 32) - 1)
	end)
	it("should support bitwise assignment expressions", function()
		local a = 0b101
		a = bit32.bor(a, 0b110)
		expect(a).to.equal(0b111)
		local b = 0b101
		b = bit32.band(b, 0b110)
		expect(b).to.equal(0b100)
		local c = 0b101
		c = bit32.bxor(c, 0b110)
		expect(c).to.equal(0b011)
		local d = 0b101
		d = bit32.lshift(d, 1)
		expect(d).to.equal(0b1010)
		local e = 0b101
		e = bit32.arshift(e, 1)
		expect(e).to.equal(0b10)
		local f = -1
		f = bit32.rshift(f, 0)
		expect(f).to.equal(math.pow(2, 32) - 1)
	end)
	it("should support bitwise with negative numbers", function()
		local x = -5
		x = bit32.arshift(x, 1)
		expect(x).to.equal(4294967293)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="302">
        <Properties>
          <string name="Name">class.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
return function()
	it("should properly initialize static properties and use `this` in a static context correctly", function()
		local X
		do
			X = setmetatable({}, {
				__tostring = function()
					return "X"
				end,
			})
			X.__index = X
			function X.new(...)
				local self = setmetatable({}, X)
				return self:constructor(...) or self
			end
			function X:constructor()
			end
			X.value1 = "a"
			do
				X.value1 ..= "b"
			end
			X.value2 = X.value1 .. "c"
		end
		expect(X.value1).to.equal("ab")
		expect(X.value2).to.equal("abc")
	end)
	it("should create a class with a constructor", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor(bar)
				self.bar = bar
			end
		end
		local foo = Foo.new("baz!")
		expect(foo.bar).to.equal("baz!")
	end)
	it("should construct with default parameters and accessors", function()
		local Vector
		do
			Vector = setmetatable({}, {
				__tostring = function()
					return "Vector"
				end,
			})
			Vector.__index = Vector
			function Vector.new(...)
				local self = setmetatable({}, Vector)
				return self:constructor(...) or self
			end
			function Vector:constructor(x, y, z)
				if x == nil then
					x = 0
				end
				if y == nil then
					y = 0
				end
				if z == nil then
					z = 0
				end
				self.x = x
				self.y = y
				self.z = z
			end
		end
		local v0 = Vector.new(1, 2, 3)
		expect(v0.x).to.equal(1)
		expect(v0.y).to.equal(2)
		expect(v0.z).to.equal(3)
		local v1 = Vector.new()
		expect(v1.x).to.equal(0)
		expect(v1.y).to.equal(0)
		expect(v1.z).to.equal(0)
	end)
	it("should expose a public method", function()
		local Greeter
		do
			Greeter = setmetatable({}, {
				__tostring = function()
					return "Greeter"
				end,
			})
			Greeter.__index = Greeter
			function Greeter.new(...)
				local self = setmetatable({}, Greeter)
				return self:constructor(...) or self
			end
			function Greeter:constructor(message)
				self.greeting = message
			end
			function Greeter:greet()
				return "Hello, " .. self.greeting
			end
			Greeter.f = TS.async(function(self) end)
		end
		local artemis = Greeter.new("artemis")
		expect(artemis.greeting).to.equal("artemis")
		expect(artemis:greet()).to.equal("Hello, artemis")
	end)
	it("should inhereit methods", function()
		local Animal
		do
			Animal = setmetatable({}, {
				__tostring = function()
					return "Animal"
				end,
			})
			Animal.__index = Animal
			function Animal.new(...)
				local self = setmetatable({}, Animal)
				return self:constructor(...) or self
			end
			function Animal:constructor()
			end
			function Animal:move(distanceInMeters)
				if distanceInMeters == nil then
					distanceInMeters = 0
				end
				return "Animal moved " .. (tostring(distanceInMeters) .. "m.")
			end
		end
		local Dog
		do
			local super = Animal
			Dog = setmetatable({}, {
				__tostring = function()
					return "Dog"
				end,
				__index = super,
			})
			Dog.__index = Dog
			function Dog.new(...)
				local self = setmetatable({}, Dog)
				return self:constructor(...) or self
			end
			function Dog:constructor(name)
				super.constructor(self)
				self.name = name
			end
			function Dog:bark()
				return self.name .. " barks"
			end
		end
		local apollo = Dog.new("apollo")
		expect(apollo:move()).to.equal("Animal moved 0m.")
		expect(apollo:move(5)).to.equal("Animal moved 5m.")
		expect(apollo:bark()).to.equal("apollo barks")
	end)
	it("should support static methods", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
			function Foo:bar()
				return "bar"
			end
			Foo.barf = TS.async(function(self)
				return "barf"
			end)
		end
		expect(Foo:bar()).to.equal("bar")
	end)
	it("should inherit static methods", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
			function Foo:bar()
				return "bar"
			end
		end
		local Bar
		do
			local super = Foo
			Bar = setmetatable({}, {
				__tostring = function()
					return "Bar"
				end,
				__index = super,
			})
			Bar.__index = Bar
			function Bar.new(...)
				local self = setmetatable({}, Bar)
				return self:constructor(...) or self
			end
			function Bar:constructor(...)
				super.constructor(self, ...)
			end
		end
		expect(Bar:bar()).to.equal("bar")
	end)
	it("should support parameter initializers", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
				self.bar = "baz"
			end
		end
		local foo = Foo.new()
		expect(foo.bar).to.equal("baz")
	end)
	it("should support toString", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
			function Foo:toString()
				return "Foo"
			end
			function Foo:__tostring()
				return self:toString()
			end
		end
		expect(tostring(Foo.new())).to.equal("Foo")
	end)
	it("should support toString inheritance", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
			function Foo:toString()
				return "Foo"
			end
			function Foo:__tostring()
				return self:toString()
			end
		end
		local Bar
		do
			local super = Foo
			Bar = setmetatable({}, {
				__tostring = function()
					return "Bar"
				end,
				__index = super,
			})
			Bar.__index = Bar
			function Bar.new(...)
				local self = setmetatable({}, Bar)
				return self:constructor(...) or self
			end
			function Bar:constructor(...)
				super.constructor(self, ...)
			end
			function Bar:__tostring()
				return self:toString()
			end
		end
		expect(tostring(Bar.new())).to.equal("Foo")
	end)
	it("should support toString inheritance with ClassExpression", function()
		local A
		do
			local _class
			do
				local B = setmetatable({}, {
					__tostring = function()
						return "B"
					end,
				})
				B.__index = B
				function B.new(...)
					local self = setmetatable({}, B)
					return self:constructor(...) or self
				end
				function B:constructor()
				end
				function B:toString()
					return "B"
				end
				function B:__tostring()
					return self:toString()
				end
				_class = B
			end
			local super = _class
			A = setmetatable({}, {
				__tostring = function()
					return "A"
				end,
				__index = super,
			})
			A.__index = A
			function A.new(...)
				local self = setmetatable({}, A)
				return self:constructor(...) or self
			end
			function A:constructor(...)
				super.constructor(self, ...)
			end
			function A:__tostring()
				return self:toString()
			end
		end
		expect(tostring(A.new())).to.equal("B")
	end)
	it("should support multiple constructors", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor(name)
				if name ~= "" and name then
					self.name = name
				end
			end
		end
		local foo1 = Foo.new()
		expect(foo1.name).never.to.be.ok()
		local foo2 = Foo.new("bar")
		expect(foo2.name).to.equal("bar")
	end)
	it("should support constructor parameter destructuring", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor(_param)
				local a = _param.a
				self.bar = a
			end
		end
		expect(Foo.new({
			a = 123,
		}).bar).to.equal(123)
	end)
	it("should support passing the rest parameter from constructor to super", function()
		local A
		do
			A = setmetatable({}, {
				__tostring = function()
					return "A"
				end,
			})
			A.__index = A
			function A.new(...)
				local self = setmetatable({}, A)
				return self:constructor(...) or self
			end
			function A:constructor(...)
				local rest = { ... }
				expect(rest[1]).to.equal(10)
				expect(rest[2]).to.equal(20)
				expect(rest[3]).to.equal(30)
			end
		end
		local B
		do
			local super = A
			B = setmetatable({}, {
				__tostring = function()
					return "B"
				end,
				__index = super,
			})
			B.__index = B
			function B.new(...)
				local self = setmetatable({}, B)
				return self:constructor(...) or self
			end
			function B:constructor(...)
				local rest = { ... }
				super.constructor(self, unpack(rest))
			end
		end
		expect(function()
			return B.new(10, 20, 30)
		end).never:throw()
	end)
	it("should support class expressions", function()
		local _class
		do
			_class = setmetatable({}, {
				__tostring = function()
					return "Anonymous"
				end,
			})
			_class.__index = _class
			function _class.new(...)
				local self = setmetatable({}, _class)
				return self:constructor(...) or self
			end
			function _class:constructor()
			end
			function _class:bar()
				return "A"
			end
		end
		local Foo = _class
		local _class_1
		do
			local super = Foo
			_class_1 = setmetatable({}, {
				__tostring = function()
					return "Anonymous"
				end,
				__index = super,
			})
			_class_1.__index = _class_1
			function _class_1.new(...)
				local self = setmetatable({}, _class_1)
				return self:constructor(...) or self
			end
			function _class_1:constructor(...)
				super.constructor(self, ...)
			end
		end
		local Bar = _class_1
		local bar = Bar.new()
		expect(bar:bar()).to.equal("A")
	end)
	it("should support built-in classes", function()
		expect(TS.Promise.new(function() end)).to.be.ok()
	end)
	it("should support numeric members", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
				self[1] = "bar"
			end
		end
		expect(Foo.new()[1]).to.equal("bar")
	end)
	it("should support computed members", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
				self.bar = "baz"
			end
		end
		expect(Foo.new().bar).to.equal("baz")
	end)
	it("should support numeric statics", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
			Foo[1] = "bar"
		end
		expect(Foo[1]).to.equal("bar")
	end)
	it("should support computed statics", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
			Foo.bar = "baz"
		end
		expect(Foo.bar).to.equal("baz")
	end)
	it("should support new expressions without parentheses", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
				self.bar = 1
			end
		end
		-- prettier-ignore
		local foo = Foo.new()
		expect(foo).to.be.ok()
		expect(TS.instanceof(foo, Foo)).to.equal(true)
		expect(foo.bar).to.equal(1)
	end)
	it("should compile static fields last", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
			function Foo:bar()
				return "baz"
			end
			Foo.x = Foo.new():bar()
		end
		expect(Foo.x).to.equal("baz")
	end)
	it("should support invalid indexing", function()
		local _class
		do
			local A = setmetatable({}, {
				__tostring = function()
					return "A"
				end,
			})
			A.__index = A
			function A.new(...)
				local self = setmetatable({}, A)
				return self:constructor(...) or self
			end
			function A:constructor()
				self["$v"] = 2
			end
			A["$"] = function(self)
				self["$v"] += 1
				return self["$v"]
			end
			_class = A
		end
		local _fn = _class.new()
		expect(_fn["$"](_fn)).to.equal(3)
		local _class_1
		do
			_class_1 = setmetatable({}, {
				__tostring = function()
					return "Anonymous"
				end,
			})
			_class_1.__index = _class_1
			function _class_1.new(...)
				local self = setmetatable({}, _class_1)
				return self:constructor(...) or self
			end
			function _class_1:constructor()
			end
			_class_1["$"] = function(self)
				self["$v"] += 1
				return self["$v"]
			end
			_class_1["$v"] = 2
		end
		expect(_class_1["$"](_class_1)).to.equal(3)
		local _class_2
		do
			local _class_3
			do
				_class_3 = setmetatable({}, {
					__tostring = function()
						return "Anonymous"
					end,
				})
				_class_3.__index = _class_3
				function _class_3.new(...)
					local self = setmetatable({}, _class_3)
					return self:constructor(...) or self
				end
				function _class_3:constructor()
					self["$v"] = -1
				end
				_class_3["$"] = function(self)
					self["$v"] += 1
					return self["$v"]
				end
			end
			local super = _class_3
			_class_2 = setmetatable({}, {
				__tostring = function()
					return "Anonymous"
				end,
				__index = super,
			})
			_class_2.__index = _class_2
			function _class_2.new(...)
				local self = setmetatable({}, _class_2)
				return self:constructor(...) or self
			end
			function _class_2:constructor(...)
				super.constructor(self, ...)
			end
			_class_2["$"] = function(self)
				return super["$"](self)
			end
		end
		local _fn_1 = _class_2.new()
		expect(_fn_1["$"](_fn_1)).to.equal(0)
		local _class_3
		do
			local _class_4
			do
				_class_4 = setmetatable({}, {
					__tostring = function()
						return "Anonymous"
					end,
				})
				_class_4.__index = _class_4
				function _class_4.new(...)
					local self = setmetatable({}, _class_4)
					return self:constructor(...) or self
				end
				function _class_4:constructor()
				end
				_class_4["$"] = function(self)
					self["$v"] += 1
					return self["$v"]
				end
				_class_4["$v"] = -1
			end
			local super = _class_4
			_class_3 = setmetatable({}, {
				__tostring = function()
					return "Anonymous"
				end,
				__index = super,
			})
			_class_3.__index = _class_3
			function _class_3.new(...)
				local self = setmetatable({}, _class_3)
				return self:constructor(...) or self
			end
			function _class_3:constructor(...)
				super.constructor(self, ...)
			end
			_class_3["$"] = function(self)
				return super["$"](self)
			end
		end
		expect(_class_3["$"](_class_3)).to.equal(0)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="303">
        <Properties>
          <string name="Name">delete.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	describe("should work for objects", function()
		it("should delete from the object with property acccess", function()
			local myTrolly = {
				apples = 5,
				bananas = 6,
				pears = 7,
			}
			myTrolly.apples = nil
			myTrolly.pears = nil
			expect(myTrolly.apples).to.equal(nil)
			expect(myTrolly.pears).to.equal(nil)
		end)
		it("should delete with optional property access", function()
			local myTrolly = {
				apples = 5,
				bananas = 6,
				pears = 7,
			}
			local _result = myTrolly
			if _result ~= nil then
				_result.apples = nil
			end
			local _result_1 = myTrolly
			if _result_1 ~= nil then
				_result_1.pears = nil
			end
			expect(myTrolly.apples).to.equal(nil)
			expect(myTrolly.pears).to.equal(nil)
		end)
		it("should delete from the object with element access", function()
			local myTrolly = {
				apples = 5,
				bananas = 6,
				pears = 7,
			}
			myTrolly.apples = nil
			myTrolly.pears = nil
			expect(myTrolly.apples).to.equal(nil)
			expect(myTrolly.pears).to.equal(nil)
		end)
		it("should delete with optional element access", function()
			local myTrolly = {
				apples = 5,
				bananas = 6,
				pears = 7,
			}
			local _result = myTrolly
			if _result ~= nil then
				_result.apples = nil
			end
			local _result_1 = myTrolly
			if _result_1 ~= nil then
				_result_1.pears = nil
			end
			expect(myTrolly.apples).to.equal(nil)
			expect(myTrolly.pears).to.equal(nil)
		end)
		it("should not delete other properties", function()
			local myTrolly = {
				apples = 5,
				bananas = 6,
			}
			myTrolly.apples = nil
			local _result = myTrolly
			if _result ~= nil then
				_result.apples = nil
			end
			local _result_1 = myTrolly
			if _result_1 ~= nil then
				_result_1.apples = nil
			end
			local _result_2 = myTrolly
			if _result_2 ~= nil then
				_result_2.apples = nil
			end
			expect(myTrolly.bananas).to.equal(6)
		end)
		it("should be able to do objects inside objects", function()
			local myTrollies = {
				c = {
					apples = 5,
					bananas = 6,
				},
			}
			myTrollies.c.apples = nil
			expect(myTrollies.c.apples).to.equal(nil)
		end)
	end)
	-- we use this function as otherwise TypeScript will evaluate the type of the variable and determine if it's possible to perform optional chaining on it.
	local function getFruitsOrUndefined()
		return nil
	end
	describe("should return true", function()
		it("should return true for property access", function()
			local myTrolly = {
				apples = 5,
				bananas = 6,
				pears = 7,
			}
			myTrolly.apples = nil
			expect(true).to.equal(true)
			myTrolly.pears = nil
			expect(true).to.equal(true)
		end)
		it("should return true for optional property access", function()
			local myTrolly = getFruitsOrUndefined()
			local _result = myTrolly
			if _result ~= nil then
				_result.apples = nil
			end
			expect(true).to.equal(true)
			local _result_1 = myTrolly
			if _result_1 ~= nil then
				_result_1.pears = nil
			end
			expect(true).to.equal(true)
		end)
		it("should return true for element access", function()
			local myTrolly = {
				apples = 5,
				bananas = 6,
				pears = 7,
			}
			myTrolly.apples = nil
			expect(true).to.equal(true)
			myTrolly.apples = nil
			expect(true).to.equal(true)
		end)
		it("should return true for optional element access", function()
			local myTrolly = getFruitsOrUndefined()
			local _result = myTrolly
			if _result ~= nil then
				_result.apples = nil
			end
			expect(true).to.equal(true)
			local _result_1 = myTrolly
			if _result_1 ~= nil then
				_result_1.pears = nil
			end
			expect(true).to.equal(true)
		end)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="304">
        <Properties>
          <string name="Name">destructure.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
-- eslint-disable prefer-const 
return function()
	it("should destructure simple arrays", function()
		local a, b = 1, 2
		expect(a).to.equal(1)
		expect(b).to.equal(2)
	end)
	it("should destructure nested arrays", function()
		local _binding, _binding_1 = { 7, 2 }, { 8, 9 }
		local a = _binding[1]
		local b = _binding[2]
		local c = _binding_1[1]
		local d = _binding_1[2]
		expect(a).to.equal(7)
		expect(b).to.equal(2)
		expect(c).to.equal(8)
		expect(d).to.equal(9)
	end)
	it("should destructure simple objects", function()
		local a = {
			b = 1,
			c = 2,
			d = 3,
		}
		local _binding = a
		local b = _binding.b
		local c = _binding.c
		local d = _binding.d
		expect(b).to.equal(1)
		expect(c).to.equal(2)
		expect(d).to.equal(3)
	end)
	it("should destructure nested objects", function()
		local a = {
			b = {
				c = {
					d = 123,
				},
			},
		}
		local _binding = a
		local _binding_1 = _binding.b
		local _binding_2 = _binding_1.c
		local d = _binding_2.d
		expect(d).to.equal(123)
	end)
	it("should destructure mixed objects", function()
		local a = {
			b = {
				c = { 8, 1, 4 },
			},
		}
		local _binding = a
		local _binding_1 = _binding.b
		local _binding_2 = _binding_1.c
		local eight = _binding_2[1]
		local one = _binding_2[2]
		local four = _binding_2[3]
		expect(eight).to.equal(8)
		expect(one).to.equal(1)
		expect(four).to.equal(4)
	end)
	it("should support default values", function()
		local foo = {
			a = {
				b = 1,
			},
		}
		local bar = {
			a = {
				b = nil,
			},
		}
		do
			local _binding = foo
			local _binding_1 = _binding.a
			local b = _binding_1.b
			if b == nil then
				b = 5
			end
			expect(b).to.equal(1)
		end
		do
			local _binding = bar
			local _binding_1 = _binding.a
			local b = _binding_1.b
			if b == nil then
				b = 5
			end
			expect(b).to.equal(5)
		end
	end)
	it("should support aliases", function()
		local foo = {
			a = {
				b = 123,
			},
		}
		local _binding = foo
		local _binding_1 = _binding.a
		local z = _binding_1.b
		expect(z).to.equal(123)
	end)
	it("should not optimize array destructuring", function()
		local function a()
			return { 1, 2, 3 }
		end
		local _binding = a()
		local d = _binding[1]
		local e = _binding[2]
		local f = _binding[3]
		expect(d).to.equal(1)
		expect(e).to.equal(2)
		expect(f).to.equal(3)
	end)
	it("should optimize tuple destructuring", function()
		local function a()
			return { 1, 2, 3 }
		end
		local _binding = a()
		local d = _binding[1]
		local e = _binding[2]
		local f = _binding[3]
		expect(d).to.equal(1)
		expect(e).to.equal(2)
		expect(f).to.equal(3)
	end)
	it("should optimize tuple destructuring with omitted expressions", function()
		local function a()
			return { 1, 2, 3, 4 }
		end
		local _binding = a()
		local b = _binding[2]
		local c = _binding[4]
		expect(b).to.equal(2)
		expect(c).to.equal(4)
	end)
	it("should support destructure assignment", function()
		local x
		local y
		local z
		local _binding
		x, y, _binding = 1, 2, { 3 }
		z = _binding[1]
		expect(x).to.equal(1)
		expect(y).to.equal(2)
		expect(z).to.equal(3)
	end)
	it("should support destructure assignment with identifier", function()
		local x
		local y
		local z
		local obj = { 1, 2, { 3 } }
		local _binding = obj
		x = _binding[1]
		y = _binding[2]
		local _binding_1 = _binding[3]
		z = _binding_1[1]
		expect(x).to.equal(1)
		expect(y).to.equal(2)
		expect(z).to.equal(3)
	end)
	it("should support destructure assignment as expression", function()
		local function test(obj)
			expect(obj[1]).to.equal(1)
			expect(obj[2]).to.equal(2)
			expect(obj[3][1]).to.equal(3)
		end
		local x
		local y
		local z
		local _binding = { 1, 2, { 3 } }
		x = _binding[1]
		y = _binding[2]
		local _binding_1 = _binding[3]
		z = _binding_1[1]
		test(_binding)
		expect(x).to.equal(1)
		expect(y).to.equal(2)
		expect(z).to.equal(3)
	end)
	it("should support destructure assignment with property access", function()
		local obj = {
			x = 0,
			y = 0,
			z = 0,
		}
		local _binding
		obj.x, obj.y, _binding = 1, 2, { 3 }
		obj.z = _binding[1]
		expect(obj.x).to.equal(1)
		expect(obj.y).to.equal(2)
		expect(obj.z).to.equal(3)
	end)
	it("should support indexing a return value from a function", function()
		local function foo()
			return { 1, 2, 3 }
		end
		local function bar()
			return { 4, 5, 6 }
		end
		expect(foo()[1]).to.equal(1)
		expect(foo()[2]).to.equal(2)
		expect(foo()[3]).to.equal(3)
		expect(bar()[1]).to.equal(4)
		expect(bar()[2]).to.equal(5)
		expect(bar()[3]).to.equal(6)
	end)
	it("should support accessing the size method", function()
		local _ = #({ 1, 2, 3 })
		expect(#({ 1, 2, 3 })).to.equal(3)
	end)
	it("should destructure properly into already declared variables", function()
		local a
		local _binding = {
			[4] = true,
		}
		local _value = next(_binding)
		a = _value
		expect(a).to.equal(4)
		local len
		local _binding_1 = { 1, 2, 3 }
		len = _binding_1[3]
		expect(len).to.equal(3)
		local y = 0
		local _binding_2 = {
			x = 1,
		}
		y = _binding_2.x
		expect(y).to.equal(1)
	end)
	it("should destructure computed property types as well (number-only)", function()
		local array = {}
		-- ▼ Array.push ▼
		table.insert(array, 1)
		table.insert(array, 2)
		table.insert(array, 3)
		table.insert(array, 4)
		-- ▲ Array.push ▲
		local function f(i)
			local num
			local _binding = array
			num = _binding[i + 1]
			return num
		end
		expect(f(0)).to.equal(1)
		expect(f(1)).to.equal(2)
		expect(f(2)).to.equal(3)
		expect(f(3)).to.equal(4)
	end)
	it("should destructure into objects", function()
		local o = {
			a = 100,
			b = 100,
			c = 100,
			d = 100,
			[1] = 100,
			e = 100,
		}
		local f = function()
			return "6"
		end
		-- prettier-ignore
		local _binding = {
			a = 1,
			b = 2,
			c = 3,
			["9"] = 4,
			[5] = 5,
			["6"] = 6,
		}
		o.a = _binding.a
		o.b = _binding.b
		o.c = _binding["9"]
		o.d = _binding[5]
		o.e = _binding[f()]
		o[1] = _binding.c
		local i = 0
		local _fn = expect(o.a).to
		i += 1
		_fn.equal(i)
		local _fn_1 = expect(o.b).to
		i += 1
		_fn_1.equal(i)
		local _fn_2 = expect(o[1]).to
		i += 1
		_fn_2.equal(i)
		local _fn_3 = expect(o.c).to
		i += 1
		_fn_3.equal(i)
		local _fn_4 = expect(o.d).to
		i += 1
		_fn_4.equal(i)
		local _fn_5 = expect(o.e).to
		i += 1
		_fn_5.equal(i)
	end)
	it("should properly destructure optimized strings", function()
		local truth = { "a", "b", "c", "d", "e", "f", "g" }
		local _array = {}
		local _length = #_array
		for _char in string.gmatch("abcdefg", utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		local _arg0 = function(x, i)
			return truth[i + 1] == x
		end
		-- ▼ ReadonlyArray.every ▼
		local _result = true
		for _k, _v in _array do
			if not _arg0(_v, _k - 1, _array) then
				_result = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result).to.equal(true)
	end)
	it("should properly destructure optimized strings with a ' as quotes", function()
		local truth = { "a", "b", "c", '"', "d", "e", "f", "g" }
		local _array = {}
		local _length = #_array
		for _char in string.gmatch('abc"defg', utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		local _arg0 = function(x, i)
			return truth[i + 1] == x
		end
		-- ▼ ReadonlyArray.every ▼
		local _result = true
		for _k, _v in _array do
			if not _arg0(_v, _k - 1, _array) then
				_result = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result).to.equal(true)
	end)
	it("should properly destructure optimized strings with backslashes", function()
		local truth = { "a", "\n", "b", "c", '"', "d", "e", "\t", "f", "\\", "g" }
		local _array = {}
		local _length = #_array
		for _char in string.gmatch('a\nbc"de\tf\\g', utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		local _arg0 = function(x, i)
			return truth[i + 1] == x
		end
		-- ▼ ReadonlyArray.every ▼
		local _result = true
		for _k, _v in _array do
			if not _arg0(_v, _k - 1, _array) then
				_result = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result).to.equal(true)
	end)
	it("should properly destructure strings with a ` as quotes", function()
		local truth = { "'", "a", "b", "c", '"', "d", "e", "f", "g", "'" }
		local _array = {}
		local _length = #_array
		for _char in string.gmatch([['abc"defg']], utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		local _arg0 = function(x, i)
			return truth[i + 1] == x
		end
		-- ▼ ReadonlyArray.every ▼
		local _result = true
		for _k, _v in _array do
			if not _arg0(_v, _k - 1, _array) then
				_result = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result).to.equal(true)
	end)
	it("should properly destruct gmatch #1", function()
		local function catchLetters(...)
			local letterPairs = { ... }
			local i = 97
			for _, _binding in letterPairs do
				local a = _binding[1]
				local b = _binding[2]
				local _fn = expect(a).to
				local _fn_1 = string
				local _original = i
				i += 1
				_fn.equal(_fn_1.char(_original))
				local _fn_2 = expect(b).to
				local _fn_3 = string
				local _original_1 = i
				i += 1
				_fn_2.equal(_fn_3.char(_original_1))
			end
		end
		local _array = {}
		local _length = 0
		local _iterFunc = string.gmatch("abcdefghijklmnopqrstuvwxyz", "(%l)(%l)")
		while true do
			local _results = { _iterFunc() }
			if #_results == 0 then
				break
			end
			_length += 1
			_array[_length] = _results
		end
		catchLetters(unpack(_array))
	end)
	it("should properly destruct gmatch #2", function()
		local _binding = string.gmatch("a,b,c", "[^,]+")
		local _binding_1 = { _binding() }
		local a = _binding_1[1]
		local _binding_2 = { _binding() }
		local b = _binding_2[1]
		local _binding_3 = { _binding() }
		local c = _binding_3[1]
		expect(a).to.equal("a")
		expect(b).to.equal("b")
		expect(c).to.equal("c")
	end)
	it("should properly destruct gmatch #3", function()
		local _binding = string.gmatch("z,a,b,c", "[^,]+")
		_binding()
		local _binding_1 = { _binding() }
		local a = _binding_1[1]
		local _binding_2 = { _binding() }
		local b = _binding_2[1]
		local _binding_3 = { _binding() }
		local c = _binding_3[1]
		expect(a).to.equal("a")
		expect(b).to.equal("b")
		expect(c).to.equal("c")
	end)
	it("should properly destruct sets", function()
		local expected = {
			[1] = true,
			[2] = true,
			[3] = true,
		}
		local _binding = {
			[1] = true,
			[2] = true,
			[3] = true,
		}
		local _value = next(_binding)
		local a = _value
		local _value_1 = next(_binding, _value)
		local b = _value_1
		local _value_2 = next(_binding, _value_1)
		local c = _value_2
		-- ▼ Set.delete ▼
		local _valueExisted = expected[a] ~= nil
		expected[a] = nil
		-- ▲ Set.delete ▲
		expect(_valueExisted).to.equal(true)
		-- ▼ Set.delete ▼
		local _valueExisted_1 = expected[b] ~= nil
		expected[b] = nil
		-- ▲ Set.delete ▲
		expect(_valueExisted_1).to.equal(true)
		-- ▼ Set.delete ▼
		local _valueExisted_2 = expected[c] ~= nil
		expected[c] = nil
		-- ▲ Set.delete ▲
		expect(_valueExisted_2).to.equal(true)
	end)
	it("should properly destruct maps", function()
		local expected = {
			a = 1,
			b = 2,
			c = 3,
		}
		local _binding = {
			a = 1,
			b = 2,
			c = 3,
		}
		local _k, _v = next(_binding)
		local a = { _k, _v }
		local _k_1, _v_1 = next(_binding, _k)
		local b = { _k_1, _v_1 }
		local _k_2, _v_2 = next(_binding, _k_1)
		local c = { _k_2, _v_2 }
		local _arg0 = a[1]
		expect(expected[_arg0]).to.equal(a[2])
		local _arg0_1 = a[1]
		-- ▼ Map.delete ▼
		local _valueExisted = expected[_arg0_1] ~= nil
		expected[_arg0_1] = nil
		-- ▲ Map.delete ▲
		expect(_valueExisted).to.equal(true)
		local _arg0_2 = b[1]
		expect(expected[_arg0_2]).to.equal(b[2])
		local _arg0_3 = b[1]
		-- ▼ Map.delete ▼
		local _valueExisted_1 = expected[_arg0_3] ~= nil
		expected[_arg0_3] = nil
		-- ▲ Map.delete ▲
		expect(_valueExisted_1).to.equal(true)
		local _arg0_4 = c[1]
		expect(expected[_arg0_4]).to.equal(c[2])
		local _arg0_5 = c[1]
		-- ▼ Map.delete ▼
		local _valueExisted_2 = expected[_arg0_5] ~= nil
		expected[_arg0_5] = nil
		-- ▲ Map.delete ▲
		expect(_valueExisted_2).to.equal(true)
	end)
	it("should properly destruct with element access", function()
		local array = { 1, 2 }
		array[1], array[2] = array[2], array[1]
		expect(array[1]).to.equal(2)
		expect(array[2]).to.equal(1)
	end)
	it("should properly destruct with var element access", function()
		local array = { 1, 2 }
		local a = 0
		local b = 1
		local _index = a + 1
		local _index_1 = b + 1
		array[_index], array[_index_1] = array[b + 1], array[a + 1]
		expect(array[a + 1]).to.equal(2)
		expect(array[b + 1]).to.equal(1)
	end)
	it("should support initializers in object destructuring", function()
		local o = {
			a = 1,
			b = 2,
			c = 3,
		}
		local function f(x)
			local _binding = o
			local a = _binding[x]
			if a == nil then
				a = 0
			end
			return a
		end
		local function g(x)
			local _binding = o
			local b = _binding.x
			if b == nil then
				b = 2
			end
			return b
		end
		expect(f("a")).to.equal(1)
		expect(f("b")).to.equal(2)
		expect(f("c")).to.equal(3)
		expect(f("d")).to.equal(0)
		expect(g("a")).to.equal(2)
		expect(g("d")).to.equal(2)
	end)
	it("should support arrays with object destructure", function()
		local array = { 3, 4 }
		local a = 0
		local b = 1
		local _binding = array
		array[b + 1] = _binding[a + 1]
		array[a + 1] = _binding[b + 1]
		expect(array[a + 1]).to.equal(3)
		expect(array[b + 1]).to.equal(3)
	end)
	it("should support object destructuring with context", function()
		local y = 0
		local _binding = {
			x = nil,
		}
		local x = _binding.x
		if x == nil then
			local _original = y
			y += 1
			x = _original
		end
		expect(x).to.equal(0)
		expect(y).to.equal(1)
	end)
	it("should support object destructing from object with shorthand syntax", function()
		local x = 123
		local _binding = {
			x = x,
		}
		local y = _binding.x
		expect(y).to.equal(123)
	end)
	it("should support object destructing from object with numeric literal key", function()
		local x = 456
		local _binding = {
			[1] = x,
		}
		local y = _binding[1]
		expect(y).to.equal(456)
	end)
	it("should support object destructing from object with string literal key", function()
		local x = 789
		-- prettier-ignore
		local _binding = {
			str = x,
		}
		local y = _binding.str
		expect(y).to.equal(789)
	end)
	it("should support destructuring from strings", function()
		local str = "xyz"
		local _binding = str
		local _matcher = string.gmatch(_binding, utf8.charpattern)
		local a = _matcher()
		local b = _matcher()
		local c = _matcher()
		expect(a).to.equal("x")
		expect(b).to.equal("y")
		expect(c).to.equal("z")
	end)
	it("should support destructuring from string literals", function()
		local _binding = "xyz"
		local _matcher = string.gmatch(_binding, utf8.charpattern)
		local a = _matcher()
		local b = _matcher()
		local c = _matcher()
		expect(a).to.equal("x")
		expect(b).to.equal("y")
		expect(c).to.equal("z")
	end)
	it("should support object assignment destructuring", function()
		local a = 0
		local b = 0
		local c = 0
		local _binding = {
			a = 4,
			b = 5,
			c = 6,
		}
		a = _binding.a
		b = _binding.b
		c = _binding.c
		expect(a).to.equal(4)
		expect(b).to.equal(5)
		expect(c).to.equal(6)
	end)
	it("should support object assignment destructuring with aliases", function()
		local a = 0
		local b = 0
		local c = 0
		local _binding = {
			x = 4,
			y = 5,
			z = 6,
		}
		a = _binding.x
		b = _binding.y
		c = _binding.z
		expect(a).to.equal(4)
		expect(b).to.equal(5)
		expect(c).to.equal(6)
	end)
	it("should support nested object assignment destructuring", function()
		local obj = {
			a = {
				b = {
					c = {
						d = "NEST!",
					},
				},
			},
		}
		local d = ""
		local _binding = obj
		local _binding_1 = _binding.a
		local _binding_2 = _binding_1.b
		local _binding_3 = _binding_2.c
		d = _binding_3.d
		expect(d).to.equal("NEST!")
	end)
	it("should support nested object assignment destructuring with alias", function()
		local obj = {
			a = {
				b = {
					c = {
						d = "NEST!",
					},
				},
			},
		}
		local str = ""
		local _binding = obj
		local _binding_1 = _binding.a
		local _binding_2 = _binding_1.b
		local _binding_3 = _binding_2.c
		str = _binding_3.d
		expect(str).to.equal("NEST!")
	end)
	it("should support array binding pattern with initializer", function()
		local _binding = {}
		local x = _binding[1]
		if x == nil then
			x = 5
		end
		expect(x).to.equal(5)
	end)
	it("should support array binding literal with omitted expression", function()
		local a = 0
		local b = 0
		a, _, b = 1, 2, 3
		expect(a).to.equal(1)
		expect(b).to.equal(3)
	end)
	it("should support array binding literal with initializer", function()
		local a = 0
		local b = 0
		local _binding = {}
		a = _binding[1]
		if a == nil then
			a = 5
		end
		b = _binding[2]
		if b == nil then
			b = 6
		end
		expect(a).to.equal(5)
		expect(b).to.equal(6)
	end)
	it("should support object binding literal with initializer", function()
		local a = 0
		local b = 0
		local _binding = {}
		a = _binding.a
		if a == nil then
			a = 5
		end
		b = _binding.b
		if b == nil then
			b = 6
		end
		expect(a).to.equal(5)
		expect(b).to.equal(6)
	end)
	it("should support object binding literal with alias and initializer", function()
		local y = 0
		local _binding = {}
		y = _binding.x
		if y == nil then
			y = 5
		end
		expect(y).to.equal(5)
	end)
	it("should destructure assign with nested sets", function()
		local a = ""
		local obj = {
			x = {
				["heck"] = true,
			},
		}
		local _binding = obj
		local _binding_1 = _binding.x
		local _value = next(_binding_1)
		a = _value
		expect(a).to.equal("heck")
	end)
	it("should destructure assign with nested maps", function()
		local a
		local obj = {
			x = {
				heck = 123,
			},
		}
		local _binding = obj
		local _binding_1 = _binding.x
		local _k, _v = next(_binding_1)
		a = { _k, _v }
		expect(a[1]).to.equal("heck")
		expect(a[2]).to.equal(123)
	end)
	it("should destructure assign with nested maps keys and values", function()
		local a
		local b
		local obj = {
			x = {
				heck = 123,
			},
		}
		local _binding = obj
		local _binding_1 = _binding.x
		local _k, _v = next(_binding_1)
		local _binding_2 = { _k, _v }
		a = _binding_2[1]
		b = _binding_2[2]
		expect(a).to.equal("heck")
		expect(b).to.equal(123)
	end)
	it("should destructure assign with double nested maps keys and values", function()
		local a
		local b
		local obj = {
			x = { {
				heck = 123,
			} },
		}
		local _binding = obj
		local _binding_1 = _binding.x
		local _binding_2 = _binding_1[1]
		local _k, _v = next(_binding_2)
		local _binding_3 = { _k, _v }
		a = _binding_3[1]
		b = _binding_3[2]
		expect(a).to.equal("heck")
		expect(b).to.equal(123)
	end)
	it("should destructure assign with double nested sets", function()
		local a
		local obj = {
			x = { {
				["heck"] = true,
			} },
		}
		local _binding = obj
		local _binding_1 = _binding.x
		local _binding_2 = _binding_1[1]
		local _value = next(_binding_2)
		a = _value
		expect(a).to.equal("heck")
	end)
	it("should destructure assign with triple nested sets", function()
		local a
		local obj = {
			x = { {
				["heck"] = true,
			} },
		}
		local _binding = obj
		local _binding_1 = _binding.x
		local _binding_2 = _binding_1[1]
		local _value = next(_binding_2)
		local _binding_3 = _value
		local _matcher = string.gmatch(_binding_3, utf8.charpattern)
		a = _matcher()
		expect(a).to.equal("h")
	end)
	it("should destructure nested generators", function()
		local function foo()
			return TS.generator(function()
				coroutine.yield(1)
				coroutine.yield(2)
				coroutine.yield(3)
			end)
		end
		local obj = {
			x = foo(),
		}
		local a = 0
		local b = 0
		local c = 0
		local _binding = obj
		local _binding_1 = _binding.x
		a = _binding_1.next().value
		b = _binding_1.next().value
		c = _binding_1.next().value
		expect(a).to.equal(1)
		expect(b).to.equal(2)
		expect(c).to.equal(3)
	end)
	it("should destructure double nested generators", function()
		local function foo()
			return TS.generator(function()
				coroutine.yield(1)
				coroutine.yield(2)
				coroutine.yield(3)
			end)
		end
		local obj = {
			x = { foo() },
		}
		local a = 0
		local b = 0
		local c = 0
		local _binding = obj
		local _binding_1 = _binding.x
		local _binding_2 = _binding_1[1]
		a = _binding_2.next().value
		b = _binding_2.next().value
		c = _binding_2.next().value
		expect(a).to.equal(1)
		expect(b).to.equal(2)
		expect(c).to.equal(3)
	end)
	it("should destructure nested strings", function()
		local obj = {
			x = "abc",
		}
		local a = ""
		local b = ""
		local c = ""
		local _binding = obj
		local _binding_1 = _binding.x
		local _matcher = string.gmatch(_binding_1, utf8.charpattern)
		a = _matcher()
		b = _matcher()
		c = _matcher()
		expect(a).to.equal("a")
		expect(b).to.equal("b")
		expect(c).to.equal("c")
	end)
	it("should destructure nested strings 2", function()
		local obj = {
			x = {
				foo = 1,
			},
		}
		local a = ""
		local _binding = obj
		local _binding_1 = _binding.x
		local _k, _v = next(_binding_1)
		local _binding_2 = { _k, _v }
		local _binding_3 = _binding_2[1]
		local _matcher = string.gmatch(_binding_3, utf8.charpattern)
		local _binding_4 = _matcher()
		local _matcher_1 = string.gmatch(_binding_4, utf8.charpattern)
		local _binding_5 = _matcher_1()
		local _matcher_2 = string.gmatch(_binding_5, utf8.charpattern)
		a = _matcher_2()
		expect(a).to.equal("f")
	end)
	it("should get sub type of iterable iterator", function()
		local function foo()
			return TS.generator(function()
				coroutine.yield("abc")
			end)
		end
		local obj = {
			x = foo(),
		}
		local a = ""
		local b = ""
		local c = ""
		local _binding = obj
		local _binding_1 = _binding.x
		local _binding_2 = _binding_1.next().value
		local _matcher = string.gmatch(_binding_2, utf8.charpattern)
		a = _matcher()
		b = _matcher()
		c = _matcher()
		expect(a).to.equal("a")
		expect(b).to.equal("b")
		expect(c).to.equal("c")
	end)
	it("should support empty destructure", function()
		local x = 0
		pcall(function()
			x = 123
			return x
		end)
		expect(x).to.equal(123)
	end)
	it("should support empty destructure assignment", function()
		local x = 0
		pcall(function()
			x = 123
			return x
		end)
		expect(x).to.equal(123)
	end)
	it("should support function destructuring if not a method", function()
		local x = 0
		local a = {
			b = function(param)
				x = param
			end,
		}
		local _binding = a
		local b = _binding.b
		b(123)
		expect(x).to.equal(123)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="305">
        <Properties>
          <string name="Name">enum.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
-- Basic enum test
local Fruits
do
	local _inverse = {}
	Fruits = setmetatable({}, {
		__index = _inverse,
	})
	Fruits.Apple = 0
	_inverse[0] = "Apple"
	Fruits.Orange = 1
	_inverse[1] = "Orange"
	Fruits.Pear = 2
	_inverse[2] = "Pear"
	Fruits["$"] = 3
	_inverse[3] = "$"
end
-- Numeric enum test
local Breads
do
	local _inverse = {}
	Breads = setmetatable({}, {
		__index = _inverse,
	})
	Breads.White = 5
	_inverse[5] = "White"
	Breads.Wheat = 6
	_inverse[6] = "Wheat"
	Breads.Pumpernickel = 7
	_inverse[7] = "Pumpernickel"
	Breads["$"] = 8
	_inverse[8] = "$"
end
-- String enums
local Soups = {
	Tomato = "TOMATO",
	ChickenNoodle = "CHICKENNOODLE",
	Dumpling = "DUMPLING",
	["$"] = "DOLLARS",
}
local EnumWithEscapedQuote = {
	Quote = '"',
}
local function getValue()
	return 123
end
local WithInitializer
do
	local _inverse = {}
	WithInitializer = setmetatable({}, {
		__index = _inverse,
	})
	local _value = getValue()
	WithInitializer.value = _value
	_inverse[_value] = "value"
end
return function()
	it("should expose enums by number", function()
		expect(Fruits[0]).to.equal("Apple")
		expect(Fruits.Orange).to.equal(1)
		expect(Fruits[2]).to.equal("Pear")
	end)
	it("should support overriding indices", function()
		expect(Breads[5]).to.equal("White")
		expect(Breads.Wheat).to.equal(6)
		expect(Breads[0]).never.to.be.ok()
	end)
	it("should support for string indices", function()
		expect(Soups.Tomato).to.equal("TOMATO")
		expect(Soups.ChickenNoodle).to.equal("CHICKENNOODLE")
		expect(Soups.Dumpling).to.equal("DUMPLING")
		expect(Soups["$"]).to.equal("DOLLARS")
	end)
	it("should support numeric const enums", function()
		expect(0).to.equal(0)
		expect(1).to.equal(1)
		expect(2).to.equal(2)
		expect(3).to.equal(3)
		expect(4).to.equal(4)
		expect(5).to.equal(5)
	end)
	it("should support string const enums", function()
		expect("BEAR").to.equal("BEAR")
		expect("DOG").to.equal("DOG")
		expect("SNAKE").to.equal("SNAKE")
		expect("SCARAB").to.equal("SCARAB")
	end)
	it("should support members with initializers", function()
		expect(WithInitializer.value).to.equal(123)
	end)
	local Animal2
	it("should support hoisted enums", function()
		expect(Animal2.Bear).to.equal("BEAR")
		expect(Animal2.Dog).to.equal("DOG")
		expect(Animal2.Snake).to.equal("SNAKE")
	end)
	Animal2 = {
		Bear = "BEAR",
		Dog = "DOG",
		Snake = "SNAKE",
	}
	it("should support enums with escaped quotes", function()
		expect(EnumWithEscapedQuote.Quote).to.equal('"')
	end)
	it("should support const enums with escaped quotes", function()
		expect('"').to.equal('"')
	end)
	it("should support computed keys", function()
		local constKeyIndex = 4
		local constKeyValue = 7
		local ConstComputedKey
		do
			local _inverse = {}
			ConstComputedKey = setmetatable({}, {
				__index = _inverse,
			})
			ConstComputedKey[constKeyIndex] = constKeyValue
			_inverse[constKeyValue] = constKeyIndex
		end
		expect(ConstComputedKey[4]).to.equal(7)
		local computedKeyIndex = 1
		local ComputedKey
		do
			local _inverse = {}
			ComputedKey = setmetatable({}, {
				__index = _inverse,
			})
			local _original = computedKeyIndex
			computedKeyIndex += 1
			ComputedKey[_original] = computedKeyIndex
			_inverse[computedKeyIndex] = _original
		end
		expect(ComputedKey[1]).to.equal(2)
		expect(computedKeyIndex).to.equal(2)
		local computedValueIndex = 3
		local PrereqInValue
		do
			local _inverse = {}
			PrereqInValue = setmetatable({}, {
				__index = _inverse,
			})
			local _computedValueIndex = computedValueIndex
			computedValueIndex = 6
			PrereqInValue[_computedValueIndex] = computedValueIndex
			_inverse[computedValueIndex] = _computedValueIndex
		end
		expect(PrereqInValue[3]).to.equal(6)
		expect(computedValueIndex).to.equal(6)
		local obj = {
			prop = 8,
		}
		local PrereqValueReference
		do
			local _inverse = {}
			PrereqValueReference = setmetatable({}, {
				__index = _inverse,
			})
			local _prop = obj.prop
			obj.prop = 6
			local _value = (obj.prop)
			PrereqValueReference[_prop] = _value
			_inverse[_value] = _prop
		end
		expect(PrereqValueReference[8]).to.equal(6)
		expect(obj.prop).to.equal(6)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="306">
        <Properties>
          <string name="Name">exportLet.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local y = 0
local Foo = {}
do
	local _container = Foo
	_container.x = 1
	y = _container.x
end
local Bar = {}
do
	local _container = Bar
	local plr = {
		ClassName = "Player",
		Name = "Validark",
	}
	local _binding = plr
	local a = _binding.ClassName
	_container.a = a
	local _binding_1 = plr
	_container.b = _binding_1.ClassName
	_container.c = _binding_1.Name
	local _binding_2 = plr
	_container.ClassName = _binding_2.ClassName
	_container.Name = _binding_2.Name
end
return function()
	it("should allow mutatable exports", function()
		expect(Foo.x).to.equal(1)
		Foo.x = 2
		expect(Foo.x).to.equal(2)
		expect(y).to.equal(1)
	end)
	it("should allow destructured let exports", function()
		-- const check
		expect(Bar.a).to.equal("Player")
		expect(Bar.ClassName).to.equal("Player")
		Bar.ClassName = "Attacker"
		expect(Bar.ClassName).to.equal("Attacker")
		expect(Bar.Name).to.equal("Validark")
		expect(Bar.b).to.equal("Player")
		expect(Bar.c).to.equal("Validark")
		Bar.b = "Nope"
		Bar.c = "Osyris"
		expect(Bar.b).to.equal("Nope")
		expect(Bar.c).to.equal("Osyris")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="307">
        <Properties>
          <string name="Name">function.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
local N = {}
do
	local _container = N
	local a = function(self, n)
		return n
	end
	_container.a = a
	local b = function(n)
		return n
	end
	_container.b = b
	local c = function(n)
		return n
	end
	_container.c = c
	local d = function(n)
		return n
	end
	_container.d = d
	local function e(self, n)
		return n
	end
	_container.e = e
	local function f(n)
		return n
	end
	_container.f = f
	local function g(n)
		return n
	end
	_container.g = g
end
return function()
	it("should support function declarations", function()
		local function foo()
			return true
		end
		expect(foo()).to.be.ok()
	end)
	it("should support function arguments", function()
		local function add(a, b)
			return a + b
		end
		expect(add(123, 456)).to.equal(579)
	end)
	it("should support no return value", function()
		local function doStuff(doIHaveToMom)
			if doIHaveToMom then
				return "cleans room"
			else
				return nil
			end
		end
		expect(doStuff(true)).to.equal("cleans room")
		expect(doStuff(false)).never.to.be.ok()
	end)
	it("should support destructuring in assignment", function()
		local function addAndMultiply(a, b)
			local sum = a + b
			local product = a * b
			return { sum, product }
		end
		local _binding = addAndMultiply(5, 6)
		local x = _binding[1]
		local y = _binding[2]
		expect(x).to.equal(11)
		expect(y).to.equal(30)
	end)
	it("should support variadic arguments", function()
		local function addAll(...)
			local n = { ... }
			local sum = 0
			for _, value in n do
				sum += value
			end
			return sum
		end
		expect(addAll()).to.equal(0)
		expect(addAll(1)).to.equal(1)
		expect(addAll(1, 2, 3)).to.equal(6)
	end)
	it("should support default arguments", function()
		local function addSeven(n)
			if n == nil then
				n = 5
			end
			return n + 7
		end
		expect(addSeven()).to.equal(12)
		expect(addSeven(7)).to.equal(14)
	end)
	it("should support function expressions", function()
		expect((function()
			return 123
		end)()).to.equal(123)
	end)
	it("should support arrow functions", function()
		expect((function()
			return 456
		end)()).to.equal(456)
	end)
	it("should support binding patterns", function()
		local function foo(_param)
			local a = _param.a
			return a * 2
		end
		expect(foo({
			a = 4,
		})).to.equal(8)
		local function bar(_param)
			local a = _param[1]
			local b = _param[2]
			return a * b
		end
		expect(bar({ 4, 7 })).to.equal(28)
	end)
	it("should support this parameter", function()
		local function foo(x, y, z)
			return tostring(x) .. (", " .. (tostring(y) .. (", " .. tostring(z))))
		end
		expect(foo(1, 2, 3)).to.equal("1, 2, 3")
	end)
	it("should properly define and call methods vs callbacks", function()
		local A
		do
			A = setmetatable({}, {
				__tostring = function()
					return "A"
				end,
			})
			A.__index = A
			function A.new(...)
				local self = setmetatable({}, A)
				return self:constructor(...) or self
			end
			function A:constructor()
				self.e = function(n)
					expect(n).to.equal(5)
				end
				self.f = function(self, n)
					expect(TS.instanceof(self, A)).to.equal(true)
					expect(n).to.equal(5)
				end
				self.g = function(n)
					expect(n).to.equal(5)
				end
			end
			function A.a(n)
				expect(self).to.equal(nil)
				expect(n).to.equal(5)
			end
			function A:b(n)
				expect(self).to.equal(A)
				expect(n).to.equal(5)
			end
			function A:c(n)
				expect(n).to.equal(5)
			end
			function A.d(n)
				expect(self).to.equal(nil)
				expect(n).to.equal(5)
			end
			function A:h(n)
				expect(TS.instanceof(self, A)).to.equal(true)
				expect(n).to.equal(5)
			end
		end
		local o
		o = {
			a = function(n)
				expect(self).to.equal(nil)
				expect(n).to.equal(5)
			end,
			b = function(self, n)
				expect(self).to.equal(o)
				expect(n).to.equal(5)
			end,
			c = function(n)
				expect(self).to.equal(nil)
				expect(n).to.equal(5)
			end,
			d = function(self, n)
				expect(self).to.equal(o)
				expect(n).to.equal(5)
			end,
			e = function(n)
				expect(n).to.equal(5)
			end,
			f = function(self, n)
				expect(self).to.equal(o)
				expect(n).to.equal(5)
			end,
			g = function(self, n)
				expect(self).to.equal(o)
				expect(n).to.equal(5)
			end,
		}
		local function f(n)
			-- expect(this).to.equal(undefined);
			expect(n).to.equal(5)
		end
		local g = function(n)
			-- expect(this).to.equal(undefined);
			expect(n).to.equal(5)
		end
		A.a(5)
		A:b(5)
		A:c(5)
		local a = A.new()
		a.d(5)
		a.e(5)
		a:f(5)
		a.g(5)
		a:h(5)
		o.a(5)
		o:b(5)
		o.c(5)
		o:d(5)
		o.e(5)
		o:f(5)
		o:g(5)
		expect(N:a(5)).to.equal(5)
		expect(N.b(5)).to.equal(5)
		expect(N.c(5)).to.equal(5)
		expect(N.d(5)).to.equal(5)
		expect(N:e(5)).to.equal(5)
		expect(N.f(5)).to.equal(5)
		expect(N.g(5)).to.equal(5)
		f(5)
		g(5);
		(function(n)
			expect(n).to.equal(5)
		end)(5);
		({
			x = function(self, n)
				expect(n).to.equal(5)
			end,
		}):x(5);
		({
			x = function(n)
				expect(n).to.equal(5)
			end,
		}).x(5);
		({
			x = function(self, n)
				expect(n).to.equal(5)
			end,
		}):x(5);
		(function(n)
			expect(n).to.equal(5)
		end)(5)
		local obj = {
			saferNum = function(n)
				return if n == n and n > 0 then n else 0
			end,
		}
		local _binding = obj
		local saferNum = _binding.saferNum
		expect(saferNum(5)).to.equal(5)
	end)
	it("should optimize array spread paramters", function()
		local function foo(a, b, c)
			return { a, b, c }
		end
		local result = foo(123, "abc", true)
		expect(result[1]).to.equal(123)
		expect(result[2]).to.equal("abc")
		expect(result[3]).to.equal(true)
	end)
	it("should protect against void values passed into built-in functions", function()
		local function foo()
		end
		expect(tonumber((foo()))).to.equal(nil)
	end)
	it("should not wrap argument spread expressions in parentheses", function()
		local args = { "123", "456" }
		expect((select(2, select(1, unpack(args))))).to.equal("456")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="308">
        <Properties>
          <string name="Name">hoist.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support variable hoisting", function()
		local x
		local function test()
			expect(x).to.equal(1)
		end
		x = 1
		test()
	end)
	it("should hoist classes", function()
		local Foo
		local function test()
			local foo = Foo.new()
			expect(foo:bar()).to.equal("baz")
		end
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
			function Foo:bar()
				return "baz"
			end
		end
		test()
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="309">
        <Properties>
          <string name="Name">if.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support if statements", function()
		local function foo(n)
			if n < 5 then
				return "bar"
			elseif n < 10 then
				return "foo"
			else
				return "baz"
			end
		end
		expect(foo(9)).to.equal("foo")
		expect(foo(4)).to.equal("bar")
		expect(foo(11)).to.equal("baz")
	end)
	it("should support prereqs in elseif", function()
		local array = { 1 }
		if true then
		else
			-- ▼ Array.pop ▼
			local _length = #array
			local _result = array[_length]
			array[_length] = nil
			-- ▲ Array.pop ▲
			if _result == 1 then
			end
		end
		expect(#array).to.equal(1)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="310">
        <Properties>
          <string name="Name">instanceof.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
return function()
	it("should support instanceof", function()
		local Foo
		do
			Foo = setmetatable({}, {
				__tostring = function()
					return "Foo"
				end,
			})
			Foo.__index = Foo
			function Foo.new(...)
				local self = setmetatable({}, Foo)
				return self:constructor(...) or self
			end
			function Foo:constructor()
			end
		end
		local Bar
		do
			local super = Foo
			Bar = setmetatable({}, {
				__tostring = function()
					return "Bar"
				end,
				__index = super,
			})
			Bar.__index = Bar
			function Bar.new(...)
				local self = setmetatable({}, Bar)
				return self:constructor(...) or self
			end
			function Bar:constructor(...)
				super.constructor(self, ...)
			end
		end
		local Baz
		do
			Baz = setmetatable({}, {
				__tostring = function()
					return "Baz"
				end,
			})
			Baz.__index = Baz
			function Baz.new(...)
				local self = setmetatable({}, Baz)
				return self:constructor(...) or self
			end
			function Baz:constructor()
			end
		end
		local foo = Foo.new()
		expect(TS.instanceof(foo, Foo)).to.equal(true)
		expect(TS.instanceof(foo, Bar)).to.equal(false)
		expect(TS.instanceof(foo, Baz)).to.equal(false)
		local bar = Bar.new()
		expect(TS.instanceof(bar, Foo)).to.equal(true)
		expect(TS.instanceof(bar, Bar)).to.equal(true)
		expect(TS.instanceof(bar, Baz)).to.equal(false)
		local baz = Baz.new()
		expect(TS.instanceof(baz, Foo)).to.equal(false)
		expect(TS.instanceof(baz, Bar)).to.equal(false)
		expect(TS.instanceof(baz, Baz)).to.equal(true)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="311">
        <Properties>
          <string name="Name">literal.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should understand number literals", function()
		expect(1).to.equal(1)
		expect(6).to.equal(6)
		expect(0xf00d).to.equal(61453)
		expect(0b1010).to.equal(10)
		expect(484).to.equal(484)
		-- issue #213
		expect(0.0000000000001).never.to.equal(1)
		expect(100000000000000).never.to.equal(1)
		-- We should compare numbers, not strings
		expect(tonumber(tostring(0.0000000000001))).to.equal(tonumber("1e-13"))
		expect(tonumber(tostring(100000000000000))).to.equal(tonumber("1e+14"))
		expect(1_0_0_0_0).to.equal(10000)
	end)
	it("should add numbers", function()
		expect(1 + 1).to.equal(2)
		local a = 1
		local b = 1
		expect(a + b).to.equal(2)
	end)
	-- prettier-ignore
	it("should understand string literals", function()
		expect("foo").to.equal("foo")
		expect("foo").to.equal("foo")
		expect("foo").to.equal("foo")
		expect(#"foo").to.equal(3)
		expect(#"foo").to.equal(3)
		expect(#"foo").to.equal(3)
		expect('\"').to.equal('\"')
		expect('\"').to.equal('\"')
		expect('\"').to.equal('\"')
		expect('"').to.equal('\"')
		expect('"').to.equal('\"')
	end)
	it("should add strings", function()
		expect("a" .. "b").to.equal("ab")
		local a = "a"
		local b = "b"
		expect(a .. b).to.equal("ab")
	end)
	it("should add numbers and strings", function()
		local a = "2"
		local b = 1
		expect(a .. tostring(b)).to.equal("21")
		expect(tostring(b) .. a).to.equal("12")
	end)
	it("should support ===", function()
		local a = (function()
			return false
		end)()
		local b = (function()
			return true
		end)()
		expect(a == a).to.equal(true)
		expect(a == b).to.equal(false)
		expect(b == b).to.equal(true)
		expect(b == a).to.equal(false)
	end)
	it("should support !==", function()
		local a = (function()
			return false
		end)()
		local b = (function()
			return true
		end)()
		expect(a ~= a).to.equal(false)
		expect(a ~= b).to.equal(true)
		expect(b ~= b).to.equal(false)
		expect(b ~= a).to.equal(true)
	end)
	it("should support &&", function()
		local a = false
		local b = true
		expect(a and a).to.equal(false)
		expect(a and b).to.equal(false)
		expect(b and b).to.equal(true)
		expect(b and a).to.equal(false)
	end)
	it("should support ||", function()
		local a = false
		local b = true
		expect(a or a).to.equal(false)
		expect(a or b).to.equal(true)
		expect(b or b).to.equal(true)
		expect(b or a).to.equal(true)
	end)
	it("should support `in`", function()
		local foo = {
			a = 1,
		}
		expect(foo.a ~= nil).to.equal(true)
		expect(foo.b ~= nil).to.equal(false)
	end)
	it("should support <", function()
		expect(1 < 2).to.equal(true)
		expect(2 < 1).to.equal(false)
		expect(2 < 2).to.equal(false)
	end)
	it("should support >", function()
		expect(1 > 2).to.equal(false)
		expect(2 > 1).to.equal(true)
		expect(2 > 2).to.equal(false)
	end)
	it("should support <=", function()
		expect(1 <= 2).to.equal(true)
		expect(2 <= 1).to.equal(false)
		expect(2 <= 2).to.equal(true)
	end)
	it("should support >=", function()
		expect(1 >= 2).to.equal(false)
		expect(2 >= 1).to.equal(true)
		expect(2 >= 2).to.equal(true)
	end)
	it("should support !", function()
		expect(not false).to.equal(true)
		expect(not true).to.equal(false)
	end)
	it("should allow postfix operators on properties", function()
		local obj = {
			x = 0,
		}
		expect(obj.x).to.equal(0)
		obj.x += 1
		expect(obj.x).to.equal(1)
		obj.x -= 1
		expect(obj.x).to.equal(0)
		local _original = obj.x
		obj.x += 1
		expect(_original).to.equal(0)
		expect(obj.x).to.equal(1)
		local _original_1 = obj.x
		obj.x -= 1
		expect(_original_1).to.equal(1)
		expect(obj.x).to.equal(0)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="312">
        <Properties>
          <string name="Name">loop.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local function difference(set1, set2)
	local result = {}
	for value in set1 do
		if not (set2[value] ~= nil) then
			result[value] = true
		end
	end
	for value in set2 do
		if not (set1[value] ~= nil) then
			result[value] = true
		end
	end
	return result
end
return function()
	it("should support numeric for loops", function()
		local hit = {}
		local sum = 10
		for i = 0, 9 do
			local _i = i
			hit[_i] = true
			sum -= 1
		end
		expect(sum).to.equal(0)
		expect(hit[0] ~= nil).to.equal(true)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
		expect(hit[4] ~= nil).to.equal(true)
		expect(hit[5] ~= nil).to.equal(true)
		expect(hit[6] ~= nil).to.equal(true)
		expect(hit[7] ~= nil).to.equal(true)
		expect(hit[8] ~= nil).to.equal(true)
		expect(hit[9] ~= nil).to.equal(true)
	end)
	it("should support optimized simple loops #1", function()
		local hit = {}
		local n = 0
		for i = 1, 3 do
			local _i = i
			hit[_i] = true
			n += 1
		end
		expect(n).to.equal(3)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
	end)
	it("should support optimized simple loops #2", function()
		local hit = {}
		local n = 0
		for i = 3, 1, -1 do
			local _i = i
			hit[_i] = true
			n += 1
		end
		expect(n).to.equal(3)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
	end)
	it("should support optimized simple loops #3", function()
		local hit = {}
		local n = 0
		do
			local i = 1
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i = i + 1
				else
					_shouldIncrement = true
				end
				if not (i <= 3) then
					break
				end
				local _i = i
				hit[_i] = true
				n += 1
			end
		end
		expect(n).to.equal(3)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
	end)
	it("should support optimized simple loops #4", function()
		local hit = {}
		local n = 0
		do
			local i = 3
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i = i - 1
				else
					_shouldIncrement = true
				end
				if not (i >= 1) then
					break
				end
				local _i = i
				hit[_i] = true
				n += 1
			end
		end
		expect(n).to.equal(3)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
	end)
	it("should support optimized simple loops #5", function()
		local hit = {}
		local n = 0
		for i = 1, 3 do
			local _i = i
			hit[_i] = true
			n += 1
		end
		expect(n).to.equal(3)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
	end)
	it("should support optimized simple loops #6", function()
		local hit = {}
		local limit = 1
		local n = 0
		for i = 3, limit, -1 do
			local _i = i
			hit[_i] = true
			n += 1
		end
		expect(n).to.equal(3)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
	end)
	it("should support optimized simple loops #7", function()
		local hit = {}
		local limit = 1
		local n = 0
		do
			local i = 3
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i -= 1
				else
					_shouldIncrement = true
				end
				if not (i <= limit) then
					break
				end
				local _i = i
				hit[_i] = true
				n += 1
			end
		end
		expect(n).to.equal(0)
		expect(hit[1] ~= nil).to.equal(false)
		expect(hit[2] ~= nil).to.equal(false)
		expect(hit[3] ~= nil).to.equal(false)
		for i = 3, limit, -1 do
			local _i = i
			hit[_i] = true
			n += 1
		end
		expect(n).to.equal(3)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
	end)
	it("should support optimized simple loops #8", function()
		local hit = {}
		local n = 0
		do
			local i = 3
			local _shouldIncrement = false
			while true do
				if _shouldIncrement then
					i -= 1
				else
					_shouldIncrement = true
				end
				if not (i <= 1) then
					break
				end
				local _i = i
				hit[_i] = true
				n += 1
			end
		end
		expect(n).to.equal(0)
		expect(hit[1] ~= nil).to.equal(false)
		expect(hit[2] ~= nil).to.equal(false)
		expect(hit[3] ~= nil).to.equal(false)
		for i = 3, 1, -1 do
			local _i = i
			hit[_i] = true
			n += 1
		end
		expect(n).to.equal(3)
		expect(hit[1] ~= nil).to.equal(true)
		expect(hit[2] ~= nil).to.equal(true)
		expect(hit[3] ~= nil).to.equal(true)
	end)
	it("should support for-of loops over arrays", function()
		local hit = {}
		local array = { "1", "2", "3", "4" }
		local n = 0
		for _, v in array do
			hit[v] = true
			n += 1
		end
		expect(n).to.equal(4)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support for-of loops over array literals", function()
		local hit = {}
		local n = 0
		for _, v in { "1", "2", "3", "4" } do
			hit[v] = true
			n += 1
		end
		expect(n).to.equal(4)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support for-of loops over string literals", function()
		local hit = {}
		local n = 0
		for v in string.gmatch("1234", utf8.charpattern) do
			hit[v] = true
			n += 1
		end
		expect(n).to.equal(4)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support for-of loops over strings", function()
		local hit = {}
		local str = "1234"
		local n = 0
		for v in string.gmatch(str, utf8.charpattern) do
			hit[v] = true
			n += 1
		end
		expect(n).to.equal(4)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support for-of loops over computed strings", function()
		local i = 0
		for letter in string.gmatch(tostring(i) .. "s", utf8.charpattern) do
		end
	end)
	it("should support for-of loops over Set literals", function()
		local hit = {}
		local n = 0
		for v in {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		} do
			hit[v] = true
			n += 1
		end
		expect(n).to.equal(4)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support for-of loops over Sets", function()
		local hit = {}
		local set = {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		}
		local n = 0
		for v in set do
			hit[v] = true
			n += 1
		end
		expect(n).to.equal(4)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support for-of loops over Map literals", function()
		local hit = {}
		local n = 0
		for _k, _v in {
			["1"] = "2",
			["3"] = "4",
		} do
			local v = { _k, _v }
			local _arg0 = v[1]
			hit[_arg0] = true
			local _arg0_1 = v[2]
			hit[_arg0_1] = true
			n += 1
		end
		expect(n).to.equal(2)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support for-of loops over Maps", function()
		local hit = {}
		local map = {
			["1"] = "2",
			["3"] = "4",
		}
		local n = 0
		for _k, _v in map do
			local v = { _k, _v }
			local _arg0 = v[1]
			hit[_arg0] = true
			local _arg0_1 = v[2]
			hit[_arg0_1] = true
			n += 1
		end
		expect(n).to.equal(2)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support optimized destructuring in for-of loops over Maps", function()
		local hit = {}
		local map = {
			["1"] = "2",
			["3"] = "4",
		}
		local n = 0
		for k, v in map do
			hit[k] = true
			hit[v] = true
			n += 1
		end
		expect(n).to.equal(2)
		expect(next(difference(hit, {
			["1"] = true,
			["2"] = true,
			["3"] = true,
			["4"] = true,
		})) == nil).to.equal(true)
	end)
	it("should support destructuring optimized destructuring in for-of loops over Maps", function()
		local n = 0
		for _binding, _binding_1 in {
			[{ "1", "2" }] = { "3", "4" },
		} do
			local i = _binding[1]
			local j = _binding[2]
			local k = _binding_1[1]
			local v = _binding_1[2]
			expect(i).to.equal("1")
			expect(j).to.equal("2")
			expect(k).to.equal("3")
			expect(v).to.equal("4")
			n += 1
		end
		expect(n).to.equal(1)
	end)
	it("should support break", function()
		local array = { 1, 2, 3, 4, 5 }
		local sum = 0
		for _, value in array do
			sum += value
			if value == 3 then
				break
			end
		end
		expect(sum).to.equal(6)
	end)
	it("should support continue", function()
		local array = { 1, 2, 3, 4 }
		local sum = 0
		for _, value in array do
			if value == 3 then
				continue
			end
			sum += value
		end
		expect(sum).to.equal(7)
	end)
	it("should support continue with numeric loops", function()
		local x = 0
		for i = 0, 9 do
			if i % 2 == 0 then
				continue
			end
			x += 1
		end
		expect(x).to.equal(5)
	end)
	it("should support do-while loops", function()
		local x = 0
		repeat
			do
				x += 5
			end
		until not (x < 25)
		expect(x).to.equal(25)
		local function expect0(y)
			expect(y).to.equal(0)
			return false
		end
		local y = 0
		repeat
			do
				local y = 1
				expect(y).to.equal(1)
			end
		until not expect0(y)
	end)
	it("should support while loops", function()
		local x = 0
		while x < 10 do
			x += 1
		end
		expect(x).to.equal(10)
	end)
	it("should support for-of destructuring", function()
		local arr = { {
			a = 1,
			b = 2,
			c = 3,
		} }
		for _, _binding in arr do
			local a = _binding.a
			local b = _binding.b
			local c = _binding.c
			expect(a).to.equal(1)
			expect(b).to.equal(2)
			expect(c).to.equal(3)
		end
	end)
	it("should work with gmatch", function()
		for a in string.gmatch("H", ".") do
			expect(a).to.equal("H")
		end
		for a, b, c, d in string.gmatch("Hello!", "(%l)(%l)(%l)(%l)") do
			expect(a).to.equal("e")
			expect(b).to.equal("l")
			expect(c).to.equal("l")
			expect(d).to.equal("o")
		end
	end)
	it("should support indexing tuple as array", function()
		local obj = {
			a = 1,
			b = 2,
			c = 3,
		}
		for _element, _element_1 in pairs(obj) do
			local tuple = { _element, _element_1 }
			expect(tuple[2]).to.equal(obj[tuple[1]])
		end
	end)
	it("should support iterator function with single return when indexing tuple as array", function()
		local shortIterator = (function()
			return true
		end)
		for _element in shortIterator do
			local tuple = { _element }
			expect(#tuple).to.equal(1)
			break
		end
	end)
	it("should support iterator function with multiple returns when indexing tuple as array", function()
		local longIterator = (function()
			return true, true, true, true, true, true
		end)
		for _element, _element_1, _element_2, _element_3, _element_4, _element_5 in longIterator do
			local tuple = { _element, _element_1, _element_2, _element_3, _element_4, _element_5 }
			expect(#tuple).to.equal(6)
			break
		end
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="313">
        <Properties>
          <string name="Name">macro_math.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support CFrame * CFrame = CFrame", function()
		local a = CFrame.new(3, 7, 9)
		local b = CFrame.new(1, 2, 3)
		local c = a * b
		expect(typeof(c) == "CFrame").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(9)
		expect(c.Z).to.equal(12)
	end)
	it("should support CFrame * Vector3 = Vector3", function()
		local a = CFrame.new(3, 7, 9)
		local b = Vector3.new(1, 2, 3)
		local c = a * b
		expect(typeof(c) == "Vector3").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(9)
		expect(c.Z).to.equal(12)
	end)
	it("should support CFrame + Vector3 = CFrame", function()
		local a = CFrame.new(3, 7, 9)
		local b = Vector3.new(1, 2, 3)
		local c = a + b
		expect(typeof(c) == "CFrame").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(9)
		expect(c.Z).to.equal(12)
	end)
	it("should support CFrame - Vector3 = CFrame", function()
		local a = CFrame.new(3, 7, 9)
		local b = Vector3.new(1, 2, 3)
		local c = a - b
		expect(typeof(c) == "CFrame").to.equal(true)
		expect(c.X).to.equal(2)
		expect(c.Y).to.equal(5)
		expect(c.Z).to.equal(6)
	end)
	it("should support UDim + UDim = UDim", function()
		local a = UDim.new(1, 2)
		local b = UDim.new(3, 4)
		local c = a + b
		expect(typeof(c) == "UDim").to.equal(true)
		expect(c.Scale).to.equal(4)
		expect(c.Offset).to.equal(6)
	end)
	it("should support UDim - UDim = UDim", function()
		local a = UDim.new(1, 2)
		local b = UDim.new(3, 4)
		local c = a - b
		expect(typeof(c) == "UDim").to.equal(true)
		expect(c.Scale).to.equal(-2)
		expect(c.Offset).to.equal(-2)
	end)
	it("should support UDim2 + UDim2 = UDim2", function()
		local a = UDim2.new(1, 2, 3, 4)
		local b = UDim2.new(1, 1, 1, 1)
		local c = a + b
		expect(typeof(c) == "UDim2").to.equal(true)
		expect(c.X.Scale).to.equal(2)
		expect(c.X.Offset).to.equal(3)
		expect(c.Y.Scale).to.equal(4)
		expect(c.Y.Offset).to.equal(5)
	end)
	it("should support UDim2 - UDim2 = UDim2", function()
		local a = UDim2.new(1, 2, 3, 4)
		local b = UDim2.new(1, 1, 1, 1)
		local c = a - b
		expect(typeof(c) == "UDim2").to.equal(true)
		expect(c.X.Scale).to.equal(0)
		expect(c.X.Offset).to.equal(1)
		expect(c.Y.Scale).to.equal(2)
		expect(c.Y.Offset).to.equal(3)
	end)
	it("should support Vector2 + Vector2 = Vector2", function()
		local a = Vector2.new(1, 2)
		local b = Vector2.new(3, 4)
		local c = a + b
		expect(typeof(c) == "Vector2").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(6)
	end)
	it("should support Vector2 - Vector2 = Vector2", function()
		local a = Vector2.new(1, 2)
		local b = Vector2.new(3, 4)
		local c = a - b
		expect(typeof(c) == "Vector2").to.equal(true)
		expect(c.X).to.equal(-2)
		expect(c.Y).to.equal(-2)
	end)
	it("should support Vector2 * Vector2 = Vector2", function()
		local a = Vector2.new(1, 2)
		local b = Vector2.new(3, 4)
		local c = a * b
		expect(typeof(c) == "Vector2").to.equal(true)
		expect(c.X).to.equal(3)
		expect(c.Y).to.equal(8)
	end)
	it("should support Vector2 * number = Vector2", function()
		local a = Vector2.new(1, 2)
		local b = 2
		local c = a * b
		expect(typeof(c) == "Vector2").to.equal(true)
		expect(c.X).to.equal(2)
		expect(c.Y).to.equal(4)
	end)
	it("should support Vector2 / Vector2 = Vector2", function()
		local a = Vector2.new(8, 4)
		local b = Vector2.new(2, 2)
		local c = a / b
		expect(typeof(c) == "Vector2").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(2)
	end)
	it("should support Vector2 / number = Vector2", function()
		local a = Vector2.new(8, 4)
		local b = 2
		local c = a / b
		expect(typeof(c) == "Vector2").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(2)
	end)
	it("should support Vector2int16 + Vector2int16 = Vector2int16", function()
		local a = Vector2int16.new(1, 2)
		local b = Vector2int16.new(3, 4)
		local c = a + b
		expect(typeof(c) == "Vector2int16").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(6)
	end)
	it("should support Vector2int16 - Vector2int16 = Vector2int16", function()
		local a = Vector2int16.new(3, 4)
		local b = Vector2int16.new(1, 4)
		local c = a - b
		expect(typeof(c) == "Vector2int16").to.equal(true)
		expect(c.X).to.equal(2)
		expect(c.Y).to.equal(0)
	end)
	it("should support Vector2int16 * Vector2int16 = Vector2int16", function()
		local a = Vector2int16.new(1, 2)
		local b = Vector2int16.new(3, 4)
		local c = a * b
		expect(typeof(c) == "Vector2int16").to.equal(true)
		expect(c.X).to.equal(3)
		expect(c.Y).to.equal(8)
	end)
	it("should support Vector2int16 / Vector2int16 = Vector2int16", function()
		local a = Vector2int16.new(2, 4)
		local b = Vector2int16.new(2, 2)
		local c = a / b
		expect(typeof(c) == "Vector2int16").to.equal(true)
		expect(c.X).to.equal(1)
		expect(c.Y).to.equal(2)
	end)
	it("should support Vector3 + Vector3 = Vector3", function()
		local a = Vector3.new(1, 2, 3)
		local b = Vector3.new(4, 5, 6)
		local c = a + b
		expect(typeof(c) == "Vector3").to.equal(true)
		expect(c.X).to.equal(5)
		expect(c.Y).to.equal(7)
		expect(c.Z).to.equal(9)
	end)
	it("should support Vector3 - Vector3 = Vector3", function()
		local a = Vector3.new(1, 2, 3)
		local b = Vector3.new(0, 1, 0)
		local c = a - b
		expect(typeof(c) == "Vector3").to.equal(true)
		expect(c.X).to.equal(1)
		expect(c.Y).to.equal(1)
		expect(c.Z).to.equal(3)
	end)
	it("should support Vector3 * Vector3 = Vector3", function()
		local a = Vector3.new(1, 2, 3)
		local b = Vector3.new(4, 5, 6)
		local c = a * b
		expect(typeof(c) == "Vector3").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(10)
		expect(c.Z).to.equal(18)
	end)
	it("should support Vector3 * number = Vector3", function()
		local a = Vector3.new(1, 2, 3)
		local b = 2
		local c = a * b
		expect(typeof(c) == "Vector3").to.equal(true)
		expect(c.X).to.equal(2)
		expect(c.Y).to.equal(4)
		expect(c.Z).to.equal(6)
	end)
	it("should support Vector3 / Vector3 = Vector3", function()
		local a = Vector3.new(4, 6, 8)
		local b = Vector3.new(2, 2, 2)
		local c = a / b
		expect(typeof(c) == "Vector3").to.equal(true)
		expect(c.X).to.equal(2)
		expect(c.Y).to.equal(3)
		expect(c.Z).to.equal(4)
	end)
	it("should support Vector3 / number = Vector3", function()
		local a = Vector3.new(2, 4, 6)
		local b = 2
		local c = a / b
		expect(typeof(c) == "Vector3").to.equal(true)
		expect(c.X).to.equal(1)
		expect(c.Y).to.equal(2)
		expect(c.Z).to.equal(3)
	end)
	it("should support Vector3int16 + Vector3int16 = Vector3int16", function()
		local a = Vector3int16.new(1, 2, 3)
		local b = Vector3int16.new(4, 5, 6)
		local c = a + b
		expect(typeof(c) == "Vector3int16").to.equal(true)
		expect(c.X).to.equal(5)
		expect(c.Y).to.equal(7)
		expect(c.Z).to.equal(9)
	end)
	it("should support Vector3int16 - Vector3int16 = Vector3int16", function()
		local a = Vector3int16.new(1, 2, 3)
		local b = Vector3int16.new(4, 5, 6)
		local c = a - b
		expect(typeof(c) == "Vector3int16").to.equal(true)
		expect(c.X).to.equal(-3)
		expect(c.Y).to.equal(-3)
		expect(c.Z).to.equal(-3)
	end)
	it("should support Vector3int16 * Vector3int16 = Vector3int16", function()
		local a = Vector3int16.new(1, 2, 3)
		local b = Vector3int16.new(4, 5, 6)
		local c = a * b
		expect(typeof(c) == "Vector3int16").to.equal(true)
		expect(c.X).to.equal(4)
		expect(c.Y).to.equal(10)
		expect(c.Z).to.equal(18)
	end)
	it("should support Vector3int16 / Vector3int16 = Vector3int16", function()
		local a = Vector3int16.new(2, 4, 6)
		local b = Vector3int16.new(2, 2, 2)
		local c = a / b
		expect(typeof(c) == "Vector3int16").to.equal(true)
		expect(c.X).to.equal(1)
		expect(c.Y).to.equal(2)
		expect(c.Z).to.equal(3)
	end)
	it("should properly support roblox math macros with binary expressions", function()
		local a = Vector2.new(1, 2) * (1 + 3)
		expect(a.X).to.equal(4)
		expect(a.Y).to.equal(8)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="314">
        <Properties>
          <string name="Name">map.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support map constructor", function()
		local map = {
			foo = 1,
			bar = 2,
			baz = 3,
		}
		expect(map.foo).to.equal(1)
		expect(map.bar).to.equal(2)
		expect(map.baz).to.equal(3)
	end)
	it("should support weak maps", function()
		local map = setmetatable({}, {
			__mode = "k",
		})
		local f = Instance.new("Frame")
		map[f] = "foo"
		expect(map[f]).to.equal("foo")
	end)
	it("should support get and set", function()
		local _exp = {}
		_exp.a = 1
		_exp.b = 2
		_exp.c = 3
		local map = _exp
		local _ = map.a
		expect(map.a).to.equal(1)
		expect(map.b).to.equal(2)
		expect(map.c).to.equal(3)
		map.d = 4
		expect(map).to.equal(map)
		map.e = 5
		expect(map.e).to.equal(5)
	end)
	it("should support has", function()
		local _exp = {}
		_exp.a = 1
		_exp.b = 2
		_exp.c = 3
		local map = _exp
		local _ = map.a ~= nil
		expect(map.a ~= nil).to.equal(true)
		expect(map.b ~= nil).to.equal(true)
		expect(map.c ~= nil).to.equal(true)
		expect(map.d ~= nil).to.equal(false)
	end)
	it("should support delete", function()
		local _exp = {}
		_exp.a = 1
		_exp.b = 2
		_exp.c = 3
		local map = _exp
		-- ▼ Map.delete ▼
		local _valueExisted = map.a ~= nil
		map.a = nil
		-- ▲ Map.delete ▲
		local hadA = _valueExisted
		expect(hadA).to.equal(true)
		expect(map.a).never.to.be.ok()
	end)
	it("should support size", function()
		local _exp = {}
		_exp.a = 1
		_exp.b = 2
		_exp.c = 3
		local map = _exp
		-- ▼ ReadonlyMap.size ▼
		local _size = 0
		for _ in map do
			_size += 1
		end
		-- ▲ ReadonlyMap.size ▲
		expect(_size).to.equal(3)
		map.b = nil
		-- ▼ ReadonlyMap.size ▼
		local _size_1 = 0
		for _ in map do
			_size_1 += 1
		end
		-- ▲ ReadonlyMap.size ▲
		expect(_size_1).to.equal(2)
	end)
	it("should support clear", function()
		local _exp = {}
		_exp.a = 1
		_exp.b = 2
		_exp.c = 3
		local map = _exp
		table.clear(map)
		expect(map.a ~= nil).to.equal(false)
		expect(map.b ~= nil).to.equal(false)
		expect(map.c ~= nil).to.equal(false)
		expect(map.a).never.to.be.ok()
		expect(map.b).never.to.be.ok()
		expect(map.c).never.to.be.ok()
		-- ▼ ReadonlyMap.size ▼
		local _size = 0
		for _ in map do
			_size += 1
		end
		-- ▲ ReadonlyMap.size ▲
		expect(_size).to.equal(0)
	end)
	it("should support forEach", function()
		local hitA = 0
		local hitB = 0
		local hitC = 0
		local _exp = {}
		_exp.a = 1
		_exp.b = 2
		_exp.c = 3
		local map = _exp
		local _arg0 = function(value, key, obj)
			if key == "a" and value == 1 then
				hitA += 1
			elseif key == "b" and value == 2 then
				hitB += 1
			elseif key == "c" and value == 3 then
				hitC += 1
			end
			expect(obj).to.equal(map)
		end
		for _k, _v in map do
			_arg0(_v, _k, map)
		end
		expect(hitA).to.equal(1)
		expect(hitB).to.equal(1)
		expect(hitC).to.equal(1)
	end)
	it("should support constructor parameters", function()
		local arr = { { "a", 1 }, { "b", 2 }, { "c", 3 } }
		local map = {
			a = 1,
			b = 2,
			c = 3,
		}
		local _map = {}
		for _, _v in arr do
			_map[_v[1]] = _v[2]
		end
		local map2 = _map
		local function values(map)
			local result = {}
			for _, value in map do
				table.insert(result, value)
			end
			return result
		end
		do
			local a = values(map)
			local _arg0 = function(v)
				return v == 1
			end
			-- ▼ ReadonlyArray.some ▼
			local _result = false
			for _k, _v in a do
				if _arg0(_v, _k - 1, a) then
					_result = true
					break
				end
			end
			-- ▲ ReadonlyArray.some ▲
			expect(_result).to.equal(true)
			local _arg0_1 = function(v)
				return v == 2
			end
			-- ▼ ReadonlyArray.some ▼
			local _result_1 = false
			for _k, _v in a do
				if _arg0_1(_v, _k - 1, a) then
					_result_1 = true
					break
				end
			end
			-- ▲ ReadonlyArray.some ▲
			expect(_result_1).to.equal(true)
			local _arg0_2 = function(v)
				return v == 3
			end
			-- ▼ ReadonlyArray.some ▼
			local _result_2 = false
			for _k, _v in a do
				if _arg0_2(_v, _k - 1, a) then
					_result_2 = true
					break
				end
			end
			-- ▲ ReadonlyArray.some ▲
			expect(_result_2).to.equal(true)
		end
		do
			local a = values(map2)
			local _arg0 = function(v)
				return v == 1
			end
			-- ▼ ReadonlyArray.some ▼
			local _result = false
			for _k, _v in a do
				if _arg0(_v, _k - 1, a) then
					_result = true
					break
				end
			end
			-- ▲ ReadonlyArray.some ▲
			expect(_result).to.equal(true)
			local _arg0_1 = function(v)
				return v == 2
			end
			-- ▼ ReadonlyArray.some ▼
			local _result_1 = false
			for _k, _v in a do
				if _arg0_1(_v, _k - 1, a) then
					_result_1 = true
					break
				end
			end
			-- ▲ ReadonlyArray.some ▲
			expect(_result_1).to.equal(true)
			local _arg0_2 = function(v)
				return v == 3
			end
			-- ▼ ReadonlyArray.some ▼
			local _result_2 = false
			for _k, _v in a do
				if _arg0_2(_v, _k - 1, a) then
					_result_2 = true
					break
				end
			end
			-- ▲ ReadonlyArray.some ▲
			expect(_result_2).to.equal(true)
		end
	end)
	it("should support isEmpty", function()
		local _ = next({}) == nil
		local v = next({}) == nil
		local map = {}
		local _1 = next(map) == nil
		local x = next(map) == nil
		expect(v).to.equal(true)
		map.Nope = 1
		expect(next(map) == nil).to.equal(false)
	end)
	-- it("should support the spread operator on maps", () => {
	-- 	expect(
	-- 		[
	-- 			...new Map([
	-- 				["a", 97],
	-- 				["b", 98],
	-- 			]),
	-- 			...new Map([
	-- 				["c", 99],
	-- 				["d", 100],
	-- 			]),
	-- 		].every(([l, n]) => l === string.char(n)),
	-- 	).to.equal(true);
	-- });
	it("should support the non-null assertion operator on maps", function()
		local a = {}
		local c
		c = a
		c[1] = 2
		expect(a[1]).to.equal(2)
		local b = {
			a = { 123 },
		}
		expect(b.a[1]).to.equal(123)
	end)
	it("should support creating ReadonlyMaps", function()
		local map = {
			foo = 1,
			bar = 2,
			baz = 3,
		}
		expect(map.foo).to.equal(1)
		expect(map.bar).to.equal(2)
		expect(map.baz).to.equal(3)
	end)
	it("should support creating Maps with tuple calls", function()
		local function foo()
			return { 123, "abc" }
		end
		local _map = {}
		for _, _v in { foo() } do
			_map[_v[1]] = _v[2]
		end
		local map = _map
		expect(map[123]).to.equal("abc")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="315">
        <Properties>
          <string name="Name">math.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	describe("should support basic math operators", function()
		it("should add numbers", function()
			expect(1 + 5).to.equal(6)
			expect(22 + 44).to.equal(66)
		end)
		it("should subtract numbers", function()
			expect(10 - 3).to.equal(7)
			expect(20 - 37).to.equal(-17)
		end)
		it("should multiply numbers", function()
			expect(5 * 7).to.equal(35)
			expect(8 * 12).to.equal(96)
		end)
		it("should divide numbers", function()
			expect(6 / 3).to.equal(2)
			expect(22 / 44).to.equal(0.5)
		end)
		it("should modulus numbers", function()
			expect(5 % 2).to.equal(1)
			expect(100 % 17).to.equal(15)
		end)
		it("should exponent numbers", function()
			expect(2 ^ 3).to.equal(8)
			expect(4 ^ 5).to.equal(1024)
		end)
	end)
	describe("should support math unary operators", function()
		it("should post increment", function()
			local x = 10
			x += 1
			expect(x).to.equal(11)
			local _original = x
			x += 1
			expect(_original).to.equal(11)
			expect(x).to.equal(12)
		end)
		it("should pre increment", function()
			local x = 10
			x += 1
			expect(x).to.equal(11)
			x += 1
			expect(x).to.equal(12)
			expect(x).to.equal(12)
		end)
		it("should post decrement", function()
			local x = 10
			x -= 1
			expect(x).to.equal(9)
			local _original = x
			x -= 1
			expect(_original).to.equal(9)
			expect(x).to.equal(8)
		end)
		it("should pre decrement", function()
			local x = 10
			x -= 1
			expect(x).to.equal(9)
			x -= 1
			expect(x).to.equal(8)
			expect(x).to.equal(8)
		end)
	end)
	describe("should support compound assignment", function()
		it("should compound assign addition", function()
			local x = 10
			x += 2
			expect(x).to.equal(12)
			x += 5
			expect(x).to.equal(17)
		end)
		it("should compound assign subtraction", function()
			local x = 10
			x -= 2
			expect(x).to.equal(8)
			x -= 5
			expect(x).to.equal(3)
		end)
		it("should compound assign multiplication", function()
			local x = 10
			x *= 2
			expect(x).to.equal(20)
			x *= 5
			expect(x).to.equal(100)
		end)
		it("should compound assign division", function()
			local x = 10
			x /= 2
			expect(x).to.equal(5)
			x /= 5
			expect(x).to.equal(1)
		end)
		it("should compound assign modulus", function()
			local x = 10
			x %= 2
			expect(x).to.equal(0)
			x %= 5
			expect(x).to.equal(0)
		end)
		it("should compound assign exponents", function()
			local x = 10
			x ^= 2
			expect(x).to.equal(100)
			x ^= 5
			expect(x).to.equal(100e8)
		end)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="316">
        <Properties>
          <string name="Name">namespace.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local n1 = {}
do
	local _container = n1
	local a = "a"
	_container.a = a
end
local n2 = {}
do
	local _container = n2
	local n3 = {}
	do
		local _container_1 = n3
		local a = "a"
		_container_1.a = a
	end
	_container.n3 = n3
end
local foo = {}
do
	local _container = foo
	local foo = {}
	do
		local _container_1 = foo
		local foo = {}
		do
			local _container_2 = foo
			local bar = "bar"
			_container_2.bar = bar
		end
		_container_1.foo = foo
	end
	_container.foo = foo
end
return function()
	it("should support namespaces", function()
		expect(n1.a).to.equal("a")
	end)
	it("should support nested namespaces", function()
		expect(n2.n3.a).to.equal("a")
	end)
	it("should support shadowed namespaces", function()
		expect(foo.foo.foo.bar).to.equal("bar")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="317">
        <Properties>
          <string name="Name">object.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
local N = {}
do
	local _container = N
	_container.x = 5
	local p = {
		a = {
			x = _container.x,
		},
	}
	_container.p = p
end
return function()
	it("should support object literal brackets", function()
		-- prettier-ignore 
		local obj = {
			test = 1,
			["2"] = 2,
			[1] = 3,
		}
		expect(obj.test).to.equal(1)
		expect(obj["2"]).to.equal(2)
		expect(obj[1]).to.equal(3)
	end)
	it("should support numeric indexing", function()
		local obj = {
			[2] = 1,
		}
		local i = 2
		local a = obj[i]
		local b = obj[2]
		local _binding = obj
		local c = _binding[i]
		local _binding_1 = obj
		local d = _binding_1[2]
		expect(a).to.equal(1)
		expect(b).to.equal(1)
		expect(c).to.equal(1)
		expect(d).to.equal(1)
		a = obj[i]
		b = obj[2]
		local _binding_2 = obj
		c = _binding_2[i]
		local _binding_3 = obj
		d = _binding_3[2]
		expect(a).to.equal(1)
		expect(b).to.equal(1)
		expect(c).to.equal(1)
		expect(d).to.equal(1)
		local j = 0
		local function f()
			j += 1
			return 2
		end
		local o = {
			[0] = 2,
			[1] = 4,
			[2] = 5,
			[3] = 6,
			[4] = 5,
		}
		o[f()] += 1
		local _index = f()
		local _original = o[_index]
		o[_index] += 1
		local x = _original
		expect(x).to.equal(6)
		expect(o[2]).to.equal(7)
		expect(j).to.equal(2)
	end)
	it("should support bracket index definitions", function()
		local a = {
			[1] = "foo",
			[2] = "bar",
		}
		-- prettier-ignore
		local b = {
			[1] = "baz",
			[2] = "boo",
		}
		expect(a[1]).to.equal("foo")
		expect(a[2]).to.equal("bar")
		expect(b[1]).to.equal("baz")
		expect(b[2]).to.equal("boo")
	end)
	it("should support object methods", function()
		local foo = {
			baz = "baz",
			bar = function(self)
				return "baz"
			end,
		}
		expect(foo:bar()).to.equal(foo.baz)
		local i = 0
		i += 1
		local _object = {
			count = 1,
			[i] = TS.async(function(self) end),
		}
		i += 1
		local _left = i
		_object[_left] = function()
			return 1
		end
		i += 1
		_object[tostring(i)] = TS.async(function(self) end)
		i += 1
		_object[i] = TS.async(function(self) end)
		i += 1
		local _left_1 = i
		_object[_left_1] = function()
			return 1
		end
		i += 1
		_object[tostring(i)] = TS.async(function(self) end)
		function _object:f()
		end
		_object.g = TS.async(function(self) end)
		local qq = _object:f()
	end)
	it("should support object spread", function()
		local foo = {
			a = 1,
			b = 2,
			c = 3,
		}
		local _object = {}
		for _k, _v in foo do
			_object[_k] = _v
		end
		_object.d = 4
		_object.e = 5
		_object.f = 6
		local bar = _object
		expect(bar.a).to.equal(1)
		expect(bar.b).to.equal(2)
		expect(bar.c).to.equal(3)
		expect(bar.d).to.equal(4)
		expect(bar.e).to.equal(5)
		expect(bar.f).to.equal(6)
	end)
	it("should overwrite with object spread", function()
		local foo = {
			a = 1,
			b = 2,
			c = 3,
		}
		local bar = {
			a = 2,
			b = 5,
			d = 2,
		}
		local _object = {}
		for _k, _v in foo do
			_object[_k] = _v
		end
		for _k, _v in bar do
			_object[_k] = _v
		end
		local obj0 = _object
		expect(obj0).never.to.equal(foo)
		expect(obj0).never.to.equal(bar)
		expect(obj0.a).to.equal(2)
		expect(obj0.b).to.equal(5)
		expect(obj0.c).to.equal(3)
		expect(obj0.d).to.equal(2)
		local _object_1 = {}
		for _k, _v in bar do
			_object_1[_k] = _v
		end
		for _k, _v in foo do
			_object_1[_k] = _v
		end
		local obj1 = _object_1
		expect(obj1).never.to.equal(foo)
		expect(obj1).never.to.equal(bar)
		expect(obj1.a).to.equal(1)
		expect(obj1.b).to.equal(2)
		expect(obj1.c).to.equal(3)
		expect(obj1.d).to.equal(2)
		do
			local k = {
				o = 1,
				b = 2,
			}
			local _object_2 = {}
			for _k, _v in k do
				_object_2[_k] = _v
			end
			_object_2.o = 3
			local _left = "b"
			local _original = k.o
			k.o += 1
			_object_2[_left] = _original
			local o = _object_2
			expect(o.o).to.equal(3)
			expect(o.b).to.equal(1)
		end
		do
			local k = {
				o = 1,
				b = 2,
			}
			local _object_2 = {
				o = 3,
			}
			for _k, _v in k do
				_object_2[_k] = _v
			end
			local _left = "b"
			local _original = k.o
			k.o += 1
			_object_2[_left] = _original
			local o = _object_2
			expect(o.o).to.equal(1)
			expect(o.b).to.equal(1)
		end
		do
			local k = {
				o = 1,
				b = 2,
			}
			local _object_2 = {
				o = 3,
			}
			local _left = "b"
			local _original = k.o
			k.o += 1
			_object_2[_left] = _original
			for _k, _v in k do
				_object_2[_k] = _v
			end
			local o = _object_2
			expect(o.o).to.equal(2)
			expect(o.b).to.equal(2)
		end
	end)
	it("should support numeric literals", function()
		local object1 = {
			[1] = 1,
			[2] = 1,
		}
		expect(object1[1]).to.equal(1)
		expect(object1[2]).to.equal(1)
		expect(({
			[0] = 1,
		})[0]).to.equal(1)
	end)
	it("should support computedMethodNames", function()
		do
			local o
			local function g(n)
				expect(self).to.equal(nil)
				return o:f(n)
			end
			local i = 0
			local _object = {
				g = g,
			}
			local _left = "id"
			i += 1
			_object[_left] = i
			_object.calls = 0
			i += 1
			_object[i] = function(self, n)
				return self:f(n)
			end
			function _object:f(n)
				self.calls += 1
				return self.calls
			end
			o = _object
			local b = {
				k = o,
			}
			local _fn = b.k
			expect(_fn[i](_fn, 5)).to.equal(1)
			expect(o[i](o, 5)).to.equal(2)
			expect(o:f(5)).to.equal(3)
			expect(o.g(5)).to.equal(4)
			o.calls += 1
			expect(o.calls).to.equal(5)
		end
	end)
	it("should support invalid Lua identifier members", function()
		local i = 0
		local o = {
			["$"] = function(self)
				self["$v"] += 1
				return self["$v"]
			end,
			["$v"] = 1,
		}
		local k = {
			o = o,
		}
		local fo = function()
			i += 1
			return o
		end
		local fk = function()
			i += 1
			return k
		end
		expect(o["$"](o)).to.equal(2)
		local _original = o["$v"]
		o["$v"] += 1
		expect(_original).to.equal(2)
		o["$v"] += 1
		expect(o["$v"]).to.equal(4)
		local _original_1 = o["$v"]
		o["$v"] += 1
		local x = _original_1
		expect(x).to.equal(4)
		o["$v"] += 1
		local y = o["$v"]
		expect(y).to.equal(6)
		local _fn = k.o
		expect(_fn["$"](_fn)).to.equal(7)
		local _exp = k.o
		local _original_2 = _exp["$v"]
		_exp["$v"] += 1
		expect(_original_2).to.equal(7)
		local _exp_1 = k.o
		_exp_1["$v"] += 1
		expect(_exp_1["$v"]).to.equal(9)
		local _exp_2 = k.o
		local _original_3 = _exp_2["$v"]
		_exp_2["$v"] += 1
		local a = _original_3
		expect(a).to.equal(9)
		local _exp_3 = k.o
		_exp_3["$v"] += 1
		local b = _exp_3["$v"]
		expect(b).to.equal(11)
		local _fn_1 = fo()
		expect(_fn_1["$"](_fn_1)).to.equal(12)
		local _exp_4 = fo()
		local _original_4 = _exp_4["$v"]
		_exp_4["$v"] += 1
		expect(_original_4).to.equal(12)
		local _exp_5 = fo()
		_exp_5["$v"] += 1
		expect(_exp_5["$v"]).to.equal(14)
		local _exp_6 = fo()
		local _original_5 = _exp_6["$v"]
		_exp_6["$v"] += 1
		local c = _original_5
		expect(c).to.equal(14)
		local _exp_7 = fo()
		_exp_7["$v"] += 1
		local d = _exp_7["$v"]
		expect(d).to.equal(16)
		expect(i).to.equal(5)
		local _fn_2 = fk().o
		expect(_fn_2["$"](_fn_2)).to.equal(17)
		local _exp_8 = fk().o
		local _original_6 = _exp_8["$v"]
		_exp_8["$v"] += 1
		expect(_original_6).to.equal(17)
		local _exp_9 = fk().o
		_exp_9["$v"] += 1
		expect(_exp_9["$v"]).to.equal(19)
		local _exp_10 = fk().o
		local _original_7 = _exp_10["$v"]
		_exp_10["$v"] += 1
		local e = _original_7
		expect(e).to.equal(19)
		local _exp_11 = fk().o
		_exp_11["$v"] += 1
		local f = _exp_11["$v"]
		expect(f).to.equal(21)
		expect(i).to.equal(10)
	end)
	it("should support shorthand assignments", function()
		local _exp = N.p.a
		_exp.x += 1
		expect(_exp.x).to.equal(6)
	end)
	it("should support computed members", function()
		local a = 8
		local i = 0
		local _object = {}
		local _left = a
		i += 1
		local _exp = i
		a = 9
		_object[_left] = tostring(_exp) .. tostring(a)
		local b = _object
		local c = {
			[a] = 1,
		}
		expect(b[8]).to.equal("19")
		expect(c[9]).to.equal(1)
	end)
	it("should support composing objects with methods and callbacks", function()
		local function add(self, n)
			self.n += n
			return self.n
		end
		local mul = function(self, n)
			self.n *= n
			return self
		end
		local function h(n)
			expect(n).to.equal(5)
		end
		local obj = {
			add = add,
			n = 10,
			mul = mul,
			h = h,
		}
		expect(obj:add(5)).to.equal(15)
		expect(obj:mul(3):add(6)).to.equal(51)
		obj.h(5)
	end)
	it("should support object member functions as implicitly being methods", function()
		-- don't ask me why, but for some reason non-method function members in objects are implicitly methods
		local o = {
			count = 1,
			getCount = function(self)
				return self.count
			end,
		}
		expect(o:getCount()).to.equal(1)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="318">
        <Properties>
          <string name="Name">promise.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
return function()
	it("should allow async function declarations", function()
		local foo = TS.async(function()
			return "foo"
		end)
		local bar = TS.async(function()
			return (TS.await(foo())) .. "bar"
		end)
		local success, value = bar():await()
		expect(success).to.equal(true)
		expect(value).to.equal("foobar")
	end)
	it("should allow async function expressions", function()
		local foo = TS.async(function()
			return "foo"
		end)
		local bar = TS.async(function()
			return (TS.await(foo())) .. "bar"
		end)
		local success, value = bar():await()
		expect(success).to.equal(true)
		expect(value).to.equal("foobar")
	end)
	it("should allow async arrow function expressions", function()
		local foo = TS.async(function()
			return "foo"
		end)
		local bar = TS.async(function()
			return (TS.await(foo())) .. "bar"
		end)
		local success, value = bar():await()
		expect(success).to.equal(true)
		expect(value).to.equal("foobar")
	end)
	it("should allow async static class methods", function()
		local X
		do
			X = setmetatable({}, {
				__tostring = function()
					return "X"
				end,
			})
			X.__index = X
			function X.new(...)
				local self = setmetatable({}, X)
				return self:constructor(...) or self
			end
			function X:constructor()
			end
			X.foo = TS.async(function(self)
				return "foo"
			end)
			X.bar = TS.async(function(self)
				return (TS.await(self:foo())) .. "bar"
			end)
		end
		local success, value = X:bar():await()
		expect(success).to.equal(true)
		expect(value).to.equal("foobar")
	end)
	it("should allow async class methods", function()
		local X
		do
			X = setmetatable({}, {
				__tostring = function()
					return "X"
				end,
			})
			X.__index = X
			function X.new(...)
				local self = setmetatable({}, X)
				return self:constructor(...) or self
			end
			function X:constructor()
			end
			X.foo = TS.async(function(self)
				return "foo"
			end)
			X.bar = TS.async(function(self)
				return (TS.await(self:foo())) .. "bar"
			end)
		end
		local success, value = X.new():bar():await()
		expect(success).to.equal(true)
		expect(value).to.equal("foobar")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="319">
        <Properties>
          <string name="Name">roact.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, game:GetService("ReplicatedStorage"), "include", "node_modules", "@rbxts", "roact", "src", "ts")
local _result = game:GetService("ReplicatedStorage"):FindFirstChild("include")
if _result ~= nil then
	_result = _result:FindFirstChild("node_modules")
	if _result ~= nil then
		_result = _result:FindFirstChild("@rbxts")
		if _result ~= nil then
			_result = _result:FindFirstChild("roact")
			if _result ~= nil then
				_result = _result:FindFirstChild("src")
			end
		end
	end
end
local RoactModule = _result
assert(RoactModule, "Unable to find @rbxts/roact!")
local ElementKindModule = RoactModule:FindFirstChild("ElementKind")
assert(ElementKindModule, "Unable to find ElementKind module in @rbxts/roact!")
local ElementKind = require(ElementKindModule)
local TypeModule = RoactModule:FindFirstChild("Type")
assert(TypeModule, "Unable to find Type module in @rbxts/roact!")
local Type = require(TypeModule)
return function()
	describe("should support Roact.Component", function()
		it("should construct a roact class", function()
			local RoactClass
			do
				RoactClass = Roact.Component:extend("RoactClass")
				function RoactClass:init()
				end
				function RoactClass:render()
					return Roact.createElement("Frame")
				end
			end
			expect(Type.of(RoactClass)).to.equal(Type.StatefulComponentClass)
		end)
		it("should construct a roact pure component class", function()
			local RoactPureClass
			do
				RoactPureClass = Roact.PureComponent:extend("RoactPureClass")
				function RoactPureClass:init()
				end
				function RoactPureClass:render()
					return Roact.createElement("Frame")
				end
			end
			expect(Type.of(RoactPureClass)).to.equal(Type.StatefulComponentClass)
		end)
		it("should construct default props", function()
			local RoactClass
			do
				RoactClass = Roact.Component:extend("RoactClass")
				function RoactClass:init()
				end
				function RoactClass:render()
					return Roact.createElement("Frame")
				end
				RoactClass.defaultProps = {
					value = 10,
				}
			end
			expect(RoactClass.defaultProps).to.be.a("table")
		end)
		it("should support static getDerivedStateFromProps", function()
			local RoactClass
			do
				RoactClass = Roact.Component:extend("RoactClass")
				function RoactClass:init()
				end
				function RoactClass:getDerivedStateFromProps(nextProps, lastState)
					return {
						someValue = nextProps.someValue,
					}
				end
				function RoactClass:render()
					return Roact.createElement("Frame")
				end
			end
			expect(RoactClass.getDerivedStateFromProps).to.be.a("function")
		end)
		it("should mount a roact object", function()
			local RoactClass
			do
				RoactClass = Roact.Component:extend("RoactClass")
				function RoactClass:init()
				end
				function RoactClass:render()
					return Roact.createElement("Frame")
				end
			end
			local element = Roact.createElement(RoactClass)
			expect(Type.of(element)).to.equal(Type.Element)
			local handle = Roact.mount(element)
			expect(Type.of(handle)).to.equal(Type.VirtualTree)
		end)
	end)
	it("should create roact intrinsics", function()
		local RoactIntrinsic = Roact.createElement("Frame")
		local RoactIntrinsicManual = Roact.createElement("Frame")
		-- Both should be a Frame
		expect(RoactIntrinsic.component).to.equal(RoactIntrinsicManual.component)
	end)
	describe("should support all roact property types", function()
		-- it("should be able to have keyed children", () => {
		-- 	const KEY = "key1";
		-- 	const KEY2 = "key2";
		-- 	const element = (
		-- 		<screengui>
		-- 			<frame Key={KEY} />
		-- 			<frame Key={KEY2} />
		-- 		</screengui>
		-- 	);
		-- 	const handle = Roact.mount(element);
		-- 	const frameKey = handle._children![KEY];
		-- 	const frame2Key = handle._children![KEY2];
		-- 	expect(frameKey).to.be.ok();
		-- 	expect(frame2Key).to.be.ok();
		-- });
		it("should support props", function()
			local TEXT = "Hello, World!"
			local propElement = Roact.createElement("TextButton", {
				Text = TEXT,
			})
			local propElementProps = propElement.props
			expect(propElementProps.Text).to.equal(TEXT)
		end)
		local EventHack = Roact.Event
		local ChangeHack = Roact.Change
		it("should support [Roact.Event]", function()
			local eventElement = (Roact.createElement("TextButton", {
				[Roact.Event.MouseButton1Click] = function() end,
			}))
			local eventElementProps = eventElement.props
			expect(eventElementProps[EventHack.MouseButton1Click]).to.be.a("function")
		end)
		it("should support [Roact.Change]", function()
			local eventElement = (Roact.createElement("TextButton", {
				[Roact.Change.AbsoluteSize] = function() end,
			}))
			local eventElementProps = eventElement.props
			expect(eventElementProps[ChangeHack.AbsoluteSize]).to.be.a("function")
		end)
		describe("should support [Roact.Ref]", function()
			--[[
				
								These are based basically off the Roact tests.
							
			]]
			it("should handle object references properly", function()
				local frameRef = Roact.createRef()
				Roact.mount(Roact.createElement("Frame", {
					[Roact.Ref] = frameRef,
				}))
				-- expect(frameRef.current).to.be.ok();
				expect(Type.of(frameRef)).to.equal(Type.Binding)
			end)
			it("should handle function references properly", function()
				local currentRbx
				local function ref(rbx)
					currentRbx = rbx
				end
				local element = Roact.createElement("Frame", {
					[Roact.Ref] = ref,
				})
				local handle = Roact.mount(element)
				expect(currentRbx).to.be.ok()
			end)
			it("should handle class references properly", function()
				local RoactRefTest
				do
					RoactRefTest = Roact.Component:extend("RoactRefTest")
					function RoactRefTest:init(p)
						self.ref = Roact.createRef()
					end
					function RoactRefTest:render()
						return Roact.createElement("ScreenGui", {
							[Roact.Ref] = self.ref,
						})
					end
					function RoactRefTest:didUpdate()
						expect(self.ref:getValue()).to.be.ok()
					end
				end
				Roact.mount(Roact.createElement(RoactRefTest))
			end)
			it("should handle class function references properly", function()
				local worked = false
				local RoactRefTest
				do
					RoactRefTest = Roact.Component:extend("RoactRefTest")
					function RoactRefTest:init()
						self.onScreenGuiRender = function(rbx)
							worked = true
						end
					end
					function RoactRefTest:render()
						return Roact.createElement("ScreenGui", {
							[Roact.Ref] = self.onScreenGuiRender,
						})
					end
				end
				Roact.mount(Roact.createElement(RoactRefTest))
				expect(worked).to.be.ok()
			end)
		end)
	end)
	it("should support JSX Fragments", function()
		local fragment = (Roact.createFragment({
			TestKey = Roact.createElement("Frame"),
		}))
		expect(Type.of(fragment)).to.equal(Type.Element)
		expect(ElementKind.of(fragment)).to.equal(ElementKind.Fragment)
		expect(ElementKind.of(fragment.elements.TestKey)).to.equal(ElementKind.Host)
	end)
	it("Should default to using a Fragment for top-level keys", function()
		local test = Roact.createFragment({
			Testing = Roact.createElement("Frame"),
		})
		expect(Type.of(test)).to.equal(Type.Element)
		expect(ElementKind.of(test)).to.equal(ElementKind.Fragment)
	end)
	describe("BinaryExpressions", function()
		it("should support BinaryExpressions", function()
			local ref
			local test = (Roact.createElement("Frame", {}, {
				true and Roact.createElement("Frame", {
					[Roact.Ref] = function(rbx)
						ref = rbx
						return ref
					end,
				}),
			}))
			Roact.mount(test)
			expect(ref).to.be.ok()
		end)
	end)
	describe("ConditionalExpressions", function()
		it("should support ConditionalExpressions", function()
			local ref
			local ref2
			local test = (Roact.createElement("Frame", {}, {
				if false then (Roact.createElement("Frame", {
					[Roact.Ref] = function(rbx)
						ref = rbx
						return ref
					end,
				})) else (Roact.createElement("TextLabel", {
					[Roact.Ref] = function(rbx)
						ref = rbx
						return ref
					end,
				})),
			}))
			local test2 = (Roact.createElement("Frame", {}, {
				if true then (Roact.createElement("Frame", {
					[Roact.Ref] = function(rbx)
						ref2 = rbx
						return ref2
					end,
				})) else (Roact.createElement("TextLabel", {
					[Roact.Ref] = function(rbx)
						ref2 = rbx
						return ref2
					end,
				})),
			}))
			Roact.mount(test)
			Roact.mount(test2)
			expect(ref).to.be.ok()
			local _ref = ref
			local _condition = typeof(_ref) == "Instance"
			if _condition then
				_condition = ref:IsA("TextLabel")
			end
			expect(_condition).to.equal(true)
			expect(ref2).to.be.ok()
			local _ref2 = ref2
			local _condition_1 = typeof(_ref2) == "Instance"
			if _condition_1 then
				_condition_1 = ref2:IsA("Frame")
			end
			expect(_condition_1).to.equal(true)
		end)
	end)
	it("should support nesting maps", function()
		local map = {}
		local ref
		local testLabel = Roact.createElement("TextLabel", {
			[Roact.Ref] = function(rbx)
				ref = rbx
				return ref
			end,
			Text = "Texty",
		})
		map.Testing = testLabel
		local _children = {}
		local _length = #_children
		for _k, _v in map do
			_children[_k] = _v
		end
		local element = Roact.createElement("ScreenGui", {}, _children)
		expect(Type.of(element)).to.equal(Type.Element)
		expect((element.props)[Roact.Children].Testing).to.equal(testLabel)
		Roact.mount(element)
		expect(ref).to.be.ok()
		local _ref = ref
		local _condition = typeof(_ref) == "Instance"
		if _condition then
			_condition = ref:IsA("TextLabel") and ref.Text == "Texty"
		end
		expect(_condition).to.equal(true)
	end)
	it("should support implicit true in JSX elements", function()
		local element = Roact.createElement("TextLabel", {
			TextWrapped = true,
		})
		expect((element.props).TextWrapped).to.equal(true)
	end)
	it("should have correct-order prop joining", function()
		local TestProps = {
			Active = false,
			BackgroundColor3 = Color3.fromRGB(220, 0, 0),
		}
		local _attributes = {
			Active = true,
		}
		for _k, _v in TestProps do
			_attributes[_k] = _v
		end
		_attributes.BackgroundColor3 = Color3.new(0, 0, 0)
		local element = (Roact.createElement("Frame", _attributes))
		local props = element.props
		expect(props.Active).to.equal(false)
		expect(props.BackgroundColor3).to.equal(Color3.new(0, 0, 0))
	end)
	it("should support passing identifier objects as events/changed handlers", function()
		local Events = {
			MouseEnter = function() end,
		}
		local _attributes = {}
		for _k, _v in Events do
			_attributes[Roact.Event[_k]] = _v
		end
		local f = Roact.createElement("Frame", _attributes)
		local props = f.props
		-- eslint-disable-next-line @typescript-eslint/ban-ts-ignore
		-- @ts-ignore because this is valid, but I can't infer the type for this
		expect(props[Roact.Event.MouseEnter]).to.equal(Events.MouseEnter)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="320">
        <Properties>
          <string name="Name">roact_spread.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
local Roact = TS.import(script, game:GetService("ReplicatedStorage"), "include", "node_modules", "@rbxts", "roact", "src", "ts")
return function()
	describe("Roact Spread operator", function()
		it("should spread properties", function()
			local props = {
				BackgroundColor3 = Color3.fromRGB(50, 50, 50),
			}
			local _attributes = {}
			for _k, _v in props do
				_attributes[_k] = _v
			end
			local element = Roact.createElement("Frame", _attributes)
			expect(element.props.BackgroundColor3).to.equal(props.BackgroundColor3)
		end)
		it("should support spread as well as regular properties", function()
			local props = {
				BackgroundColor3 = Color3.fromRGB(50, 50, 50),
			}
			local TextColor = Color3.fromRGB(220, 220, 220)
			local _attributes = {
				TextColor3 = TextColor,
			}
			for _k, _v in props do
				_attributes[_k] = _v
			end
			local element = Roact.createElement("TextLabel", _attributes)
			local elementProps = element.props
			expect(elementProps.BackgroundColor3).to.equal(props.BackgroundColor3)
			expect(elementProps.TextColor3).to.equal(TextColor)
		end)
		it("should support multiple spreads", function()
			local props = {
				BackgroundColor3 = Color3.fromRGB(50, 50, 50),
			}
			local props2 = {
				TextColor3 = Color3.fromRGB(220, 220, 220),
			}
			local _attributes = {}
			for _k, _v in props do
				_attributes[_k] = _v
			end
			for _k, _v in props2 do
				_attributes[_k] = _v
			end
			local element = Roact.createElement("TextLabel", _attributes)
			local elementProps = element.props
			expect(elementProps.TextColor3).to.equal(props2.TextColor3)
			expect(elementProps.BackgroundColor3).to.equal(props.BackgroundColor3)
		end)
		it("should support spreading for custom objects", function()
			local RoactClass
			do
				RoactClass = Roact.Component:extend("RoactClass")
				function RoactClass:init()
				end
				function RoactClass:render()
					return Roact.createElement("TextLabel", {
						Text = self.props.Text,
						TextColor3 = self.props.TextColor3,
					})
				end
			end
			local setValues = {
				Text = "The text here",
			}
			local _attributes = {
				TextColor3 = Color3.new(1, 0, 0),
			}
			for _k, _v in setValues do
				_attributes[_k] = _v
			end
			local element = (Roact.createElement(RoactClass, _attributes))
			local elementProps = element.props
			expect(elementProps.Text).to.equal(setValues.Text)
			expect(elementProps.TextColor3).to.equal(Color3.new(1, 0, 0))
		end)
		it("should support making templated objects", function()
			local ButtonSize
			do
				local _inverse = {}
				ButtonSize = setmetatable({}, {
					__index = _inverse,
				})
				ButtonSize.Small = 0
				_inverse[0] = "Small"
				ButtonSize.Normal = 1
				_inverse[1] = "Normal"
				ButtonSize.Large = 2
				_inverse[2] = "Large"
			end
			local smallButtonProps = {
				Size = UDim2.new(0, 150, 0, 20),
				TextSize = 12,
			}
			local normalButtonProps = {
				Size = UDim2.new(0, 200, 0, 30),
				TextSize = 20,
			}
			local largeButtonProps = {
				Size = UDim2.new(0, 300, 0, 40),
				TextSize = 30,
			}
			local buttonRef = Roact.createRef()
			local MyButton
			do
				MyButton = Roact.Component:extend("MyButton")
				function MyButton:init()
				end
				function MyButton:render()
					local _binding = self.props
					local Size = _binding.Size
					local Text = _binding.Text
					local overloadProps = {
						Text = Text,
					}
					if Size == ButtonSize.Normal then
						local _attributes = {
							[Roact.Ref] = buttonRef,
						}
						for _k, _v in normalButtonProps do
							_attributes[_k] = _v
						end
						for _k, _v in overloadProps do
							_attributes[_k] = _v
						end
						return Roact.createElement("TextButton", _attributes)
					elseif Size == ButtonSize.Large then
						local _attributes = {
							[Roact.Ref] = buttonRef,
						}
						for _k, _v in largeButtonProps do
							_attributes[_k] = _v
						end
						for _k, _v in overloadProps do
							_attributes[_k] = _v
						end
						return Roact.createElement("TextButton", _attributes)
					elseif Size == ButtonSize.Small then
						local _attributes = {
							[Roact.Ref] = buttonRef,
						}
						for _k, _v in smallButtonProps do
							_attributes[_k] = _v
						end
						for _k, _v in overloadProps do
							_attributes[_k] = _v
						end
						return Roact.createElement("TextButton", _attributes)
					else
						error("Size specified not supported.")
					end
				end
			end
			local largeButton = (Roact.createElement(MyButton, {
				Size = ButtonSize.Large,
				Text = "Large Button",
			}))
			local normalButton = (Roact.createElement(MyButton, {
				Size = ButtonSize.Normal,
				Text = "Normal Button",
			}))
			local smallButton = (Roact.createElement(MyButton, {
				Size = ButtonSize.Small,
				Text = "Small Button",
			}))
			expect((largeButton.props).Size).to.equal(ButtonSize.Large)
			expect((normalButton.props).Size).to.equal(ButtonSize.Normal)
			expect((smallButton.props).Size).to.equal(ButtonSize.Small)
			local buttons = { {
				button = largeButton,
				template = largeButtonProps,
			}, {
				button = normalButton,
				template = normalButtonProps,
			}, {
				button = smallButton,
				template = smallButtonProps,
			} }
			for _, button in buttons do
				Roact.mount(button.button)
				expect(buttonRef:getValue()).to.be.ok()
				expect(buttonRef:getValue().TextSize).to.equal(button.template.TextSize)
				expect(buttonRef:getValue().Size).to.equal(button.template.Size)
			end
		end)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="321">
        <Properties>
          <string name="Name">roblox.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support using the Roblox API", function()
		expect(game:FindFirstChild("Workspace")).to.equal(game:GetService("Workspace"))
	end)
	it("should support calling Roblox API methods with element expressions", function()
		expect(game.FindFirstChild(game, "Workspace")).to.equal(game.GetService(game, "Workspace"))
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="322">
        <Properties>
          <string name="Name">robloxEnum.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should permit the use of GetEnums()", function()
		for _, enumType in Enum:GetEnums() do
			for _1, _binding in enumType:GetEnumItems() do
				local name = _binding.Name
				expect(typeof(name)).to.equal("string")
			end
		end
	end)
	it("should permit the use of GetEnumItems()", function()
		local axisNames = {
			["X"] = true,
			["Y"] = true,
			["Z"] = true,
		}
		for _, _binding in Enum.Axis:GetEnumItems() do
			local name = _binding.Name
			expect(axisNames[name] ~= nil).to.equal(true)
		end
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="323">
        <Properties>
          <string name="Name">set.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support set constructor", function()
		local set = {
			["foo"] = true,
			["bar"] = true,
			["baz"] = true,
		}
		expect(set.foo ~= nil).to.equal(true)
		expect(set.bar ~= nil).to.equal(true)
		expect(set.baz ~= nil).to.equal(true)
		do
			local _ = {
				[1] = true,
				[2] = true,
				[3] = true,
			}
			({
				[1] = true,
				[2] = true,
				[3] = true,
			})[4] = true
			local _exp = {
				[1] = true,
				[2] = true,
				[3] = true,
			}
			_exp[4] = true
			_exp[5] = true
			local u = {
				[1] = true,
				[2] = true,
				[3] = true,
			}
			local _exp_1 = {
				[1] = true,
				[2] = true,
				[3] = true,
			}
			_exp_1[4] = true
			local v = _exp_1
			local _exp_2 = {
				[1] = true,
				[2] = true,
				[3] = true,
			}
			_exp_2[4] = true
			_exp_2[5] = true
			local w = _exp_2
			local x = function()
				return {
					[1] = true,
					[2] = true,
					[3] = true,
				}
			end
			local y = function()
				local _exp_3 = {
					[1] = true,
					[2] = true,
					[3] = true,
				}
				_exp_3[4] = true
				return _exp_3
			end
			local z = function()
				local _exp_3 = {
					[1] = true,
					[2] = true,
					[3] = true,
				}
				_exp_3[4] = true
				_exp_3[5] = true
				return _exp_3
			end
			local i = 0
			local _1 = {
				[1] = true,
				[2] = true,
				[(function()
					local _original = i
					i += 1
					return _original
				end)()] = true,
			}
			({
				[1] = true,
				[2] = true,
				[(function()
					local _original = i
					i += 1
					return _original
				end)()] = true,
			})[4] = true
			local _exp_3 = {
				[1] = true,
				[2] = true,
				[(function()
					local _original = i
					i += 1
					return _original
				end)()] = true,
			}
			_exp_3[4] = true
			_exp_3[5] = true
			local a = {
				[1] = true,
				[2] = true,
				[(function()
					local _original = i
					i += 1
					return _original
				end)()] = true,
			}
			local _exp_4 = {
				[1] = true,
				[2] = true,
				[(function()
					local _original = i
					i += 1
					return _original
				end)()] = true,
			}
			_exp_4[4] = true
			local b = _exp_4
			local _exp_5 = {
				[1] = true,
				[2] = true,
				[(function()
					local _original = i
					i += 1
					return _original
				end)()] = true,
			}
			_exp_5[4] = true
			_exp_5[5] = true
			local c = _exp_5
			local d = function()
				return {
					[1] = true,
					[2] = true,
					[(function()
						local _original = i
						i += 1
						return _original
					end)()] = true,
				}
			end
			local e = function()
				local _exp_6 = {
					[1] = true,
					[2] = true,
					[(function()
						local _original = i
						i += 1
						return _original
					end)()] = true,
				}
				_exp_6[4] = true
				return _exp_6
			end
			local f = function()
				local _exp_6 = {
					[1] = true,
					[2] = true,
					[(function()
						local _original = i
						i += 1
						return _original
					end)()] = true,
				}
				_exp_6[4] = true
				_exp_6[5] = true
				return _exp_6
			end
			expect(i).to.equal(6)
			d()
			expect(i).to.equal(7)
			e()
			expect(i).to.equal(8)
			f()
			expect(i).to.equal(9)
		end
		do
			local _set = {}
			local _array = {}
			local _length = #_array
			local _array_1 = { 1, 2, 3 }
			table.move(_array_1, 1, #_array_1, _length + 1, _array)
			for _, _v in _array do
				_set[_v] = true
			end
			local _set_1 = {}
			local _array_2 = {}
			local _length_1 = #_array_2
			local _array_3 = { 1, 2, 3 }
			table.move(_array_3, 1, #_array_3, _length_1 + 1, _array_2)
			for _, _v in _array_2 do
				_set_1[_v] = true
			end
			_set_1[4] = true
			local _set_2 = {}
			local _array_4 = {}
			local _length_2 = #_array_4
			local _array_5 = { 1, 2, 3 }
			table.move(_array_5, 1, #_array_5, _length_2 + 1, _array_4)
			for _, _v in _array_4 do
				_set_2[_v] = true
			end
			_set_2[4] = true
			_set_2[5] = true
			local _set_3 = {}
			local _array_6 = {}
			local _length_3 = #_array_6
			local _array_7 = { 1, 2, 3 }
			table.move(_array_7, 1, #_array_7, _length_3 + 1, _array_6)
			for _, _v in _array_6 do
				_set_3[_v] = true
			end
			local u = _set_3
			local _set_4 = {}
			local _array_8 = {}
			local _length_4 = #_array_8
			local _array_9 = { 1, 2, 3 }
			table.move(_array_9, 1, #_array_9, _length_4 + 1, _array_8)
			for _, _v in _array_8 do
				_set_4[_v] = true
			end
			_set_4[4] = true
			local v = _set_4
			local _set_5 = {}
			local _array_10 = {}
			local _length_5 = #_array_10
			local _array_11 = { 1, 2, 3 }
			table.move(_array_11, 1, #_array_11, _length_5 + 1, _array_10)
			for _, _v in _array_10 do
				_set_5[_v] = true
			end
			_set_5[4] = true
			_set_5[5] = true
			local w = _set_5
			local x = function()
				local _set_6 = {}
				local _array_12 = {}
				local _length_6 = #_array_12
				local _array_13 = { 1, 2, 3 }
				table.move(_array_13, 1, #_array_13, _length_6 + 1, _array_12)
				for _, _v in _array_12 do
					_set_6[_v] = true
				end
				return _set_6
			end
			local y = function()
				local _set_6 = {}
				local _array_12 = {}
				local _length_6 = #_array_12
				local _array_13 = { 1, 2, 3 }
				table.move(_array_13, 1, #_array_13, _length_6 + 1, _array_12)
				for _, _v in _array_12 do
					_set_6[_v] = true
				end
				_set_6[4] = true
				return _set_6
			end
			local z = function()
				local _set_6 = {}
				local _array_12 = {}
				local _length_6 = #_array_12
				local _array_13 = { 1, 2, 3 }
				table.move(_array_13, 1, #_array_13, _length_6 + 1, _array_12)
				for _, _v in _array_12 do
					_set_6[_v] = true
				end
				_set_6[4] = true
				_set_6[5] = true
				return _set_6
			end
			local i = 0
			local _set_6 = {}
			local _array_12 = {}
			local _length_6 = #_array_12
			local _array_13 = { 1, 2, (function()
				local _original = i
				i += 1
				return _original
			end)() }
			table.move(_array_13, 1, #_array_13, _length_6 + 1, _array_12)
			for _, _v in _array_12 do
				_set_6[_v] = true
			end
			local _set_7 = {}
			local _array_14 = {}
			local _length_7 = #_array_14
			local _array_15 = { 1, 2, (function()
				local _original = i
				i += 1
				return _original
			end)() }
			table.move(_array_15, 1, #_array_15, _length_7 + 1, _array_14)
			for _, _v in _array_14 do
				_set_7[_v] = true
			end
			_set_7[4] = true
			local _set_8 = {}
			local _array_16 = {}
			local _length_8 = #_array_16
			local _array_17 = { 1, 2, (function()
				local _original = i
				i += 1
				return _original
			end)() }
			table.move(_array_17, 1, #_array_17, _length_8 + 1, _array_16)
			for _, _v in _array_16 do
				_set_8[_v] = true
			end
			_set_8[4] = true
			_set_8[5] = true
			local _set_9 = {}
			local _array_18 = {}
			local _length_9 = #_array_18
			local _array_19 = { 1, 2, (function()
				local _original = i
				i += 1
				return _original
			end)() }
			table.move(_array_19, 1, #_array_19, _length_9 + 1, _array_18)
			for _, _v in _array_18 do
				_set_9[_v] = true
			end
			local a = _set_9
			local _set_10 = {}
			local _array_20 = {}
			local _length_10 = #_array_20
			local _array_21 = { 1, 2, (function()
				local _original = i
				i += 1
				return _original
			end)() }
			table.move(_array_21, 1, #_array_21, _length_10 + 1, _array_20)
			for _, _v in _array_20 do
				_set_10[_v] = true
			end
			_set_10[4] = true
			local b = _set_10
			local _set_11 = {}
			local _array_22 = {}
			local _length_11 = #_array_22
			local _array_23 = { 1, 2, (function()
				local _original = i
				i += 1
				return _original
			end)() }
			table.move(_array_23, 1, #_array_23, _length_11 + 1, _array_22)
			for _, _v in _array_22 do
				_set_11[_v] = true
			end
			_set_11[4] = true
			_set_11[5] = true
			local c = _set_11
			local d = function()
				local _set_12 = {}
				local _array_24 = {}
				local _length_12 = #_array_24
				local _array_25 = { 1, 2, (function()
					local _original = i
					i += 1
					return _original
				end)() }
				table.move(_array_25, 1, #_array_25, _length_12 + 1, _array_24)
				for _, _v in _array_24 do
					_set_12[_v] = true
				end
				return _set_12
			end
			local e = function()
				local _set_12 = {}
				local _array_24 = {}
				local _length_12 = #_array_24
				local _array_25 = { 1, 2, (function()
					local _original = i
					i += 1
					return _original
				end)() }
				table.move(_array_25, 1, #_array_25, _length_12 + 1, _array_24)
				for _, _v in _array_24 do
					_set_12[_v] = true
				end
				_set_12[4] = true
				return _set_12
			end
			local f = function()
				local _set_12 = {}
				local _array_24 = {}
				local _length_12 = #_array_24
				local _array_25 = { 1, 2, (function()
					local _original = i
					i += 1
					return _original
				end)() }
				table.move(_array_25, 1, #_array_25, _length_12 + 1, _array_24)
				for _, _v in _array_24 do
					_set_12[_v] = true
				end
				_set_12[4] = true
				_set_12[5] = true
				return _set_12
			end
			expect(i).to.equal(6)
			d()
			expect(i).to.equal(7)
			e()
			expect(i).to.equal(8)
			f()
			expect(i).to.equal(9)
		end
	end)
	it("should support weak sets", function()
		local set = setmetatable({}, {
			__mode = "k",
		})
		local f = Instance.new("Frame")
		set[f] = true
		expect(set[f] ~= nil).to.equal(true)
		local i = 0
		local _object = {}
		local _left = "x"
		local _original = i
		i += 1
		_object[_left] = _original
		local k = _object
		setmetatable({}, {
			__mode = "k",
		})
		setmetatable({}, {
			__mode = "k",
		})
		local _set = {}
		local _array = {}
		local _length = #_array
		local _array_1 = { {} }
		table.move(_array_1, 1, #_array_1, _length + 1, _array)
		for _, _v in _array do
			_set[_v] = true
		end
		setmetatable(_set, {
			__mode = "k",
		})
		setmetatable({
			[{}] = true,
		}, {
			__mode = "k",
		})
		local _object_1 = {}
		local _left_1 = "x"
		local _original_1 = i
		i += 1
		_object_1[_left_1] = _original_1
		setmetatable({
			[_object_1] = true,
		}, {
			__mode = "k",
		})
		local _object_2 = {}
		for _k, _v in k do
			_object_2[_k] = _v
		end
		setmetatable({
			[_object_2] = true,
		}, {
			__mode = "k",
		})
		expect(getmetatable(setmetatable({}, {
			__mode = "k",
		})).__mode).to.equal("k")
		expect(getmetatable(setmetatable({}, {
			__mode = "k",
		})).__mode).to.equal("k")
		local _set_1 = {}
		local _array_2 = {}
		local _length_1 = #_array_2
		local _array_3 = { {} }
		table.move(_array_3, 1, #_array_3, _length_1 + 1, _array_2)
		for _, _v in _array_2 do
			_set_1[_v] = true
		end
		expect(getmetatable(setmetatable(_set_1, {
			__mode = "k",
		})).__mode).to.equal("k")
		expect(getmetatable(setmetatable({
			[{}] = true,
		}, {
			__mode = "k",
		})).__mode).to.equal("k")
		local _object_3 = {}
		local _left_2 = "x"
		local _original_2 = i
		i += 1
		_object_3[_left_2] = _original_2
		expect(getmetatable(setmetatable({
			[_object_3] = true,
		}, {
			__mode = "k",
		})).__mode).to.equal("k")
		local _object_4 = {}
		for _k, _v in k do
			_object_4[_k] = _v
		end
		expect(getmetatable(setmetatable({
			[_object_4] = true,
		}, {
			__mode = "k",
		})).__mode).to.equal("k")
		local u = setmetatable({}, {
			__mode = "k",
		})
		local v = setmetatable({}, {
			__mode = "k",
		})
		local _set_2 = {}
		local _array_4 = {}
		local _length_2 = #_array_4
		local _array_5 = { {} }
		table.move(_array_5, 1, #_array_5, _length_2 + 1, _array_4)
		for _, _v in _array_4 do
			_set_2[_v] = true
		end
		local w = setmetatable(_set_2, {
			__mode = "k",
		})
		local x = setmetatable({
			[{}] = true,
		}, {
			__mode = "k",
		})
		local _object_5 = {}
		local _left_3 = "x"
		local _original_3 = i
		i += 1
		_object_5[_left_3] = _original_3
		local y = setmetatable({
			[_object_5] = true,
		}, {
			__mode = "k",
		})
		local _object_6 = {}
		for _k, _v in k do
			_object_6[_k] = _v
		end
		local z = setmetatable({
			[_object_6] = true,
		}, {
			__mode = "k",
		})
		expect(getmetatable(u).__mode).to.equal("k")
		expect(getmetatable(v).__mode).to.equal("k")
		expect(getmetatable(w).__mode).to.equal("k")
		expect(getmetatable(x).__mode).to.equal("k")
		expect(getmetatable(y).__mode).to.equal("k")
		expect(getmetatable(z).__mode).to.equal("k")
	end)
	it("should support add", function()
		local set = {}
		set.foo = true
		set.test = true
		expect(set).to.equal(set)
		expect(set.foo ~= nil).to.equal(true)
	end)
	it("should support has", function()
		local _exp = {}
		_exp.a = true
		_exp.b = true
		_exp.c = true
		local set = _exp
		local _ = set.a ~= nil
		expect(set.a ~= nil).to.equal(true)
		expect(set.b ~= nil).to.equal(true)
		expect(set.c ~= nil).to.equal(true)
		expect(set.d ~= nil).to.equal(false)
	end)
	it("should support clear", function()
		local _exp = {}
		_exp.a = true
		_exp.b = true
		_exp.c = true
		local set = _exp
		table.clear(set)
		-- ▼ ReadonlySet.size ▼
		local _size = 0
		for _ in set do
			_size += 1
		end
		-- ▲ ReadonlySet.size ▲
		expect(_size).to.equal(0)
		expect(set.a ~= nil).to.equal(false)
		expect(set.b ~= nil).to.equal(false)
		expect(set.c ~= nil).to.equal(false)
	end)
	it("should support delete", function()
		local _exp = {}
		_exp.a = true
		_exp.b = true
		_exp.c = true
		local set = _exp
		-- ▼ ReadonlySet.size ▼
		local _size = 0
		for _ in set do
			_size += 1
		end
		-- ▲ ReadonlySet.size ▲
		expect(_size).to.equal(3)
		expect(set.b ~= nil).to.equal(true)
		-- ▼ Set.delete ▼
		local _valueExisted = set.b ~= nil
		set.b = nil
		-- ▲ Set.delete ▲
		local hadB = _valueExisted
		-- ▼ Set.delete ▼
		local _valueExisted_1 = set.d ~= nil
		set.d = nil
		-- ▲ Set.delete ▲
		local hadD = _valueExisted_1
		expect(hadB).to.equal(true)
		expect(hadD).to.equal(false)
		-- ▼ ReadonlySet.size ▼
		local _size_1 = 0
		for _ in set do
			_size_1 += 1
		end
		-- ▲ ReadonlySet.size ▲
		expect(_size_1).to.equal(2)
		expect(set.b ~= nil).to.equal(false)
		expect(set.a ~= nil).to.equal(true)
		set.a = nil
		expect(set.a ~= nil).to.equal(false)
	end)
	it("should support forEach", function()
		local hitA = 0
		local hitB = 0
		local hitC = 0
		local _exp = {}
		_exp.a = true
		_exp.b = true
		_exp.c = true
		local set = _exp
		local _arg0 = function(value, value2, obj)
			expect(value).to.equal(value2)
			expect(obj).to.equal(set)
			if value == "a" then
				hitA += 1
			elseif value == "b" then
				hitB += 1
			elseif value == "c" then
				hitC += 1
			end
		end
		for _v in set do
			_arg0(_v, _v, set)
		end
		expect(hitA).to.equal(1)
		expect(hitB).to.equal(1)
		expect(hitC).to.equal(1)
	end)
	it("should support size", function()
		local _exp = {}
		_exp.a = true
		_exp.b = true
		_exp.c = true
		local set = _exp
		-- ▼ ReadonlySet.size ▼
		local _size = 0
		for _ in set do
			_size += 1
		end
		-- ▲ ReadonlySet.size ▲
		expect(_size).to.equal(3)
		set.d = true
		-- ▼ ReadonlySet.size ▼
		local _size_1 = 0
		for _ in set do
			_size_1 += 1
		end
		-- ▲ ReadonlySet.size ▲
		expect(_size_1).to.equal(4)
	end)
	it("should support isEmpty", function()
		local _ = next({}) == nil
		local v = next({}) == nil
		local set = {}
		local _1 = next(set) == nil
		local x = next(set) == nil
		expect(v).to.equal(true)
		set.Nope = true
		expect(next(set) == nil).to.equal(false)
	end)
	it("should support creating ReadonlySets", function()
		local set = {
			["foo"] = true,
			["bar"] = true,
			["baz"] = true,
		}
		expect(set.foo ~= nil).to.equal(true)
		expect(set.bar ~= nil).to.equal(true)
		expect(set.baz ~= nil).to.equal(true)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="324">
        <Properties>
          <string name="Name">string.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support string methods", function()
		expect(string.sub("Hello, world", 1, 1)).to.equal("H")
	end)
	it("should support string methods on identifiers", function()
		local str = "Hello, world"
		expect(string.sub(str, 1, 1)).to.equal("H")
	end)
	it("should support string.split", function()
		local function checkLen(len, arr)
			expect(#arr).to.equal(len)
			return arr
		end
		local str = "Hello, world"
		local _exp = { string.byte(str, 0, -1) }
		local _arg0 = function(i)
			return string.char(i)
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp)
		for _k, _v in _exp do
			_newValue[_k] = _arg0(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.map ▲
		local chars = _newValue
		local words = { "Hello", "world" }
		local hSplit = { "", "ello, world" }
		local _exp_1 = string.split(str, "")
		local _arg0_1 = function(char, i)
			return char == chars[i + 1]
		end
		-- ▼ ReadonlyArray.every ▼
		local _result = true
		for _k, _v in _exp_1 do
			if not _arg0_1(_v, _k - 1, _exp_1) then
				_result = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result).to.equal(true)
		local _exp_2 = string.split(str, ", ")
		local _arg0_2 = function(word, i)
			return word == words[i + 1]
		end
		-- ▼ ReadonlyArray.every ▼
		local _result_1 = true
		for _k, _v in _exp_2 do
			if not _arg0_2(_v, _k - 1, _exp_2) then
				_result_1 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_1).to.equal(true)
		local _exp_3 = string.split(str, "H")
		local _arg0_3 = function(word, i)
			return word == hSplit[i + 1]
		end
		-- ▼ ReadonlyArray.every ▼
		local _result_2 = true
		for _k, _v in _exp_3 do
			if not _arg0_3(_v, _k - 1, _exp_3) then
				_result_2 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_2).to.equal(true)
		expect(checkLen(1, string.split("", "a"))[1]).to.equal("")
		for i = 2, 9 do
			local _arg0_4 = i - 1
			local str = string.rep("d", _arg0_4)
			local str1 = string.split(str, "d")
			expect(#str1).to.equal(i)
			local _arg0_5 = function(c)
				return c == ""
			end
			-- ▼ ReadonlyArray.every ▼
			local _result_3 = true
			for _k, _v in str1 do
				if not _arg0_5(_v, _k - 1, str1) then
					_result_3 = false
					break
				end
			end
			-- ▲ ReadonlyArray.every ▲
			expect(_result_3).to.equal(true)
		end
		expect(#string.split("", "") == 0).to.equal(true)
		local slasher = { "", "Validark", "Osyris", "Vorlias", "" }
		local _exp_4 = checkLen(5, string.split("/Validark/Osyris/Vorlias/", "/"))
		local _arg0_4 = function(word, i)
			return word == slasher[i + 1]
		end
		-- ▼ ReadonlyArray.every ▼
		local _result_3 = true
		for _k, _v in _exp_4 do
			if not _arg0_4(_v, _k - 1, _exp_4) then
				_result_3 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_3).to.equal(true)
		local _exp_5 = checkLen(4, string.split("Validark/Osyris/Vorlias/", "/"))
		local _arg0_5 = function(word, i)
			return word == slasher[i + 1 + 1]
		end
		-- ▼ ReadonlyArray.every ▼
		local _result_4 = true
		for _k, _v in _exp_5 do
			if not _arg0_5(_v, _k - 1, _exp_5) then
				_result_4 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_4).to.equal(true)
		local _exp_6 = checkLen(3, string.split("Validark/Osyris/Vorlias", "/"))
		local _arg0_6 = function(word, i)
			return word == slasher[i + 1 + 1]
		end
		-- ▼ ReadonlyArray.every ▼
		local _result_5 = true
		for _k, _v in _exp_6 do
			if not _arg0_6(_v, _k - 1, _exp_6) then
				_result_5 = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result_5).to.equal(true)
	end)
	it("should support calling gmatch", function()
		expect((string.gmatch("Hello", ".")())).to.equal("H")
	end)
	it("should support the spread operator on strings", function()
		local array4 = { "H", "i", "y", "a" }
		local _array = {}
		local _length = #_array
		for _char in string.gmatch("Hiya", utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		local _arg0 = function(x, i)
			return x == array4[i + 1]
		end
		-- ▼ ReadonlyArray.every ▼
		local _result = true
		for _k, _v in _array do
			if not _arg0(_v, _k - 1, _array) then
				_result = false
				break
			end
		end
		-- ▲ ReadonlyArray.every ▲
		expect(_result).to.equal(true)
	end)
	it("should support string.find", function()
		local data = { string.find("Hello", "H", 1, true) }
		local _value = data[1]
		if _value ~= 0 and (_value == _value and _value) then
			expect(data[1]).to.equal(1)
			expect(data[2]).to.equal(1)
		end
		local data2 = { string.find("Hello", "e", 2, true) }
		local _value_1 = data2[1]
		if _value_1 ~= 0 and (_value_1 == _value_1 and _value_1) then
			expect(data2[1]).to.equal(2)
			expect(data2[2]).to.equal(2)
		end
	end)
	it("should support concatenating strings", function()
		expect("a" .. tostring(1) .. tostring(true) .. tostring(false)).to.equal("a1truefalse")
	end)
	it("should support variable string indices", function()
		local i = 1
		local j = 3
		local _i = i
		local _j = j
		expect(string.sub("foobar", _i, _j)).to.equal("foo")
	end)
	it("should support proper destructuring and iterating", function()
		local function compare(results, array2)
			for i = 0, #array2 - 1 do
				expect(results[i + 1]).to.equal(array2[i + 1])
			end
		end
		-- optimized destructuring
		local _array = {}
		local _length = #_array
		for _char in string.gmatch("𝟘𝟙𝟚𝟛", utf8.charpattern) do
			_length += 1
			_array[_length] = _char
		end
		compare(_array, { "𝟘", "𝟙", "𝟚", "𝟛" })
		local _array_1 = {}
		local _length_1 = #_array_1
		for _char in string.gmatch("யாமறிந்த", utf8.charpattern) do
			_length_1 += 1
			_array_1[_length_1] = _char
		end
		compare(_array_1, { "ய", "ா", "ம", "ற", "ி", "ந", "்", "த" })
		local spreadString = function(str)
			local _array_2 = {}
			local _length_2 = #_array_2
			for _char in string.gmatch(str, utf8.charpattern) do
				_length_2 += 1
				_array_2[_length_2] = _char
			end
			return _array_2
		end
		-- run-time destructuring
		compare(spreadString("𝟘𝟙𝟚𝟛"), { "𝟘", "𝟙", "𝟚", "𝟛" })
		compare(spreadString("யாமறிந்த"), { "ய", "ா", "ம", "ற", "ி", "ந", "்", "த" })
		local i = 0
		for substr in string.gmatch("𝟘𝟙𝟚𝟛", utf8.charpattern) do
			local _fn = expect(substr).to
			local _exp = { "𝟘", "𝟙", "𝟚", "𝟛" }
			local _original = i
			i += 1
			_fn.equal(_exp[_original + 1])
		end
		local j = 0
		local myStr = "யாமறிந்த"
		for substr in string.gmatch(myStr, utf8.charpattern) do
			local _fn = expect(substr).to
			local _exp = { "ய", "ா", "ம", "ற", "ி", "ந", "்", "த" }
			local _original = j
			j += 1
			_fn.equal(_exp[_original + 1])
		end
	end)
	it("should support multiline strings as an object index", function()
		local key = [[str
			ing]]
		local obj = {
			[ [[str
			ing]] ] = "foo",
		}
		expect(obj[ [[str
			ing]] ]).to.equal("foo")
		expect(obj[key]).to.equal("foo")
		obj[ [[str
			ing]] ] = "bar"
		expect(obj[ [[str
			ing]] ]).to.equal("bar")
		expect(obj[key]).to.equal("bar")
	end)
	-- issue #1467
	it([=[should support strings with \", ', and ending with ]]=], function()
		local str1 = [=[A string with a " and ' ending in a ]]=]
		expect(#str1).to.equal(37)
		local str2 = [==[A string with a " and ' ending in a ]] ]=]==]
		expect(#str2).to.equal(41)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="325">
        <Properties>
          <string name="Name">switch.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support switch statements with fall through", function()
		local function foo(s)
			repeat
				local _fallthrough = false
				if s == "a" then
					_fallthrough = true
				end
				if _fallthrough or s == "b" then
					return 1
				end
				if s == "c" then
					return 2
				end
				if s == "d" then
					if true then
						break
					end
					_fallthrough = true
				end
				if _fallthrough or s == "e" then
					return 4
				end
				return -1
			until true
			return 3
		end
		expect(foo("a")).to.equal(1)
		expect(foo("b")).to.equal(1)
		expect(foo("c")).to.equal(2)
		expect(foo("d")).to.equal(3)
		expect(foo("e")).to.equal(4)
		expect(foo("f")).to.equal(-1)
	end)
	it("should support switch statements without fall through", function()
		local function bar(s)
			repeat
				if s == "a" then
					return 1
				end
				if s == "b" then
					return 2
				end
				if s == "c" then
					return 3
				end
			until true
			return 4
		end
		expect(bar("a")).to.equal(1)
		expect(bar("b")).to.equal(2)
		expect(bar("c")).to.equal(3)
		expect(bar("d")).to.equal(4)
	end)
	it("should support switch statements with remaining empty conditions", function()
		local function bar(s)
			repeat
				local _fallthrough = false
				if s == "a" then
					return 1
				end
				if s == "b" then
					_fallthrough = true
				end
				if _fallthrough or s == "c" then
				end
			until true
			return 2
		end
		expect(bar("a")).to.equal(1)
		expect(bar("b")).to.equal(2)
		expect(bar("c")).to.equal(2)
		expect(bar("d")).to.equal(2)
	end)
	it("should support switch statements with context", function()
		local function bar(n)
			local x = 1
			repeat
				local _original = x
				x += 1
				if n == _original then
					return -1
				end
				local _original_1 = x
				x += 1
				if n == _original_1 then
					return -2
				end
			until true
			return 0
		end
		expect(bar(1)).to.equal(-1)
		expect(bar(2)).to.equal(-2)
		expect(bar(3)).to.equal(0)
	end)
	it("should support switch statements with fallthrough and context", function()
		local function bar(n)
			local x = 1
			repeat
				local _fallthrough = false
				local _original = x
				x += 1
				if n == _original then
					_fallthrough = true
				end
				if not _fallthrough then
					local _original_1 = x
					x += 1
					_fallthrough = n == _original_1
				end
				if _fallthrough then
					return -2
				end
			until true
			return 0
		end
		expect(bar(1)).to.equal(-2)
		expect(bar(2)).to.equal(-2)
		expect(bar(3)).to.equal(0)
	end)
	it("should support switch statements with preceding statements", function()
		local function bar(n)
			local x = 1
			n += 1
			repeat
				local _fallthrough = false
				local _original = x
				x += 1
				if n == _original then
					_fallthrough = true
				end
				if not _fallthrough then
					local _original_1 = x
					x += 1
					_fallthrough = n == _original_1
				end
				if _fallthrough then
					_fallthrough = true
				end
				if not _fallthrough then
					local _original_1 = x
					x += 1
					_fallthrough = n == _original_1
				end
				if _fallthrough then
					_fallthrough = true
				end
				if not _fallthrough then
					local _original_1 = x
					x += 1
					_fallthrough = n == _original_1
				end
				if _fallthrough then
					return -2
				end
			until true
			return 0
		end
		expect(bar(0)).to.equal(-2)
		expect(bar(1)).to.equal(-2)
		expect(bar(2)).to.equal(-2)
		expect(bar(3)).to.equal(-2)
		expect(bar(4)).to.equal(0)
	end)
	it("should support switch statements with a boolean value", function()
		local function foo(n)
			repeat
				if true == (n >= 10) then
					return 10
				end
				if true == (n >= 5) then
					return 5
				end
				if true == (n >= 0) then
					return 0
				end
			until true
		end
		expect(foo(10)).to.equal(10)
		expect(foo(7)).to.equal(5)
		expect(foo(5)).to.equal(5)
		expect(foo(3)).to.equal(0)
		expect(foo(0)).to.equal(0)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="326">
        <Properties>
          <string name="Name">template.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should understand string templates", function()
		local value = "hello"
		expect('"' .. (value .. ' world"')).to.equal('"hello world"')
		expect('"' .. (value .. '" world')).to.equal('"hello" world')
		expect(value .. ' "world"').to.equal('hello "world"')
		expect("a" .. ("b" .. ("c" .. ("d" .. "e")))).to.equal("abcde")
	end)
	it("should support tagged TemplateExpression", function()
		local OPERATIONS = {
			["*"] = function(a, b)
				local _a = a
				local _b = b
				return _a * _b
			end,
			["/"] = function(a, b)
				local _a = a
				local _b = b
				return _a / _b
			end,
			["+"] = function(a, b)
				local _a = a
				local _b = b
				return _a + _b
			end,
			["-"] = function(a, b)
				local _a = a
				local _b = b
				return _a - _b
			end,
		}
		local function trim(s)
			return (string.match(s, "^%s*(.-)%s*$"))
		end
		local function m(strings, ...)
			local operands = { ... }
			-- ▼ ReadonlyArray.map ▼
			local _newValue = table.create(#strings)
			for _k, _v in strings do
				_newValue[_k] = trim(_v, _k - 1, strings)
			end
			-- ▲ ReadonlyArray.map ▲
			local operators = _newValue
			local value = table.remove(operands, 1)
			table.remove(operators, 1)
			for i = 0, #operands - 1 do
				local operator = trim(operators[i + 1])
				if OPERATIONS[operator] ~= nil then
					local operation = OPERATIONS[operator]
					value = operation(value, operands[i + 1])
				end
			end
			return value
		end
		local a = Vector3.new(1, 2, 3)
		local b = Vector3.new(4, 5, 6)
		local pos = m({ "", " * ", " - ", "" }, a, b, Vector3.new(1, 2, 3))
		expect(pos.X).to.equal(3)
		expect(pos.Y).to.equal(8)
		expect(pos.Z).to.equal(15)
	end)
	it("should support tagged NoSubstitutionTemplateLiteral", function()
		local function foo(strings)
			return "baz"
		end
		expect(foo({ "bar" })).to.equal("baz")
	end)
	it("should support functions which might return void", function()
		local function foo()
			if math.random() > 1 then
				-- impossible condition, math.random will always be 0-1
				-- but this generates an optional return type for TS
				return Instance.new("Model")
			end
		end
		tonumber((foo()))
		expect("value = " .. tostring((foo()))).to.equal("value = nil")
	end)
	it("should support defined expressions", function()
		local value = 123
		expect("value = " .. tostring(value)).to.equal("value = 123")
	end)
	it("should support unknown expressions", function()
		local value = 456
		expect("value = " .. tostring(value)).to.equal("value = 456")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="327">
        <Properties>
          <string name="Name">ternary.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support ternary expressions", function()
		expect(if true then 1 else 0).to.equal(1)
		expect(if false then 1 else 0).to.equal(0)
		expect(if true then false else true).to.equal(false)
		expect(if false then false else true).to.equal(true)
	end)
	it("should support JS truthiness", function()
		local value = 123
		local zero = 0
		local emptyStr = ""
		local NaN = 0 / 0
		expect(if value ~= 0 and (value == value and value) then "PASS" else "FAIL").to.equal("PASS")
		expect(if zero ~= 0 and (zero == zero and zero) then "PASS" else "FAIL").to.equal("FAIL")
		expect(if emptyStr ~= "" and emptyStr then "PASS" else "FAIL").to.equal("FAIL")
		expect(if NaN ~= 0 and (NaN == NaN and NaN) then "PASS" else "FAIL").to.equal("FAIL")
	end)
	it("should support JS truthiness with prereqs", function()
		local value = 123
		local zero = 0
		local emptyStr = ""
		local NaN = 0 / 0
		local strA = "A"
		local strB = ""
		local _result
		if value ~= 0 and (value == value and value) then
			strA ..= "B"
			_result = strA
		else
			_result = "FAIL"
		end
		expect(_result).to.equal("AB")
		local _result_1
		if zero ~= 0 and (zero == zero and zero) then
			_result_1 = "FAIL"
		else
			strB ..= "X"
			_result_1 = strB
		end
		expect(_result_1).to.equal("X")
		local _result_2
		if emptyStr ~= "" and emptyStr then
			_result_2 = "FAIL"
		else
			strB ..= "Y"
			_result_2 = strB
		end
		expect(_result_2).to.equal("XY")
		local _result_3
		if NaN ~= 0 and (NaN == NaN and NaN) then
			_result_3 = "FAIL"
		else
			strB ..= "Z"
			_result_3 = strB
		end
		expect(_result_3).to.equal("XYZ")
	end)
	it("should correctly wrap if-expressions in parentheses where needed", function()
		local function getColorStr(on)
			return (if on then "on" else "off") .. "Color"
		end
		expect(getColorStr(true)).to.equal("onColor")
		expect(getColorStr(false)).to.equal("offColor")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="328">
        <Properties>
          <string name="Name">truthiness.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support JS truthiness", function()
		local function isTruthy(x)
			local y = not not (x ~= 0 and (x == x and (x ~= "" and x)))
			-- make sure that the expression is equivalent to an if statement
			if not not (x ~= 0 and (x == x and (x ~= "" and x))) then
				expect(y).to.equal(true)
			else
				expect(y).to.equal(false)
			end
			return y
		end
		expect(isTruthy()).to.equal(false)
		expect(isTruthy(nil)).to.equal(false)
		expect(isTruthy("")).to.equal(false)
		expect(isTruthy("Hello")).to.equal(true)
		expect(isTruthy(0)).to.equal(false)
		expect(isTruthy(1)).to.equal(true)
		expect(isTruthy(0 / 0)).to.equal(false)
		expect(isTruthy({})).to.equal(true)
		expect(isTruthy({ 1 })).to.equal(true)
		expect(isTruthy({})).to.equal(true)
		expect(isTruthy({
			a = 0,
		})).to.equal(true)
	end)
	it("should support truthiness in && expressions", function()
		local i = 0
		local function f(s)
			local _condition = s
			if _condition ~= "" and _condition then
				_condition = "Go"
			end
			local x = _condition
			local y = if s == "" then "" else "Go"
			expect(x).to.equal(y)
			local _condition_1 = s
			if _condition_1 ~= "" and _condition_1 then
				_condition_1 = "Go"
			end
			expect(_condition_1).to.equal(y)
			local _condition_2 = s
			if _condition_2 ~= "" and _condition_2 then
				local _original = i
				i += 1
				_condition_2 = _original
			end
			if _condition_2 ~= 0 and (_condition_2 == _condition_2 and (_condition_2 ~= "" and _condition_2)) then
				expect(s).to.equal("thing")
				expect(i).to.equal(2)
			end
		end
		f("")
		f("stuff")
		f("thing")
	end)
	it("should support truthiness in || expressions", function()
		local i = 0
		local function f(s)
			local _condition = s
			if not (_condition ~= "" and _condition) then
				_condition = "default"
			end
			local x = _condition
			local y = if s == "" then "default" else s
			expect(x).to.equal(y)
			local _condition_1 = s
			if not (_condition_1 ~= "" and _condition_1) then
				_condition_1 = "default"
			end
			expect(_condition_1).to.equal(y)
			local _condition_2 = s
			if not (_condition_2 ~= "" and _condition_2) then
				local _original = i
				i += 1
				_condition_2 = _original
			end
			if _condition_2 ~= 0 and (_condition_2 == _condition_2 and (_condition_2 ~= "" and _condition_2)) then
				expect(s).to.equal("stuff")
				expect(i).to.equal(1)
			end
		end
		f("")
		f("stuff")
	end)
	it("should support binary expressions", function()
		local function test(x, answers)
			local i = -1
			local _condition = x
			if _condition ~= "" and _condition then
				_condition = x == "Soup"
			end
			local _fn = expect(_condition).to
			local _exp = answers
			i += 1
			_fn.equal(_exp[i + 1])
			local _condition_1 = x
			if not (_condition_1 ~= "" and _condition_1) then
				_condition_1 = x == "Soup"
			end
			local _fn_1 = expect(_condition_1).to
			local _exp_1 = answers
			i += 1
			_fn_1.equal(_exp_1[i + 1])
			local _fn_2 = expect(not (x ~= "" and x) and x == "Soup").to
			local _exp_2 = answers
			i += 1
			_fn_2.equal(_exp_2[i + 1])
			local _fn_3 = expect(not (x ~= "" and x) or x == "Soup").to
			local _exp_3 = answers
			i += 1
			_fn_3.equal(_exp_3[i + 1])
			local _fn_4 = expect(not not (x ~= "" and x) and x == "Soup").to
			local _exp_4 = answers
			i += 1
			_fn_4.equal(_exp_4[i + 1])
			local _fn_5 = expect(not not (x ~= "" and x) or x == "Soup").to
			local _exp_5 = answers
			i += 1
			_fn_5.equal(_exp_5[i + 1])
		end
		test(nil, { nil, false, false, true, false, false })
		test("", { "", false, false, true, false, false })
		test("a", { false, "a", false, false, false, true })
		test("Soup", { true, "Soup", false, true, true, true })
	end)
	it("should support returning binary expressions", function()
		local function f(s)
			local _condition = s
			if not (_condition ~= "" and _condition) then
				_condition = "default"
			end
			return _condition
		end
		local function g(s)
			local _condition = s
			if _condition ~= "" and _condition then
				_condition = "default"
			end
			return _condition
		end
		expect(f("")).to.equal("default")
		expect(f("a")).to.equal("a")
		expect(g("")).to.equal("")
		expect(g("a")).to.equal("default")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="329">
        <Properties>
          <string name="Name">try.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("include"):WaitForChild("RuntimeLib"))
return function()
	it("should support try/catch", function()
		local x = 123
		TS.try(function()
			x = 456
		end, function(e) end)
		expect(x).to.equal(456)
	end)
	it("should support try/catch with throwing strings", function()
		local function foo()
			local exception
			TS.try(function()
				error("bar")
			end, function(e)
				exception = e
			end)
			return exception
		end
		expect(foo()).to.be.a("string")
	end)
	it("should support try/catch with throwing objects", function()
		local function foo()
			local exception
			TS.try(function()
				error({})
			end, function(e)
				exception = e
			end)
			return exception
		end
		expect(foo()).to.be.a("table")
	end)
	it("should support try/catch with return", function()
		local function foo()
			local _exitType, _returns = TS.try(function()
				return TS.TRY_RETURN, { "foo" }
			end, function(e) end)
			if _exitType then
				return unpack(_returns)
			end
		end
		expect(foo()).to.be.a("string")
	end)
	it("should support try/catch with break", function()
		local x = 0
		for i = 0, 1 do
			x += 1
			local _exitType, _returns = TS.try(function()
				return TS.TRY_BREAK
			end, function(e) end)
			if _exitType then
				break
			end
		end
		expect(x).to.equal(1)
	end)
	it("should support try/catch with continue", function()
		local x = 0
		for i = 0, 1 do
			if i % 2 == 0 then
				local _exitType, _returns = TS.try(function()
					return TS.TRY_CONTINUE
				end, function(e) end)
				if _exitType then
					continue
				end
			end
			x += 1
		end
		expect(x).to.equal(1)
	end)
	it("should support try/catch without a catch variable", function()
		local function foo()
			local exception
			TS.try(function()
				error("bar")
			end, function()
				exception = "abc"
			end)
			return exception
		end
		expect(foo()).to.equal("abc")
	end)
	it("should support try/catch with finally", function()
		local values = {}
		TS.try(function()
			table.insert(values, "A")
			error("bar")
		end, function()
			table.insert(values, "B")
		end, function()
			table.insert(values, "C")
		end)
		expect(values[1]).to.equal("A")
		expect(values[2]).to.equal("B")
		expect(values[3]).to.equal("C")
	end)
	it("should support try with finally", function()
		local values = {}
		TS.try(function()
			table.insert(values, "A")
		end, nil, function()
			table.insert(values, "C")
		end)
		expect(values[1]).to.equal("A")
		expect(values[2]).to.equal("C")
	end)
	it("should support nested try/catch with return", function()
		local function foo()
			local _exitType, _returns = TS.try(function()
				local _exitType_1, _returns_1 = TS.try(function()
					return TS.TRY_RETURN, { "foo" }
				end, function(e) end)
				if _exitType_1 then
					return _exitType_1, _returns_1
				end
			end, function(e) end)
			if _exitType then
				return unpack(_returns)
			end
		end
		expect(foo()).to.be.a("string")
	end)
	it("should support nested try/catch with break", function()
		local x = 0
		for i = 0, 1 do
			x += 1
			local _exitType, _returns = TS.try(function()
				local _exitType_1, _returns_1 = TS.try(function()
					return TS.TRY_BREAK
				end, function(e) end)
				if _exitType_1 then
					return _exitType_1
				end
			end, function(e) end)
			if _exitType then
				break
			end
		end
		expect(x).to.equal(1)
	end)
	it("should support nested try/catch with continue", function()
		local x = 0
		for i = 0, 1 do
			if i % 2 == 0 then
				local _exitType, _returns = TS.try(function()
					local _exitType_1, _returns_1 = TS.try(function()
						return TS.TRY_CONTINUE
					end, function(e) end)
					if _exitType_1 then
						return _exitType_1
					end
				end, function(e) end)
				if _exitType then
					continue
				end
			end
			x += 1
		end
		expect(x).to.equal(1)
	end)
	it("should support try/catch with multiple flow control cases", function()
		local function foo()
			local x = 0
			for i = 0, 9 do
				local _exitType, _returns = TS.try(function()
					if i == 5 then
						return TS.TRY_RETURN, { x }
					elseif i % 2 == 0 then
						return TS.TRY_CONTINUE
					end
					x += 1
				end, function() end)
				if _exitType == TS.TRY_RETURN then
					return unpack(_returns)
				elseif _exitType then
					continue
				end
			end
		end
		expect(foo()).to.equal(2)
	end)
	it("should support loops between nested try/catch with break", function()
		local function foo()
			local x = 0
			local _exitType, _returns = TS.try(function()
				for i = 0, 9 do
					local _exitType_1, _returns_1 = TS.try(function()
						if i == 5 then
							return TS.TRY_RETURN, { x }
						elseif i % 2 == 0 then
							return TS.TRY_CONTINUE
						end
						x += 1
					end, function() end)
					if _exitType_1 == TS.TRY_RETURN then
						return _exitType_1, _returns_1
					elseif _exitType_1 then
						continue
					end
				end
			end, function() end)
			if _exitType then
				return unpack(_returns)
			end
		end
		expect(foo()).to.equal(2)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="330">
        <Properties>
          <string name="Name">tuple.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should unpack function return tuples", function()
		local function foo()
			return { 101, 203 }
		end
		local _binding = foo()
		local a = _binding[1]
		local b = _binding[2]
		expect(a).to.equal(101)
		expect(b).to.equal(203)
		local c = foo()
		expect(c[1]).to.equal(101)
		expect(c[2]).to.equal(203)
		expect(foo()[1]).to.equal(101)
		expect(foo()[2]).to.equal(203)
	end)
	it("should support wrapping function results", function()
		local function foo()
			return { 1, 2, 3 }
		end
		expect(foo()[1]).to.equal(1)
		expect(foo()[2]).to.equal(2)
		expect(foo()[3]).to.equal(3)
	end)
	it("should support functions returning tuple calls", function()
		local function foo()
			return { 1, "2" }
		end
		local function bar()
			return foo()
		end
		local _binding = bar()
		local a = _binding[1]
		local b = _binding[2]
		expect(a).to.equal(1)
		expect(b).to.equal("2")
	end)
	it("should support wrapping tuple returns in tuple", function()
		local function foo()
			return { 1, "2" }
		end
		local function bar()
			return { foo(), true }
		end
		local _binding = bar()
		local _binding_1 = _binding[1]
		local a = _binding_1[1]
		local b = _binding_1[2]
		local c = _binding[2]
		expect(a).to.equal(1)
		expect(b).to.equal("2")
		expect(c).to.equal(true)
	end)
	it("should support function calls with tuple returns as expression statements", function()
		local itWorked = false
		local function foo()
			itWorked = true
			return { 1, "2" }
		end
		foo()
		expect(itWorked).to.equal(true)
	end)
	it("should support indirect tuple returns", function()
		local function foo()
			local result = { 1, 2, 3 }
			return result
		end
		local _binding = foo()
		local x = _binding[1]
		local y = _binding[2]
		local z = _binding[3]
		expect(x).to.equal(1)
		expect(y).to.equal(2)
		expect(z).to.equal(3)
	end)
	it("should allow tuples access to array functions", function()
		local function foo()
			local result = { 1, 2, 3 }
			return result
		end
		local _exp = foo()
		-- ▼ Array.pop ▼
		local _length = #_exp
		local _result = _exp[_length]
		_exp[_length] = nil
		-- ▲ Array.pop ▲
		expect(_result).to.equal(3)
	end)
	it("should unpack function return tuples with LuaTuple<T>", function()
		local function foo()
			return 101, 203
		end
		local a, b = foo()
		expect(a).to.equal(101)
		expect(b).to.equal(203)
		local c = { foo() }
		expect(c[1]).to.equal(101)
		expect(c[2]).to.equal(203)
		expect((foo())).to.equal(101)
		expect((select(2, foo()))).to.equal(203)
	end)
	it("should support functions returning tuple calls with LuaTuple<T>", function()
		local function foo()
			return 1, "2"
		end
		local function bar()
			return foo()
		end
		local a, b = bar()
		expect(a).to.equal(1)
		expect(b).to.equal("2")
	end)
	it("should support wrapping tuple returns in tuple with LuaTuple<T>", function()
		local function foo()
			return 1, "2"
		end
		local function bar()
			return { foo() }, true
		end
		local _binding, c = bar()
		local a = _binding[1]
		local b = _binding[2]
		expect(a).to.equal(1)
		expect(b).to.equal("2")
		expect(c).to.equal(true)
	end)
	it("should support function calls with tuple returns as expression statements with LuaTuple<T>", function()
		local itWorked = false
		local function foo()
			itWorked = true
			return 1, "2"
		end
		foo()
		expect(itWorked).to.equal(true)
	end)
	it("should support indirect tuple returns with LuaTuple<T>", function()
		local function foo()
			local result = { 1, 2, 3 }
			return unpack(result)
		end
		local x, y, z = foo()
		expect(x).to.equal(1)
		expect(y).to.equal(2)
		expect(z).to.equal(3)
	end)
	it("should allow tuples access to array functions with LuaTuple<T>", function()
		local function foo()
			local result = { 1, 2, 3 }
			return unpack(result)
		end
		local _exp = { foo() }
		-- ▼ Array.pop ▼
		local _length = #_exp
		local _result = _exp[_length]
		_exp[_length] = nil
		-- ▲ Array.pop ▲
		expect(_result).to.equal(3)
	end)
	it("should allow LuaTuples to have Array<> inside", function()
		local function foo()
			return 1, 2, "3"
		end
		local _exp = { foo() }
		-- ▼ Array.pop ▼
		local _length = #_exp
		local _result = _exp[_length]
		_exp[_length] = nil
		-- ▲ Array.pop ▲
		expect(_result).to.equal("3")
	end)
	it("should support assigning from LuaTuples", function()
		local function foo()
			return 101, 203
		end
		local a = 0
		local b = 0
		a, b = foo()
		expect(a).to.equal(101)
		expect(b).to.equal(203)
	end)
	it("should support assigning from LuaTuples with omitted expressions", function()
		local function foo()
			return 101, 203, 345
		end
		local a = 0
		local b = 0
		a, _, b = foo()
		expect(a).to.equal(101)
		expect(b).to.equal(345)
	end)
	it("should support nested assigning from LuaTuples", function()
		local function foo()
			return 101, { 203, 345 }
		end
		local a = 0
		local b = 0
		local _binding
		a, _binding = foo()
		b = _binding[2]
		expect(a).to.equal(101)
		expect(b).to.equal(345)
	end)
	it("should support nested assigning from LuaTuples 2", function()
		local function foo()
			return 101, {
				a = 203,
				b = 345,
			}
		end
		local a = 0
		local b = 0
		local _binding
		a, _binding = foo()
		b = _binding.b
		expect(a).to.equal(101)
		expect(b).to.equal(345)
	end)
	it("should wrap LuaTuple returns in for loop conditions", function()
		local function luaTupleReturn()
			return false
		end
		local hasRun1 = false
		while { luaTupleReturn() } do
			hasRun1 = true
			break
		end
		expect(hasRun1).to.equal(true)
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="331">
        <Properties>
          <string name="Name">type.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should properly fetch types with parenthesis and nonNull assertions", function()
		local function loop(array)
			local i = 0
			-- prettier-ignore
			for _, value in array do
				local _fn = expect(value).to
				local _original = i
				i += 1
				_fn.equal(_original)
			end
		end
		loop({ 0, 1, 2, 3 })
	end)
	it("should support instantiated expressions", function()
		local function wow(str)
			return str
		end
		local foo = wow
		expect(foo("foo")).to.equal("foo")
	end)
end
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="332">
        <Properties>
          <string name="Name">typeof.spec</string>
          <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
return function()
	it("should support typeOf", function()
		expect(typeof({})).to.equal("table")
		expect(typeof(nil)).to.equal("nil")
		expect(typeof(1)).to.equal("number")
		expect(typeof("foo")).to.equal("string")
		expect(typeof(true)).to.equal("boolean")
		expect(typeof({})).to.equal("table")
		local _vector2 = Vector2.new()
		expect(typeof(_vector2)).to.equal("Vector2")
	end)
	it("should support typeIs", function()
		expect(type({}) == "table").to.equal(true)
		expect(type(nil) == "nil").to.equal(true)
		expect(type(1) == "number").to.equal(true)
		expect(type("foo") == "string").to.equal(true)
		expect(type(true) == "boolean").to.equal(true)
		expect(type({}) == "table").to.equal(true)
		local _vector2 = Vector2.new()
		expect(typeof(_vector2) == "Vector2").to.equal(true)
		-- make sure this doesn't produce invalid Lua
		local _ = type("Hello, world!") == "string"
		local _1 = type("Hello, world!") == "string"
		local _2 = not (type("Hello, world!") == "string")
		local _3 = not (type("Hello, world!") == "string")
		local lel = not (type("Hello, world!") == "string")
		if type("Hello, world!") == "string" then
		end
		local _4 = type("s") == "table"
	end)
end
]]></string>
        </Properties>
      </Item>
    </Item>
  </Item>
  <Item class="StarterGui" referent="333">
    <Properties>
      <string name="Name">StarterGui</string>
    </Properties>
    <Item class="ModuleScript" referent="334">
      <Properties>
        <string name="Name">isolated</string>
        <string name="Source"><![CDATA[-- Compiled with roblox-ts v2.2.0
local x = 1
return {
	x = x,
}
]]></string>
      </Properties>
    </Item>
  </Item>
</roblox>