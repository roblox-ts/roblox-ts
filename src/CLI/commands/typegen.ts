import { findTsConfigPath } from "CLI/util/findTsConfigPath";
import { getRojoSourceMap, RojoSourceMap } from "CLI/util/getRojoSourceMap";
import { getTsConfigProjectOptions } from "CLI/util/getTsConfigProjectOptions";
import fs from "fs-extra";
import path from "path";
import { createProjectData, createProjectProgram, ProjectOptions } from "Project";
import { createPathTranslator } from "Project/functions/createPathTranslator";
import { DEFAULT_PROJECT_OPTIONS } from "Shared/constants";
import ts from "typescript";
import yargs from "yargs";

const BANNED_SERVICES = new Set([
	// StarterPlayer contents are cloned elsewhere at runtime. They should not be accessed directly.
	"StarterPlayer",
	// Plugins in the debugger should not be accessed directly
	"PluginDebugService",
]);

function buildSignatures(children: ReadonlyArray<RojoSourceMap>, path: ReadonlyArray<string>) {
	const seen = new Set<string>();
	const members = new Array<ts.PropertySignature>();
	for (const child of children) {
		if (child.name === "node_modules") continue;
		if (seen.has(child.name)) continue;
		seen.add(child.name);
		members.push(buildPropertySignature(child, path.concat(child.name)));
	}
	return members;
}

function buildTypeNode(sourceMap: RojoSourceMap, path: ReadonlyArray<string>) {
	const types = new Array<ts.TypeNode>();
	types.push(ts.factory.createTypeReferenceNode(sourceMap.className, undefined));
	if (sourceMap.children) {
		types.push(ts.factory.createTypeLiteralNode(buildSignatures(sourceMap.children, path)));
	}
	return ts.factory.createIntersectionTypeNode(types);
}

function buildPropertySignature(sourceMap: RojoSourceMap, path: ReadonlyArray<string>) {
	// Workspace.Terrain is `readonly` and TypeScript will complain that all declarations must have identical modifiers
	const modifiers = new Array<ts.Modifier>();
	if (path[0] === "Workspace" && path[1] === "Terrain") {
		modifiers.push(ts.factory.createModifier(ts.SyntaxKind.ReadonlyKeyword));
	}

	return ts.factory.createPropertySignature(
		modifiers,
		ts.isIdentifierText(sourceMap.name, undefined) ? sourceMap.name : `"${sourceMap.name}"`,
		undefined,
		buildTypeNode(sourceMap, path),
	);
}

interface TypeGenFlags {
	project: string;
	rojo?: string;
}

/**
 * Defines the behavior for the `rbxtsc typegen` command.
 */
export = ts.identity<yargs.CommandModule<object, TypeGenFlags>>({
	command: ["typegen"],

	describe: "Creates a `src/services.d.ts` file from `rojo sourcemap`",

	builder: () =>
		yargs
			.option("project", {
				alias: "p",
				string: true,
				default: ".",
				describe: "project path",
			})
			.option("rojo", {
				string: true,
				describe: "manually select Rojo project file",
			}),

	handler: async argv => {
		const tsConfigPath = findTsConfigPath(argv.project);

		// parse the contents of the retrieved JSON path as a partial `ProjectOptions`
		const projectOptions: ProjectOptions = Object.assign(
			{},
			DEFAULT_PROJECT_OPTIONS,
			getTsConfigProjectOptions(tsConfigPath),
			argv,
		);

		const data = createProjectData(tsConfigPath, projectOptions);
		const program = createProjectProgram(data);
		const pathTranslator = createPathTranslator(program, data);

		const rojoSourceMap = getRojoSourceMap(argv.rojo, true);

		const statements = new Array<ts.Statement>();

		if (rojoSourceMap.children) {
			for (const service of rojoSourceMap.children) {
				if (BANNED_SERVICES.has(service.name)) continue;
				if (!service.children) continue;
				const members = buildSignatures(service.children, [service.name]);
				statements.push(ts.factory.createInterfaceDeclaration([], service.name, undefined, undefined, members));
			}
		}

		if (statements.length > 0) {
			statements[0] = ts.setSyntheticLeadingComments(statements[0], [
				{
					text: " eslint-disable -- This file is generated by rbxtsc ",
					pos: -1,
					end: -1,
					hasTrailingNewLine: true,
					kind: ts.SyntaxKind.MultiLineCommentTrivia,
				},
			]);
		}

		const sourceFile = ts.factory.createSourceFile(
			statements,
			ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
			ts.NodeFlags.None,
		);

		const printer = ts.createPrinter({});
		const fileContents = printer.printFile(sourceFile);
		const filePath = path.join(pathTranslator.rootDir, "services.d.ts");
		fs.ensureDirSync(path.dirname(filePath));
		fs.writeFileSync(filePath, fileContents);
	},
});
